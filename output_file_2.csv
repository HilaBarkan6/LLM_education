question_type,has_solution,exam_year,semester,moed,question_number,url,data_resource,points,question_translation_latex,multiple_choice_answer,answer_translation_latex,number_of_possible_answers,topics_covered,dataset,translated_separately,question_in_hebrew,answer_in_hebrew,orig_answer_in_eng,should_translate,question_id,comments
D,FALSE,2001,a,b,1,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,"\textit{In a sequence of \(N\) Insert operations into a 2-3 tree (initially empty), let \(F(N)\) be the number of times a node split is performed in the tree when inserting \(N\) elements, in the worst case. Let \(G(N)\) be the total number of computer operations, when inserting \(N\) elements, in the worst case.}

\textit{What is the tightest upper bound on the ratio \(G(N)/F(N)\)?}

\begin{enumerate}
    \item \(\theta(1)\)
    \item \(\theta(\log(N))\)
    \item \(\theta(N)\)
    \item \(\theta(N \log(N))\)
    \item \(\theta\left(\frac{N}{\log(N)}\right)\)
\end{enumerate}

",na,na,na,"a, f",tested,1,"בסדרה של N פעולות Insert לעץ 2-3 (ריק מלכתחילה)
יהא F(N) מספר הפעמים שבוצע פיצול של צומת בעץ בהכנסת N איברים, במקרה הגרוע ביותר.
יהא G(N) מספר פעולות המחשב הכולל, בהכנסת N איברים, במקרה הגרוע ביותר. 

מה החסם העליון ההדוק ביותר ליחס  G(n)/F(n)?
א. θ(1)
ב. θ (Log(N))
ג. θ (N)
ד. θ (NLog(N))
ה. θ (N/Log(N))",na,,,,
D,FALSE,2001,a,b,2,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,"a,f,h",na,1,"נתונה ערמת מינימום (heap min) בגודל N. רוצים להופכה לעץ אדום שחור. ניתן לבצע זאת בזמן    worst case  של:
א. θ (Log(N))
ב. θ (N)
ג. θ ( NLog(N))
ד.  θ ( NLog(N)Log(N))
ה.  אף תשובה אינה נכונה (למעט ה').",na,,,,
D,FALSE,2001,a,b,3,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,"a,h",na,1,"נתון מבנה Heap min שרירותי בגודל N. עבור K שרירותי רוצים למצוא את האיבר ה-K הקטן ביותר  ואת האיבר ה-K הגדול ביותר  . זמן הריצה ב-worst case, של האלגוריתם הטוב ביותר למציאת שני האיברים האלו בתלות ב-K ו-N, הינו:
א. θ (Log(N))
ב. θ (N)
ג. θ ( NLog(N))
ד. θ ( KLog(K)) 
ה. θ (MIN{N, KLog(N)})
ו. θ ( (N-K)Log(N-K))",na,,,,
D,FALSE,2001,a,b,4,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,"a,d,h",na,1,"נתון מערך בגודל n3 שבו כל ערך מופיע בדיוק פעמיים. האלגוריתם היעיל היותר למיון המערך, במודל ההשוואות, פועל במקרה הגרוע בזמן:
א. Ω(n Log(n))
ב. Ω(n3 Log(n))
ג. Ω(n3 Log3(n))
ד. Ω((n Log(n))3)
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,a,b,6,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,"
Insert \(2n\) elements into a hash table with \(3n\) slots. Each slot holds a single element. In the event of a collision (mapping an element to an occupied slot), the new element is added to a common linked list for all elements.
The expected search time for an unsuccessful search in the structure (i.e., searching for a value \(x\) that does not exist in the structure) is:

\begin{enumerate}
    \item \(\Theta(1)\)
    \item \(\Theta(n)\)
    \item \(\Theta(\log(n))\)
    \item None of the above.
\end{enumerate}
",na,na,na,"a,g",untested,1,"מכניסים 2n איברים לטבלת hash עם 3n תאים. בכל תא מקום לאיבר בודד. במקרה של התנגשות (מיפוי איבר לתא תפוס) מכניסים את האיבר החדש לרשימה מקושרת משותפת לכל האיברים.
תוחלת זמן חיפוש כושל במבנה (כלומר חיפוש ערך x שלא קיים במבנה) היא:

א. Θ(1)
ב. Θ (n)
ג. Θ (log(n))
ד. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,a,b,7,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,"\noindent Given a sorted array of length $n$. In the worst case, how long does it take to convert the array into a heap using array implementation? 

\begin{enumerate}
    \item $\Theta(1)$
    \item $\Theta(n)$
    \item $\Theta(\log(n))$
    \item $\Theta(n \log(n))$
\end{enumerate}",na,na,na,"a,d,h",tested,1," נתון מערך ממוין באורך n. בכמה זמן במקרה הגרוע ניתן להפוך את המערך לערימה במימוש מערך? 

א. Θ (1)
ב. Θ (n)
ג. Θ (Log(n))
ד. Θ (nLog(n)).",na,,,,
D,FALSE,2001,a,b,8,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,a,na,1,"נתון:
f(n) = 2^(log(n)/log(3)), 
g(n) = n^2
מהו היחס ההדוק ביותר?
א. g(n) = θ(f(n)).
ב. g(n) = o(f(n)).
ג. g(n) = ω(f(n)).
ד. g(n) = O(f(n)).
ה. g(n) = Ω(f(n)).",na,,,,
D,FALSE,2001,a,b,9,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,"\text{Solve the following recurrence formula:} \\
$T(n) = 2 \cdot T\left(\frac{n}{2}\right) + n \log(n)^2$, \\
$T(n) = 10$ \text{ for } $n \leq 100$ \\
\text{a. } T(n) = $\Theta(n)$ \\
\text{b. } T(n) = $\Theta(n \log_2 n)$ \\
\text{c. } T(n) = $\Theta(n \log_3 n)$ \\
\text{d. } T(n) = $\Theta(n^2)$ \\
\text{e. None of the above.}",na,na,na,a,untested,1,"פתרו את נוסחת הנסיגה הבאה:
T(n) = 2*T(n/2) + nlog(n)^2,
T(n) = 10 for n <= 100
א.  T(n) = θ(n)
ב.   T(n) = θ(nLog2n)
ג.  T(n) = θ(nLog3n)
ד.  T(n) = θ(n2)
ה.  אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,a,b,10,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,"
Given the following string: “BAOBAB”. 

We want to write it using Huffman coding, which is defined on the letters appearing in the aforementioned string, according to their frequency of appearance in the string.

The length of the encoding (in bits) will be:

a. 6 

b. 9 

c. 10 

d. 12 

e. None of the above.
",na,na,na,p,untested,1,"נתונה המחרוזת הבאה : “BAOBAB”.
רוצים לרשום אותה בעזרת קוד הופמן, אשר מוגדר על האותיות המופיעות במחרוזת הנ""ל, לפי תדירות הופעתן במחרוזת.
אורך הקידוד (בביטים) יהיה:
א. 6
ב. 9
ג. 10
ד. 12
ה. אף אחד מהנ""ל.",na,,,,
A,FALSE,2001,a,b,11,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,na,na,1,"לקחו עץ בינארי מסודר (יש חשיבות לסדר הבנים משמאל לימין, ואם יש בן יחיד, יש חשיבות אם הוא בן שמאלי או ימני). העץ מכיל  n צמתים שממוספרים במספרים 1 עד n בסדר כלשהו. שימו לב שהעץ אינו בהכרח עץ חיפוש. ייצרו מעץ זה שני מערכים כמתואר להלן:
מערך באורך n המתאר סדר DLR של העץ.
מערך בגודל n, אשר מכיל במקום H(k) את עומק הצומת המסומן ב-k (למשל, אם k הוא השורש, H(k) = 0). 
השאלה: האם בהינתן שני המערכים הנ""ל בלבד, ניתן לשחזר ביחידות את העץ? ",na,,,,
A,FALSE,2001,a,b,12,https://docs.google.com/document/d/1m9QlOxr3Vv3z0TqwfYVvZtR-cgSUOuuc,TAU,na,na,na,na,na,na,na,1,"נתונים n קטעים [ ai, bi ].  (לכל i מתקיים ai < bi).
ידוע שלכל קטע bi הוא מספר שלם בתחום n2...1 (אבל זה לא בהכרח נכון עבור המספרים ai).
רוצים להכריע האם כל הקטעים זרים. 
מצאו אלגוריתם יעיל ככל האפשר לפתרון הבעיה הנ""ל",na,,,,
D,FALSE,2001,b,a,1,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"\text{In a sequence of } N \text{ Insert operations into an initially empty red-black tree:}

\text{Let } F(N) \text{ be the total number of rotation operations in the worst case.}

\text{Let } G(N) \text{ be the total number of computer operations in the worst case.}

\text{What is the tightest upper bound for the ratio } G(N)/F(N)?

\begin{enumerate}
    \item $\theta(1)$
    \item $\theta(\log(N))$
    \item $\theta(N)$
    \item $\theta(N \log(N))$
\end{enumerate}",na,na,na,"a,f",untested,1,"בסדרה של N פעולות Insert לעץ אדום שחור (ריק מלכתחילה):
יהא F(N) מספר פעולות הרוטציה הכולל במקרה הגרוע ביותר.
יהא G(N) מספר פעולות המחשב הכולל במקרה הגרוע ביותר. 

מה החסם העליון ההדוק ביותר ליחס  G(N)/F(N)?
א. θ(1)
ב. θ (lg(N))
ג. θ (N)
ד. θ (Nlg(N))",na,,,,
D,FALSE,2001,b,a,2,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"Given a binary tree of size \(N\). We want to ensure it is a search tree. The WC complexity of the most efficient algorithm for performing the check is: \\
a. \(\Theta(\log(N))\) \\
b. \(\Theta(N)\) \\
c. \(\Theta(N \log(N))\) \\
d. Depends on the height of the tree.",na,na,na,"a,e",untested,1,"נתון עץ בינארי בגודל N. רוצים לוודא שהוא עץ חיפוש. סיבוכיות ה-WC של האלגוריתם  היעיל ביותר לביצוע הבדיקה הוא
א. θ (lg(N))
ב. θ (N)
ג. θ ( Nlg(N))
ד. תלוי בגובה העץ. ",na,,,,
D,FALSE,2001,b,a,3,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,"a,d,k",na,1," מערך בעל n איברים יקרא ""מוגזם"" אם יש בו שלושה ערכים שכל אחד מהם מופיע לפחות n*(1-1/log(n))*3 פעמים, ושאר הערכים מופיעים לכל היותר פעמיים כל אחד. מהו החסם התחתון של ה-Worst Case של אלגוריתם מיון של מערך ""מוגזם""?
א. θ (n)
ב. θ (n lg  lg (n)) 
ג. θ (n lg (n))
ד. θ(nloglog(n)/log(n))",na,,,,
D,FALSE,2001,b,a,4,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,"a,h",na,1,"נתונות שתי ערמות מקסימום (heap max) בגודל N. רוצים לאחד אותן לערימה חוקית אחת. ניתן לבצע זאת בזמן:
א. θ (lg(N))
ב. θ (N)
ג. θ ( Nlg(N))
ד. אף תשובה אינה נכונה (למעט ד').",na,,,,
D,FALSE,2001,b,a,5,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"
Given a hash table (with a hash function randomly chosen from a universal set). In this table, collisions are resolved as follows: 
each element mapped to a non-empty cell is stored in a red-black tree shared by the entire table. 
Search is performed by checking the appropriate cell (using the hash function), 
and if the cell is not empty and the desired element is not found there, search is done in the tree. 
Let \( B \) be the size of the table, \( N \) the number of elements, and \( \alpha = \frac{N}{B} \). 
The expected unsuccessful search time is:
\begin{enumerate}
    \item \( \Theta(1 + \alpha) \) on average if \( B = \Theta(N) \).
    \item \( \Theta(1) \) on average if \( N^2 = B \); 
    \( \Theta(\log N) \) on average if \( 10 \cdot N = B \).
    \item \( \Theta(1) \) in the worst case if \( N^2 = B \) 
    (the worst case is on all sequences of \( N \) elements and function choices); 
    \( \Theta(\log N) \) in the worst case if \( 10 \cdot N = B \).
    \item \( \theta\left(\frac{\log(N-B)}{B}\right) \) on average.
\end{enumerate}
",na,na,na,"a,f,g",tested,1,"נתונה טבלת Hash (עם פונקצית Hash שנבחרת באופן אקראי מקבוצה אוניברסלית). בטבלה זו התנגשויות נפתרות באופן הבא:
כל איבר שממופה לתא שאינו ריק, נשמר בעץ אדום שחור משותף לכל הטבלה. חיפוש מתבצע על ידי בדיקת  התא המתאים (באמצעות פונקצית ה-Hash), ואם התא אינו ריק, והאיבר הרצוי אינו נמצא שם – מחפשים בעץ.
יהא B גודל הטבלה, N – מספר האיברים ו- α=N/B. 
זמן חיפוש כושל הוא:
א.   Θ(1+α) בתוחלת אם  B=Θ (N). 
ב.   Θ(1) בתוחלת אם N2=B; Θ(log N) בתוחלת אם 10⋅N=B.
ג.   Θ(1) ב-worst case  אם N2=B ( ה-worst case  הוא על כל הסדרות
      של N איברים ובחירות הפונקציות); Θ(log N) ב-worst case אם
      10⋅N=B.

ד. θ(log(N-B)/B) בתוחלת. ",na,,,,
D,FALSE,2001,b,a,6,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"\noindent Given an array with \( N \) elements. It is known that one value appears exactly \( \frac{2}{N} \) times, another value exactly \( \frac{4}{N} \) times, another value \( \frac{8}{N} \) times, etc. What is the runtime of the most efficient sorting algorithm (in the comparison model) for this array (WC)?\\
A. \( \Theta (\log (N)) \)\\
B. \( \Theta (N) \)\\
C. \( \Theta (N \log\log (N)) \)\\
D. \( \Theta (N \log (N)) \)",na,na,na,"a,d,k",untested,1,"נתון מערך עם N איברים. ידוע שערך אחד מופיע בו בדיוק 2/N פעמים, ערך נוסף בדיוק 4/N פעמים, ערך נוסף 8/N פעמים וכו'. מה זמן ריצת אלגוריתם מיון (במודל ההשוואות) היעיל ביותר למערך זה (WC).
א. θ (lg (N))
ב. θ (N).
ג. θ (N lglg (N)) 
ד. θ (N lg (N)) ",na,,,,
D,FALSE,2001,b,a,7,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"
The solution of the following recurrence relation:
\[ T(n) = n^{0.5} \cdot T(n^{0.5}) + 10 \]
is
\begin{enumerate}
    \item $\Theta(n)$
    \item $O(n^{1/2} \log n)$
    \item $O(n \log n)$
    \item $\Theta(n \log n)$
\end{enumerate}
",na,na,na,a,tested,1,"הפתרון של נוסחת הנסיגה הבאה:
T(n) = n^0.5*T(n^0.5) + 10
הוא
א. θ (n)
ב.  (n1/2  lg (n))
ג.  (n lg (n)) 
ד. θ (nlg(n)) ",na,,,,
D,FALSE,2001,b,a,8,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,a,na,1,"מי יותר גדול?
f(n) = n^(10*log(n)), g(n) = (log(n))^n


א. f(n)=O(g(n))
ב. f(n)=Ω(g(n))
ג. f(n)=Θ (g(n))
ד. f(n)=o(g(n))
ה. f(n) = ω(g(n))",na,,,,
D,FALSE,2001,b,a,9,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,"a,h",na,1,"נתונה ערימה (heap-max) בגודל N שבה כל הערכים שונים זה מזה. הפעולה DECREASE_KEY( P, VAL) מקבלת כקלט מצביע P לאחד מאברי הערימה וערך VAL. התוצאה המתקבלת הינה ערימה  אשר בה, יורד ערכו של האיבר אליו הצביע P. 
לדוגמא, אם P הצביע לאיבר עם ערך 12 ערכו החדש יהיה VAL-12.
בהנתן כי P מצביע לאיבר ה-K-י בגודלו בערימה (יש בדיוק 1-K איברים קטנים ממנו), באיזו יעילות ניתן לבצע 
את DECREASE_KEY( P, VAL)  ?


א. θ (lg(k))
ב. θ (lg (n))
ג. θ (lg(n/k))
ד. θ (min(k,log n))",na,,,,
D,FALSE,2001,b,a,10,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,"Define the distance between two nodes in a tree as the length of the shortest path between them. What is the maximum possible distance between a pair of nodes in a red-black tree with \( N \) nodes?

\begin{enumerate}
    \item[a.] \(\log_2(N) \pm \Theta(1)\)
    \item[b.] \(2\log_2(N) \pm \Theta(1)\)
    \item[c.] \(3\log_2(N) \pm \Theta(1)\)
    \item[d.] \(4\log_2(N) \pm \Theta(1)\)
\end{enumerate}",na,na,na,f,tested,1,"נגדיר מרחק בין שני צמתים בעץ כאורך המסלול הקצר ביותר ביניהם. מהו המרחק המקסימלי האפשרי בין זוג צמתים בעץ אדום שחור בעל N צמתים?

LOG2(N) ± Θ(1) 
ב.2LOG2(N) ± Θ (1)   
ג.  3LOG2(N) ± Θ (1)
ד.  4LOG2(N) ± Θ (1)",na,,,,
A,FALSE,2001,b,a,11.a,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,na,na,1,"נתון מערך שבו ה-OS(i) (האיבר ה-i בגודלו) נמצא באחד המקומות
i-k,i-k+1,….,i+k-1,i+k. מצאו אלגוריתם יעיל ככל הניתן למיון מערך זה.",na,,,,
A,FALSE,2001,b,a,11.b,https://docs.google.com/document/d/1oTX1kHKgw8iBufPGBn9d1Tzmll5dgOIz,TAU,na,na,na,na,na,na,na,1,"נתון מערך שבו ה-OS(i) (האיבר ה-i בגודלו) נמצא באחד המקומות
i-k,i-k+1,….,i+k-1,i+k.  מצאו חסם תחתון במודל ההשוואות לאלגוריתמי מיון שהקלט שלהם הוא הזה. הוכיחו את נכונות החסם התחתון. ",na,,,,
D,FALSE,2001,b,b,1,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,na,na,na,na,"a,f",na,1,"בסדרה של N פעולות Insert לעץ 2-3 (ריק מלכתחילה):
יהא F(N) מספר פעולות הוספת צומת חדש (new) הכולל במקרה הגרוע ביותר.
יהא G(N) מספר פעולות המחשב הכולל במקרה הגרוע ביותר. 

מה החסם העליון ההדוק ביותר ליחס  G(n)/F(n)?
א. θ(1)
ב. θ (lg(N))
ג. θ (N)
ד. θ (Nlg(N))
ה. θ (N/lg(N))",na,,,,
D,FALSE,2001,b,b,2,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,"\noindent
Given a minimum heap of size \( N \). We want to transform it into a red-black tree. This can be done in worst-case time of:
\begin{enumerate}
    \item \(\Theta(\log(N))\)
    \item \(\Theta(N)\)
    \item \(\Theta(N \log(N))\)
    \item \(\Theta(N \log(N) \log(N))\)
    \item None of the answers is correct (except for e).
\end{enumerate}",na,na,na,"a,f,h",untested,1,"נתונה ערמת מינימום (heap min) בגודל N. רוצים להופכה לעץ אדום שחור. ניתן לבצע זאת בזמן    worst case  של:
א. θ (lg(N))
ב. θ (N)
ג. θ ( Nlg(N))
ד.  θ ( Nlg(N)lg(N))
ה.  אף תשובה אינה נכונה (למעט ה').",na,,,,
D,FALSE,2001,b,b,3,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,na,na,na,na,"a,h",na,1,"נתון מבנה Heap min שרירותי בגודל N. עבור K שרירןתי רוצים למצוא את האיבר ה-K הקטן ביותר  ואת האיבר ה-K הגדול ביותר  . זמן הריצה ב-worst case, של האלגוריתם הטוב ביותר למציאת שני האיברים האלו בתלות ב-K ו-N, הינו:
א. θ (lg(N))
ב. θ (N)
ג. θ ( Nlg(N))
ד. θ ( Klg(K)) 
ה. θ (MIN{N, Klg(N)})
ו. θ ( (N-K)lg(N-K))",na,,,,
D,FALSE,2001,b,b,4,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,"
Given an array of size \( n^3 \) where each value appears exactly twice. The most efficient algorithm for sorting the array, in the comparison model, operates in the worst case at the time:

\begin{enumerate}
    \item \( \Omega(n \log(n)) \)
    \item \( \Omega(n^3 \log(n)) \)
    \item \( \Omega(n^3 \log^3(n)) \)
    \item \( \Omega((n \log(n))^3) \)
    \item None of the above
\end{enumerate}
",na,na,na,"a,d,k",tested,1,"נתון מערך בגודל n3 שבו כל ערך מופיע בדיוק פעמיים. האלגורית היעיל היותר למיון המערך, במודל ההשוואות, פועל במקרה הגרוע בזמן:
א. Ω(n lg(n))
ב. Ω(n3 lg(n))
ג. Ω(n3 lg3(n))
ד. Ω((n lg(n))3)
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,b,b,5,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,"
Implement a queue using two stacks, where each stack is implemented using a priority queue (heap). Perform a sequence of \( n \) enqueue or dequeue operations (in some order) starting from an empty data structure.
The average time per operation (in the most efficient implementation possible) is:

A. \( O(1) \) \\
B. \( O(\log n) \) \\
C. \( O(n) \) \\
D. \( O(n \log n) \) \\
E. None of the above.
",na,na,na,"a,h",tested,1,"ממשים תור בעזרת שתי מחסניות, כאשר כל מחסנית ממומשת בעזרת תור קדימויות (ערימה). מבצעים סידרה של n פעולות הכנסה או הוצאה מהתור (בסדר כלשהו) כשבהתחלה מבנה הנתונים ריק. 
הזמן הממוצע לפעולה בודדת (במימוש יעיל ככל האפשר) הוא:

א. O(1)
ב. O(lg(n))
ג. O(n)
ד. O(n lg(n))
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,b,b,6,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,na,na,na,na,a,na,1,"נתונים n קטעים [ ai, bi ].  (לכל i מתקיים ai < bi).
ידוע שלכל קטע bi הוא מספר שלם בתחום n3...1 (אבל זה לא בהכרח נכון עבור המספרים ai).
רוצים להכריע האם כל הקטעים זרים. ניתן לבצע זאת בזמן

א. O(n)
ב. O(n lg(n))
ג. O(n lg3(n))
ד. O(n3 lg 3 (n))
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,b,b,7,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,"""The comparison model +"" is like the comparison model, except that when comparing two elements \(a\) and \(b\), one can receive one of the following five answers:
\(a = b\)
\(a\) is greater than ten elements (or more) that are greater than \(b\).
\(b\) is greater than ten elements (or more) that are greater than \(a\).
\(a\) is greater than \(b\) but there are fewer than ten elements whose value is between \(a\) and \(b\).
\(b\) is greater than \(a\) but there are fewer than ten elements whose value is between \(a\) and \(b\).

A lower bound for the W.C. of a sorting algorithm in the comparison model + is:\\
a. \(\Omega(1)\)\\
b. \(\Omega(\log(n))\)\\
c. \(\Omega(n)\)\\
d. \(\Omega(n \log(n))\)\\
e. None of the above.\\",na,na,na,"a,k",tested,1,"""מודל ההשוואות +"" הוא כמו מודל ההשואות, אלא שבהשוואת זוג איברים a ו-b אפשר לקבל אחת מחמש מהתשובות הבאות:
a = b
a גדול מעשרה איברים (או יותר) שגדולים מ-b.
b גדול מעשרה איברים (או יותר) שגדולים מ-a.
a גדול מ-b אבל יש פחות מעשרה איברים שערכם בין a ל-b.
b גדול מ-a אבל יש פחות מעשרה איברים שערכם בין a ל-b.

חסם תחתון ל-W.C. של אלגוריתם מיון במודל ההשוואות + הוא:
א. Ω(1)
ב. Ω(lg(n))
ג. Ω(n)
ד. Ω(n lg(n))
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2001,b,b,8,https://docs.google.com/document/d/1WrQhJhuDshuffTfuKpQvOh2PtYD6TLs9,TAU,na,"
Insert \(2n\) elements into a hash table with \(3n\) cells. Each cell can hold a single element. In case of a collision (mapping an element to an occupied cell), the new element is inserted into a common linked list for all elements. The expected time of an unsuccessful search in the structure (i.e., searching for a value \(x\) that does not exist in the structure) is:

A. \(O(1)\) \\
B. \(O(n)\) \\
C. \(O(\log(n))\) \\
D. None of the above.

",na,na,na,"a,d,g",untested,1,"מכניסים 2n איברים לטבלת hash עם 3n תאים. בכל תא מקום לאיבר בודד. במקרה של התנגשות (מיפוי איבר לתא תפוס) מכניסים את האיבר החדש לרשימה מקושרת משותפת לכל האיברים.
תוחלת זמן חיפוש כושל במבנה (כלומר חיפוש ערך x שלא קיים במבנה) היא:

א. O(1)
ב. O(n)
ג. O(lg(n))
ד. אף אחד מהנ""ל.",na,,,,
D,TRUE,2002,a,a,2,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,"\noindent Consider a red-black tree as studied in class and described in Cormen (all Nils are considered leaves and their color is black). Let the height of a node \( y \) be defined as the length of the longest path (counted in nodes) upwards to \( y \). The count does not include \( y \) and the discussed nil. Let \( x \) be a node that is removed (note: the intention is the node removed and not the value removed) in the delete operation (as studied in class in a binary search tree). We are interested in the height of \( x \) before the removal. Then:
\begin{enumerate}
    \item The tightest upper bound on the height of \( x \) is 0.
    \item The tightest upper bound on the height of \( x \) is 1.
    \item The tightest upper bound on the height of \( x \) is 2.
    \item The tightest upper bound on the height of \( x \) is 3.
    \item There is no upper bound on the height of \( x \).
\end{enumerate}",2,na,5,p,tested,1,"התייחסו לעץ אדום שחור כפי שנלמד בכיתה ומתואר ב-Cormen (כל ה-Nils נחשבים כעלים וצבעם הוא שחור). יהי הגובה של צומת y  מוגדר כאורך המסלול (נספר בצמתים) הארוך ביותר מעלה ל-y. הספירה לא כוללת את y ואת ה-nil הנידון. יהי x  צומת שמושמט (שימו לב: הכוונה לצומת המושמט ולא לערך המושמט) בפעולת ה-delete  (כמו שנלמד בכיתה בעץ חיפוש בינארי). הננו מעוניינים בגובהו של x לפני ההשמטה. אזי:
1. החסם העליון ההדוק ביותר על גובהו של x  הינו 0 .
2. החסם העליון ההדוק ביותר על גובהו של x  הינו 1 .
3. החסם העליון ההדוק ביותר על גובהו של x  הינו 2.
4. החסם העליון ההדוק ביותר על גובהו של x  הינו 3.
5. אין חסם עליון על גובהו של x  .",na,,,,
D,TRUE,2002,a,a,3,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,3,"\noindent A family of functions \( H = \{h \mid h : M \to \{1, 2, \ldots, n\}\} \) is called universal if for all different \( x, y \) in \( M \), the number of functions \( h \) in \( H \) for which \( h(x) = h(y) \) is the size of \( H \) divided by \( n \).

A family of functions \( H = \{h \mid h : M \to \{1, 2, \ldots, n\}\} \) is called 2-universal if for all different \( x, y \) in \( M \), the pair \( (h(x), h(y)) \) is uniformly distributed over the set \(\{(i, j) \mid 1 \leq i, j \leq n\}\).

Is it true that every 2-universal family is universal?

1. Yes

2. No

",1,na,2,g,tested,1,"משפחת פונקציות{{ H = {h|h:M -> {1,2,..,n נקראת אוניברסלית אם לכל x, y שונים ב-M, מספר הפונקציות h ב- H עבורם (h(x שווה ל h(y)a היא כגודלה של H חלקי n.

משפחת פונקציות {{ H = {h|h:M -> {1,2,..,n נקראת 2-אוניברסלית אם לכל x, y שונים ב-M, הזוג    <(h(x),h(y> מתפלג אחיד מהקבוצה {<i, j>| 1 <= i, j <= n}. 

האם נכון שכל משפחה 2-אוניברסלית היא אוניברסלית?

1. כן
2. לא",na,,,,
D,TRUE,2002,a,a,4,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,3,"\noindent A family of functions $H = \{h \mid h: M \to \{1,2,\ldots,n\}\}$ is called universal if for every distinct $x, y$ in $M$, the number of functions $h$ in $H$ for which $h(x) = h(y)$ is equal to the size of $H$ divided by $n$. \\
A family of functions $H = \{h \mid h: M \to \{1,2,\ldots,n\}\}$ is called almost-universal if for every distinct $x, y$ in $M$, if we choose $h$ uniformly from $H$, then the probability that $h(x) = h(y)$ is less than $\frac{2}{n}$. \\

\noindent Is it true that every universal family is almost-universal? \\
1. Yes \\
2. No",1,na,2,g,tested,1,"משפחת פונקציות  H = {h|h:M -> {1,2,..,n}} נקראת אוניברסלית אם לכל x, y שונים ב-M, מספר הפונקציות h ב- H עבורם  h(x) = h(y) היא כגודלה של H חלקי n.
משפחת פונקציות  H = {h|h:M -> {1,2,..,n}} נקראת כמעט-אוניברסלית אם לכל x, y שונים ב-M, אם נבחר h באופן אחיד מתוך H אזי ההסתברות ש h(x) = h(y) קטנה מ 2/n.

האם נכון שכל משפחה אוניברסלית היא כמעט אוניברסלית?
1. כן
2. לא",na,,,,
D,TRUE,2002,a,a,5,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,"Given an array of size \( n \) where all its values are from the set \(\{1,2,\ldots,n^{\log\log(n)}\}\). It is possible to sort the elements of the array:\\

1. In time \(\theta(n)\) on average\\
2. In time \(\theta(n)\) in the worst case\\
3. In time \(\theta(n\log(n))\) in the worst case\\
4. In time \(\theta(n\log\log(n))\) in the worst case\\
5. In time \(\theta\left(\frac{n\log(n)}{\log\log(n)}\right)\) in the worst case\\
6. In time \(\theta\left(\frac{n\log(n)}{\log\log(n)}\right)\) on average",4,na,6,"a,l",tested,1,"נתון מערך בגודל  nשכל ערכיו מהקבוצה {1,2,...,n^(loglog(n))}. אזי ניתן למיין את איברי המערך:
1. בזמן θ(n) במקרה הממוצע
2. בזמן θ(n) במקרה הגרוע 
3. בזמן θ(nlog(n)) במקרה הגרוע
4. בזמן θ(nloglog(n)) במקרה הגרוע.
5. בזמן θ(nlog(n)/loglog(n)) במקרה הגרוע
6. בזמן θ(nlog(n)/loglog(n)) במקרה הממוצע",na,,,,
D,TRUE,2002,a,a,6,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,"
Given an array with \( n \) elements where \( n^{2001/2002} \) of the elements are identical. The array can be sorted in worst-case time (mark the tightest bound, assuming the RAM model):
\begin{enumerate}
    \item \( \Theta(n) \)
    \item \( \Theta(n^{1/2002}\log(n)) \)
    \item \( \Theta(n\log(n)^{1/2002}) \)
    \item \( \Theta(n^{2001/2002}\log(n)) \)
    \item \( \Theta(n\log(n)^{2001/2002}) \)
    \item \( \Theta(n\log(n)) \)
\end{enumerate}
",6,na,6,"a,j,m",tested,1,"נתון מערך עם n איברים בו n^(2001/2002) מהאיברים זהים. ניתן למיין את המערך בזמן worst case (יש לסמן את התשובה ההדוקה ביותר, בהנחת מודל RAM):
1, θ(n)
2. θ(n^(1/2002)log(n))
3. θ(nlog(n)^(1/2002))
4. θ(n^(2001/2002)log(n))
5. θ(nlog(n)^(2001/2002))
6. θ(nlog(n))",na,,,,
D,TRUE,2002,a,a,7,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,na,3,na,4,h,na,1,"נדפיס את איברי ערימת מקסימום  עם n איברים בסדר preorder (שימו לב: preorder=DLR!). אזי בהנחה ש n  גדול (לדוגמה 2002<n), אילו מהבאים נכון:

1. איבר המינימום יכול להופיע במקום הראשון
2. איבר המינימום תמיד יופיע באחד מ n/2 + 1 המקומות האחרונים
3. איבר המינימום יכול להופיע במקום ה log(n) + 1
4. אם הערימה מלאה לגמרי גם בשכבה התחתונה אז איבר המינימום יופיע בדיוק במקום ה n/2",na,,,,
D,TRUE,2002,a,a,8,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,na,5,na,6,b,na,1,"בהינתן מבנה נתונים ריק וסדרה כלשהי של n פעולות עליו - זמן Amortized של פעולה במבנה הנתונים יוגדר כזמן הכולל של n הפעולות מחולק ב n.
נתונה מחסנית התומכת בפעולות:
Pop() בזמן O(1)
Push(x) בזמן O(1)
PopLog() בזמן O(log n) - השולפת log n איברים מראש המחסנית (כאשר n הוא מספר האיברים הנוכחי במחסנית)

אזי בהינתן סדרה כלשהי של n פעולות המתחילה במחסנית ריקה, זמן  Amortizedשל פעולה במחסנית הוא:

1. θ(loglog(n))
2.θ(n)  
3. θ(log(n/log(n)))
4. θ(n/log(n))
5. θ(1)
6. θ(log(n))",na,,,,
D,TRUE,2002,a,a,9,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,6,na,2,na,4,"a,d",na,1,"נתון מערך עם m איברים. n המקומות הראשונים מכילים את הערך 1 והשאר מכילים 0 (n לא ידוע). רוצים למצוא את n. ניתן לעשות זאת בזמן (worst case) היעיל ביותר:

1. θ(1)
2. θ(log(n))
3. θ(min{n, m})
4. θ(m)",na,,,,
D,TRUE,2002,a,a,10,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,5,"Given a queue of natural numbers \( Q_1 \) with \( n \) elements. We want to sort the elements in \( Q_1 \), meaning that at the end of the sorting algorithm's run, \( Q_1 \) will contain the same elements as at the beginning, only in sorted order. The sorting algorithm is allowed to use one additional queue \( Q_2 \) with \( O(n) \) elements and an additional \( O(1) \) memory. Then, there exists such a sorting algorithm as follows:\\
1. Its running time is \( O(n^3) \) and uses principles similar to Bubble Sort.\\
2. Its running time is \( O(n^2) \) and uses principles similar to Bubble Sort.\\
3. Its running time is \( O(n^3\log(n)) \) and uses principles similar to Quick Sort (meaning the version of Quick Sort with a running time of \( O(n\log(n)) \) in the worst case).\\
4. Its running time is \( O(n^2\log(n)) \) and uses principles similar to Quick Sort (meaning the version of Quick Sort with a running time of \( O(n\log(n)) \) in the worst case).\\
5. Its running time is \( O(n^2\log(n)) \) and uses principles similar to Merge Sort.\\
6. Its running time is \( O(n\log(n)) \) and uses principles similar to Merge Sort.",6,na,6,"a,j,m,p",tested,1,"נתון תור של מספרים טבעיים Q1 עם n איברים. רוצים למיין את האיברים ב Q1, כלומר בסיום ריצת אלגוריתם המיון Q1 יכיל את אותם האיברים כמו בתחילת הריצה רק בסדר ממוין. מותר לאלגוריתם המיון להשתמש בתור אחד נוסף Q2 עם O(n) איברים ובעוד O(1) זיכרון נוסף. אזי קיים אלגוריתם כנ""ל למיון 
1. שזמן ריצתו O(n^3) והמשתמש בעקרונות הדומים ל Bubble Sort
2. שזמן ריצתו O(n^2) והמשתמש בעקרונות הדומים ל Bubble Sort
3. שזמן ריצתו O(n^3log(n)) והמשתמש בעקרונות הדומים ל Quick Sort (הכוונה לגרסת Quick Sort בעלת זמן ריצה O(nlog(n)) במקרה הגרוע)
4. שזמן ריצתו O(n^2log(n)) והמשתמש בעקרונות הדומים ל  Quick Sort(הכוונה לגרסת Quick Sort בעלת זמן ריצה O(nlog(n)) במקרה הגרוע)
5. שזמן ריצתו O(n^2log(n)) והמשתמש בעקרונות הדומים ל Merge Sort
6. שזמן ריצתו O(nlog(n)) והמשתמש בעקרונות הדומים ל Merge Sort",na,,,,
C,TRUE,2002,a,a,11,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,13,na,5,na,7,"a,f",na,1,"רוצים לבנות מבנה נתונים לתחזוקת מספרים טבעיים התומך בפעולות insert(x), delete(x), find(x), , עבור מספר טבעי x, ובפעולת  multiple_of_5() המחזירה שני ערכים שונים במבנה x, y המקימים y=5x. אזי קיים מבנה כנ""ל בו (אנו מעוניינים במבנה התומך בפעולות עם סיבוכיות הטובה ביותר) (4 נקודות):
1. פעולות insert(x), delete(x) נעשות בזמן O(log(n)^2) במקרה הגרוע, ופעולות find(x), multiple_of_5()  נעשות בזמן O(log(n)) במקרה הגרוע.
2. פעולות insert(x), delete(x) נעשות בזמן O(log(n)^2) במקרה הגרוע, ופעולות  find(x), multiple_of_5() נעשות בזמן O(log(n)) במקרה הגרוע.
3. פעולות insert(x), find(x), delete(x) נעשות בזמן O(log n) במקרה הגרוע, ופעולת multiple_of_5() נעשית בזמן O(n^2) במקרה הגרוע.
4. פעולות insert(x), delete(x) נעשות בזמן O(log(n)^2) במקרה הגרוע, פעולת  find(x) נעשית בזמן O(log(n)) ופעולת multiple_of_5() נעשית בזמן O(n) במקרה הגרוע.
5. פעולות insert(x), find(x), delete(x) נעשות בזמן O(log n) במקרה הגרוע, ופעולת multiple_of_5() נעשית בזמן O(1) במקרה הגרוע.
6. פעולות insert(x), find(x), delete(x) נעשות בזמן O(log n) במקרה הגרוע, ופעולת multiple_of_5() נעשית בזמן O(n) במקרה הגרוע.
7. כל הפעולות נעשות בזמן O(log n) במקרה הגרוע","התשובה הנכונה היא ה'.
מבנה הנתונים יהיה עץ 2-3 (או עץ חיפוש מאוזן אחר) שמכיל את כל האיברים. רשימה דו כיוונית שמכילה את הזוגות שהמנה ביניהם היא 5. כמו כן יש הצבעות הדדיות בין האיברים בשני המבנים.
פעולות הוספה, מחיקה וחיפוש מבוצעות על העץ. במקרה של הוספה ומחיקה יש לעדכן גם את הרשימה (כלומר להוסיף או להוריד זוג מהרשימה, לפי הצורך).
פעולת Multiple_of_5() תבוצע על ידי החזרת ראש הרשימה המקושרת.",,,,
A,FALSE,2002,a,a,12,https://docs.google.com/document/d/1UoJdnerEFxl6OfCgPoKIRk-N_cj2xNo1,TAU,10,na,na,na,na,na,na,1,"זוג ערכים במערך נקראים עוקבים אם הם שונים ולאחר מיון הם נמצאים במקומות סמוכים במערך. בהינתן מערך של מספרים טבעיים בגודל n, הציעו אלגוריתם (בעל סיבוכיות worst case הטובה ביותר) הבודק האם יש זוג ערכים עוקבים שסכום המופעים של שניהם ביחד הוא לפחות  (כלומר מספר הפעמים שמופיע ערך מסוים ועוד מספר הפעמים שמופיע הערך העוקב לו יהיה לפחות ).","ניתן לפתור ב-O(n)   Worst case בכמה דרכים בהתבססות על order statistics. למשל, פתרון שמתבסס על העקרונות הבאים )  בלא פרוט פרטים טכניים): 
מציאת חציון – O(n) (סמנו ב-M)
מציאת האיבר הקטן ביותר הגדול מהחציון (H) (אם יש) – O(n)
מציאת האיבר הגדול ביותר הקטן מהחציון (L) (אם יש(– O(n)
ספירת הופעות של M, L, H – O(n)
אם כמות ההופעות הכוללת של M ו-H או של M ו-L מקיימת את התנאי התשובה חיובית. אחרת שלילית. ",,,,
D,FALSE,2002,b,a,1,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"\noindent We propose a new algorithm for sorting an array:

\begin{itemize}
    \item If the size of the array is at most 2, sort it in constant time.
    \item Otherwise:
    \begin{enumerate}
        \item Sort the first two-thirds of the array (recursively).
        \item Sort the last two-thirds of the array (recursively).
        \item Sort again the first two-thirds of the array.
    \end{enumerate}
\end{itemize}

The running time of the above algorithm is:
\begin{enumerate}
    \item $\theta(n\log(n))$
    \item $\theta(n\log(n)^{1.5})$
    \item $\theta(n^{1.5}\log(n))$
    \item $\theta(n^{\log(3)/\log(1.5)})$
    \item $\theta(n^{\log(3)/\log(2/3)})$
    \item $\theta(n)$
\end{enumerate}",na,na,na,"a,c,d",tested,1,"נציע אלגוריתם חדש למיון מערך:

אם גודל המערך לכל היותר 2 – מיין אותו בזמן קבוע.
אחרת: 
מיין את שני השלישים הראשונים של המערך (ברקורסיה)
מיין את שני השלישים האחרונים של המערך (ברקורסיה)
מיין שוב את שני השלישים הראשונים של המערך

זמן הריצה של האלגוריתם הנ""ל הוא:
א. θ(nlog(n))
ב. θ(nlog(n)^1.5) 
ג. θ(n^1.5log(n))
ד. θ(n^(log(3)/log(1.5))))
ה. θ(n^(log(3)/log(2/3)))) 
ו. θ(n)",na,,,,
D,FALSE,2002,b,a,2,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"Given the functions:

\[ f(n) = (\log(n)^{0.5})^n, \]
\[ g(n) = n^{\log(n)^{0.5}} \]

Which of the following is correct?\\

1. \( f = \Theta(g, 1) \)\\
2. \( f = o(g) \) (small-o, 2).\\
3. \( g = o(f) \) (small-o, 3).\\
4. None of the above.",na,na,na,a,tested,1,"f(n) = (log(n)^0.5)^n,
g(n) = n^(log(n)^0.5)
מה מהבאים נכון ?

f = Θ(g ,1 ) 
f = o(g)    (o .2 קטן).
g = o(f)   (o .3  קטן).
4. אף אחד מהנ""ל",na,,,,
D,FALSE,2002,b,a,3,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"
Given two max heaps implemented with arrays, each containing \( n \) elements. We want to merge them into a single max heap, in the most efficient W.C. running time, in the comparison model. The time is:

a. \( \Theta(1) \)

b. \( \Theta(\log(n)) \)

c. \( \Theta((\log(n))^2) \)

d. \( \Theta(n) \)

e. \( \Theta(n\log(n)) \)
",na,na,na,"a,h",untested,1,"נתונות שתי ערימות מקסימום במימוש מערך, המכילות n איברים כל אחת. רוצים לאחד אותן לערימת מקסימום יחידה, בזמן ריצה W.C. היעיל ביותר, במודל ההשוואות. הזמן הוא:

א. θ(1)
ב. θ(log(n)) 
ג. θ(log(n)^2)
ד. θ(n)
ה. θ(nlog(n))",na,,,,
D,FALSE,2002,b,a,4,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,na,na,na,na,"a,b",na,1," נתון מבנה A שתומך בפעולות Insert, Delete, Find. אם נתון שזמן Amortized לפעולה הוא  θ(log(n)), אז יתכן שפעולת Insert לוקחת ב-W.C.:
א. θ(loglog(n))
ב. θ(log(n)) 
ג. θ(n)
ד. א+ב
ה. ב+ג
ו. א+ב+ג",na,,,,
D,FALSE,2002,b,a,5,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"
Given an array of size \( n^3 \) that contains \( n^2 \) different values, the most efficient algorithm to sort the array runs in W.C. time:

A. \( \theta(n^2\log(n)) \)

B. \( \theta(n^3) \)

C. \( \theta(n^3\log(n)) \)

D. \( \theta(n^3\log(n)) \)

E. \( \theta(n^3\log(n)^2) \)

F. \( \theta(n^3\log(n)^3) \)
",na,na,na,"a,d",tested,1,"נתון מערך בגודל n^3 שבו יש n^2 ערכים שונים. אלגוריתם למיון המערך, היעיל ביותר רץ בזמן W.C.: 

א. θ(n^2log(n))
ב. θ(n^3) 
ג. θ(n^3log(n))
ד. θ(n^3log(n))
ה. θ(n^3log(n)^2) 
ו. θ(n^3log(n)^3)",na,,,,
D,FALSE,2002,b,a,6,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,na,na,na,na,"a,d",na,1,"נתון מספר k ומערך A בגודל n. המערך ""כמעט ממוין"" כלומר כל איבר נמצא במרחק לכל היותר log(n) מקומות ממקומו במערך הממוין. רוצים אלגוריתם יעיל ביותר (ב-W.C.)  לחיפוש הערך k במערך A. ניתן לעשות זאת בזמן:
א. θ(nlog(n))
ב. θ(n)  
ג. θ(n/log(n)) 
ד. θ(log(n)^2)
ה. θ(log(n)) 
ו. θ(loglog(n))",na,,,,
D,FALSE,2002,b,a,7,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"
We want an algorithm that receives an input of an array of size \( n \), and prints the order statistics \( n/2, n/2 + 1, n/2 + 2, \ldots, n/2 + \log(n) \), that is, the median and the \(\log(n)\) elements that would follow it if the array were sorted. This can be done in W.C. time (the most efficient):

\begin{enumerate}
    \item \(\theta(n \log(n))\)
    \item \(\theta(n)\)
    \item \(\theta\left(\frac{n}{\log(n)}\right)\)
    \item \(\theta(\log(n)^2)\)
    \item \(\theta(\log(n))\)
\end{enumerate}
",na,na,na,"a,d",untested,1,"רוצים אלגוריתם שמקבל קלט מערך בגודל n, ומדפיס את הסדרים הסטטיסטים  n/2,n/2 + 1,n/2 + 2,...,n/2 + log(n) כלומר את החציון ואת log(n) האיברים שהיו באים אחריו לו המערך היה ממוין. אפשר לבצע זאת בזמן W.C. (היעיל ביותר):
א. θ(nlog(n))
ב. θ(n)  
ג. θ(n/log(n)) 
ד. θ(log(n)^2)
ה. θ(log(n))",na,,,,
D,FALSE,2002,b,a,8,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,"\noindent Given two search trees $T_1$ and $T_2$, each containing $n$ keys. It is known that all the keys in $T_2$ are greater than all the keys in $T_1$. The trees are joined into a single tree named $T$ as follows: \\
Let $x$ be a new node, which will be defined as the root of the tree. $T_2$ will be attached as the right child of $x$ and $T_1$ will be attached as the left child of $x$. The key value of $x$ will be defined as any number that is greater than all keys in $T_1$ and smaller than all keys in $T_2$. \\
In which of the following cases is it guaranteed that the tree $T$ is valid?

\begin{itemize}
    \item A. When the trees are regular binary search trees.
    \item B. When the trees are AVL search trees.
    \item C. When the trees are 2-3 search trees.
    \item D. A + B
    \item E. A + C
    \item F. A + B + C
\end{itemize}",na,na,na,"e,f",tested,1,"נתונים שני עצי חיפוש T1  ו-T2, שמכילים n מפתחות כל אחד. ידוע שכל המפתחות ב-T2 גדולים מכל המפתחות ב-T1.  מחברים את העצים לעץ אחד בשם T באופן הבא: 
יהי x צומת חדש, שיוגדר להיות השורש של העץ. T2  יחובר כבן ימני של x ו-T1 יחובר כבן שמאלי של x. ערך המפתח של x יוגדר להיות מספר כלשהו שגדול מכל המפתחות ב-T1 וקטן מכל המפתחות ב-T2.
באיזה מהמקרים הבאים מובטח שהעץ T הוא חוקי ?

א. כשהעצים הם עצי חיפוש רגילים.
ב. כשהעצים הם עצי חיפוש AVL.
ג. כשהעצים הם עצי חיפוש 3-2.
ד. א + ב
ה. א + ג
ו. א + ב + ג",na,,,,
A,FALSE,2002,b,a,9,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (על ידי נקודות התחלה וסיום). רוצים להכריע האם קיימים שני קטעים שנחתכים בנקודה אחת.  (כלומר האם קיימת נקודה שמוכלת בלפחות שניים מ-n הקטעים הנ""ל). 
טענה: ניתן לבצע זאת בזמן W.C. O(nloglog(n)) במודל ההשוואות.",na,,,,
A,FALSE,2002,b,a,10,https://docs.google.com/document/d/1ARR0v5jx5FzYIqxWEbptDtL2r0-6A1B9,TAU,na,na,na,na,na,na,na,1,"רוצים מבנה נתונים שתומך בפעולות איתחול, הכנסה וחיפוש.
פעולת האיתחול מבוצעת על קבוצת מספרים בגודל n. 
פעולת הכנסה של איבר תבוצע לכל היותר log(n) פעמים. 
דרישות מהמבנה:
זיכרון: θ(n) 
זמן W.C.: 	פעולת הכנסה: O(loglog(n)) 
פעולת חיפוש: O(loglog(n)) 
פעולת איתחול: לא מוגבל",na,,,,
D,FALSE,2003,a,a,1,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,na,na,na,4,a,na,1,"T(n) = T(n/4) + T(3n/4) + 1
רמז: אפשר להשתמש בעץ רקורסיה.
א. T(n) = θ(n)
ב. T(n) = θ(n^(log(4)/log(3))) 
ג. T(n) = θ(nlog(n))
ד. T(n) = θ(n^0.75)",na,,,,
D,FALSE,2003,a,a,2,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,4,na,na,na,2,a,na,1,"אם f(n) = θ(g(n))  (ושתיהן פונקציות מונוטוניות עולות מהטבעיים לטבעיים) אז בהכרח:
log(f(n)) = θ(log(g(n)))
א. נכון
ב. לא נכון",na,,,,
D,FALSE,2003,a,a,3,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,4,"
If \( f(n) = \theta(g(n)) \) (and both are monotonically increasing functions from the naturals to the naturals) then necessarily:

\( 2^{f(n)} = \theta(2^{g(n)}) \)

\begin{enumerate}
    \item True
    \item False
\end{enumerate}
",na,na,2,a,tested,1,"אם f(n) = θ(g(n))  (ושתיהן פונקציות מונוטוניות עולות מהטבעיים לטבעיים) אז בהכרח:
2^f(n) = θ(2^g(n)) 
א. נכון
ב. לא נכון",na,,,,
D,FALSE,2003,a,a,4,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,na,na,na,5,e,na,1," בסריקת DLR (PreOrder)  של עץ חיפוש בגובה h יופיע האיבר המינימלי במקום:
א. הראשון
ב. האחרון
ג. אחד מ-h המקומות הראשונים.
ד. אחד מ-h המקומות האחרונים.
ה. אף אחד מהנ""ל.",na,,,,
D,FALSE,2003,a,a,5,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,"
Given a data structure that supports the operations Insert, ExtractMax (not necessarily implemented as a heap).
Assuming the comparison model, give the highest lower bound for the amortized time of an operation in the structure.
(Reminder – in amortized time calculation, the series may contain any sequence of operations, and we are interested in the series that leads to the worst-case time).
a. \( \Omega(1) \)
b. \( \Omega(\log\log(n)) \)
c. \( \Omega(\log(n)) \)
d. \( \Omega(n) \)
e. \( \Omega(n\log(n)) \)
f. \( \Omega\left(\frac{n}{\log(n)}\right) \)
",na,na,6,b,tested,1,"נתון  מבנה נתונים התומך בפעולות Insert, ExtractMax (לא בהכרח במימוש ערימה).
בהנחת מודל ההשוואות, תנו חסם תחתון (הגבוה ביותר) לזמן Amortize של פעולה במבנה.
(תזכורת – בחישוב זמן Amortize הסידרה יכולה להכיל כל רצף של פעולות, והננו מעונינים בסדרה המוליכה לזמן הגרוע ביותר).
א. Ω(1)
ב. Ω(loglog(n)) 
ג. Ω(log(n))
ד. Ω(n)
ה. Ω(nlog(n)) 
ו. Ω(n/log(n))",na,,,,
D,FALSE,2003,a,a,6,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,"\noindent Given an array of size $n$. We want an algorithm that finds a triple of elements in the array: $x, y, z$ such that: $x + y = z$. If there is no such triple, the algorithm returns 'no'. The fastest (on average) algorithm to solve the problem runs in average time:

\begin{enumerate}
    \item $O(n^2)$
    \item $O(n^2 \log(n))$
    \item $O(n^3)$
    \item $O(n^3 \log(n))$
    \item $O(n^2 \log(n)^2)$
\end{enumerate}",na,na,5,a,tested,1,"נתון מערך בגודל n. רוצים אלגוריתם המוצא שלשה של איברים במערך: x,y,z כך ש:
x  + y = z. אם אין שלשה כזו, האלגוריתם מחזיר 'לא'.
האלגוריתם המהיר ביותר (ממוצע) לפתרון הבעיה פועל  בזמן ממוצע:

א. O(n^2)
ב. O(n^2log(n)) 
ג. O(n^3)
ד. O(n^3log(n))
ה. O(n^2log(n)^2)",na,,,,
D,FALSE,2003,a,a,7,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,"\noindent Given an array of size $n$, we want an algorithm that finds a triplet of elements in the array: $x, y, z$ such that $x + y = z$. If no such triplet exists, the algorithm returns 'no'. Propose the fastest algorithm (worst case) for solving this problem: \\
The running time of the algorithm is: \\
a. $O(n \log n)$ \\
b. $O(n^2)$ \\
c. $O(n^2 \log n)$ \\
d. $O(n^3)$ \\
e. $O(n^3 \log n)$ \\
f. $O(n^2 \log^2 n)$",na,na,6,a,untested,1,"נתון מערך בגודל n. רוצים אלגוריתם המוצא שלשה של איברים במערך: x,y,z כך ש:
x  + y = z. אם אין שלשה כזו, האלגוריתם מחזיר 'לא'.
הציעו את האלגוריתם המהיר ביותר (W.C) לפתרון הבעיה :
זמן האלגוריתם הוא:
א. O(nlog(n))
ב. O(n^2) 
ג. O(n^2log(n))
ד. O(n^3)
ה. O(n^3log(n)) 
ו. O(n^2log(n)^2)",na,,,,
D,FALSE,2003,a,a,8,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,4,"
Given a max-heap of size \( n \) with positive keys. The root key is \( n \). It is known that the key of each node is half the key of its parent. Then necessarily:
The sum of all keys is \(\theta(n)\)
A. True
B. False
",na,na,2,h,untested,1," נתונה ערימת מקסימום בגודל n של מפתחות חיוביים. מפתח השורש הוא n. ידוע שהמפתח של כל צומת קטן פי 2 מהמפתח של אבא שלו. אזי בהכרח:
סכום כל המפתחות הוא θ(n)
א. נכון
ב. לא נכון",na,,,,
D,FALSE,2003,a,a,9,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,4,"\subsection*{Given Question}

A maximum heap of size $n$ consisting of positive keys is given. The root key is $n$. It is known that the key of each node is half that of its parent. Therefore, necessarily:
The sum of the keys of the leaves is $\Theta(n)$
(A) True
(B) False",na,na,2,h,tested,1,"נתונה ערימת מקסימום בגודל n של מפתחות חיוביים. מפתח השורש הוא n. ידוע שהמפתח של כל צומת קטן פי 2 מהמפתח של אבא שלו. אזי בהכרח:
סכום המפתחות של העלים הוא θ(n) 
א. נכון
ב. לא נכון",na,,,,
D,FALSE,2003,a,a,10,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,"
They changed the MergeSort algorithm: at each stage, instead of dividing the array into two equal parts, a number \(i\) between 1 and the size of the array minus one is randomly chosen (where 1 is chosen with probability \(\frac{2}{n}\) and the others with probability \(\frac{1}{n}\)), and the array is divided into one part of size \(i\) and a second part - the remaining elements. The rest of the algorithm remains unchanged. Below is the Pseudo-code of the new algorithm:

\texttt{MergeSort2(A,p,q)}\\
\texttt{if p = q then return}\\
\(i = \texttt{random number from (1…q – p)}\)\\
\texttt{MergeSort2 (A, p, p + i - 1)}\\
\texttt{MergeSort2 (A, p + i , q)}\\
\texttt{Merge (A, p, p + i - 1, q)}

The running time of the above algorithm is:
\begin{enumerate}
    \item Average \(\Theta(n\log(n))\), worst-case \(\Theta(n^2)\)
    \item Average \(\Theta(n^2)\), worst-case \(\Theta(n^2)\)
    \item Average \(\Theta(n)\), worst-case \(\Theta(n\log(n))\)
    \item Average \(\Theta(n)\), worst-case \(\Theta(n^2)\)
    \item Average \(\Theta(n\log(n))\), worst-case \(\Theta(n\log(n))\)
\end{enumerate}
",na,na,5,m,untested,1,"שינו את אלגוריתם MergeSort: בכל שלב, במקום לחלק את המערך לשני חלקים שווים, מגרילים מספר i בין 1 לגודל המערך פחות אחד (כאשר 1 מתקבל בהסתברות 2/n והשאר בהסתברות 1/n), ומחלקים את המערך לחלק אחד בגודל i  וחלק שני  - שאר האיברים. יתר האלגוריתם ללא שינוי. להלן Pseudo-code של האלגוריתם החדש:

MergeSort2(A,p,q)
if p = q then return
i = random number from (1…q – p )
MergeSort2 (A, p, p + i - 1)
MergeSort2 (A, p + i , q)
Merge (A, p, p + i - 1, q)

זמן הריצה של האלגוריתם הנ""ל הוא:
א. ממוצע θ(nlog(n)), גרוע ביותר θ(n^2)
ב. ממוצע θ(n^2), גרוע ביותר θ(n^2) 
ג. ממוצע θ(n), גרוע ביותר θ(nlog(n))
ד. ממוצע θ(n), גרוע ביותר θ(n^2) 
ה. ממוצע θ(nlog(n)), גרוע ביותר θ(nlog(n))",na,,,,
A,FALSE,2003,a,a,11.a,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,7,na,na,na,na,na,na,1,"נתונות n נקודות במישור. כל נקודה מיוצגת על ידי זוג סדור (x,y) (הנקודה (5,6) שונה מהנקודה (6,5) ). הציעו מבנה נתונים התומך בפעולות:
Insert(x,y) – מוסיפה למבנה את הנקודה (x,y).
Delete(x,y) – מוחקת מהמבנה את הנקודה (x,y) אם היתה במבנה. אחרת לא עושה כלום.
Member(x,y) – מחזירה True  אם הנקודה (x,y) במבנה. אחרת מחזירה False.

סיבוכיות ה-W.C. של כל הפעולות הנ""ל צריכה להיות O(log n)",na,,,,
A,FALSE,2003,a,a,11.b,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,7,na,na,na,na,na,na,1,"נתונות n נקודות במישור. כל נקודה מיוצגת על ידי זוג סדור (x,y) (הנקודה (5,6) שונה מהנקודה (6,5) ). הציעו מבנה נתונים התומך בפעולות:
Insert(x,y) – מוסיפה למבנה את הנקודה (x,y).
Delete(x,y) – מוחקת מהמבנה את הנקודה (x,y) אם היתה במבנה. אחרת לא עושה כלום.
Member(x,y) – מחזירה True  אם הנקודה (x,y) במבנה. אחרת מחזירה False.
סיבוכיות ה-W.C. של כל הפעולות הנ""ל צריכה להיות O(log n). הציעו איך ניתן לממש את הנ""ל ובנוסף את הפעולה Larger(a,b) . 
הפעולה הזו מדפיסה את כל הנקודות (x,y) שמקיימות x>a  וגם את כל הנקודות (x,y)  שמקיימות  y>b . זמן W.C.  לפעולה הוא  O(k + log n) כאשר k הוא מספר האיברים שיודפסו.
זמן הפעולות מהסעיף הקודם ללא שינוי.",na,,,,
A,FALSE,2003,a,a,12.a,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,7,na,na,na,na,na,na,1,נתונים שני עצי 2-3 T1  ו-T2 בגודל n1 ו-n2 בהתאמה. הציעו אלגוריתם שמאחד את שני העצים לעץ 2-3 חוקי בזמן W.C. O(n1+n2).,na,,,,
A,FALSE,2003,a,a,12.b,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,7,na,na,na,na,na,na,1,"נתונים שני עצי 2-3 T1  ו-T2 בגודל n1 ו-n2 בהתאמה. נניח שידוע שכל האיברים בעץ T1 קטנים מכל האיברים בעץ T2.
הציעו אלגוריתם שמאחד את שני העצים לעץ 2-3 חוקי בזמן W.C. O(log (Max(n1,n2)).",na,,,,
A,FALSE,2003,a,a,12.c,https://docs.google.com/document/d/1uYfTozVQ7fEkuWRJr2g7R7ZqkkAKm4Jd,TAU,8,na,na,na,na,na,na,1,נתונים שני עצי 2-3 T1  ו-T2 בגודל n1 ו-n2 בהתאמה. הוכיחו שלא ניתן לפתור את זה הציעו אלגוריתם שמאחד את שני העצים לעץ 2-3 חוקי בזמן O((n1 + n2)^0.5) במודל ההשואות.,na,,,,
D,TRUE,2003,b,a,1,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,"
Assume you have an algorithm capable of performing the Heapify operation (as defined in class) on a heap in time \( O(\log\log(n)) \). What will be the running time of the BuildHeap algorithm (as defined in class), if instead of using the standard Heapify algorithm as a black box, you use the new Heapify algorithm?

A. \(\Theta(n\log(n))\) 

B. \(\Theta(n\log\log(n))\) 

C. \(\Theta\left(\frac{n\log(n)}{\log\log(n)}\right)\) 

D. \(\Theta\left(\frac{n\log\log(n)}{\log(n)}\right)\) 

E. \(\Theta(n)\) 
",E,na,5,a,tested,1,"נניח כי עומד לרשותכם אלגוריתם המסוגל לממש את פעולתHeapify  (שהוגדרה בכיתה)  על ערימה בזמן O(lglg(n)). מה יהיה זמן הריצה של אלגוריתם BuildHeap (כפי שהוגדר בכיתה), אם במקום להשתמש באלגוריתם Heapify  הרגיל כקופסא שחורה, תשתמשו באלגוריתם Heapify החדש?
א. θ(nlog(n))
ב. θ(nloglog(n)) 
ג. θ(nlog(n)/loglog(n))
ד. θ(nloglog(n)/log(n))
ה. θ(n) ",na,,,,
D,TRUE,2003,b,a,2,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,"
In class, we saw a binary search algorithm in a sorted array.
We will modify it as follows:
At each step, instead of checking only the value at index \( n/2 \), we will check the value at each of the indices \( n/k \), \( 2n/k \), \( 3n/k \), ..., \( (k-1)n/k \).  
If at one of them the value equals the value being searched for, we will stop and return its index.
Otherwise, we will apply the algorithm recursively only on the appropriate segment.
The runtime of this algorithm will be:
\begin{enumerate}
    \item \(\Theta(n)\) 
    \item \(\Theta(n\log(k))\) 
    \item \(\Theta\left(\frac{k\log(n)}{\log(k)}\right)\) 
    \item \(\Theta\left(\frac{\log(n)}{\log(k)}\right)\)
    \item \(\Theta\left(\frac{\log(n)}{k}\right)\)
\end{enumerate}
",C,na,5,a,tested,1,"בכיתה ראינו אלגוריתם חיפוש בינרי במערך ממוין.
נשנה אותו באופן הבא:
בכל שלב, במקום לבדוק רק את הערך באינדקס n/2, נבדוק את הערך בכל אחד מהאינדקסים n/k, 2n/k, 3n/k,..., (k-1)n/k.  
אם באחד מהם הערך שווה לערך שמחפשים – נעצור ונחזיר את האינדקס שלו.
אחרת – נפעיל את האלגוריתם באופן רקורסיבי רק על הקטע המתאים.
זמן הריצה של אלגוריתם זה יהיה:
א. θ(n) 
ב. θ(nlog(k)) 
ג. θ(klog(n)/log(k)) 
ד. θ(log(n)/log(k))
ה. θ(log(n)/k)",na,,,,
D,TRUE,2003,b,a,3,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,B,na,6,a,na,1,"T(n) = T(n - 1) + log(n)
T(n) = ? 
א. θ(n^2)
ב. θ(nlog(n)) 
ג. θ(n)
ד. θ(log(n)*loglog(n))
ה. θ(log(n))
ו.  אף אחד מהנ""ל.",na,,,,
D,TRUE,2003,b,a,4,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,"
Given the functions \( f(n) = 2^{(\log\log(n))^{0.5}} \) and \( g(n) = (\log\log(n))^2 \cdot n^{0.5} \), which of the following is true?
\begin{enumerate}
    \item \( f = \Theta(g) \)
    \item \( f = o(g) \)
    \item \( g = o(f) \)
    \item None of the above
\end{enumerate}
",2,na,4,a,untested,1,"
f(n) = 2^(loglog(n)^0.5), g(n) = (loglog(n))^2*n^0.5
מה מהבאים נכון ?
f = Θ(g .1) 
f = o(g)    (o .2 קטן).    ****
g = o(f)   (o .3 קטן).
4. אף אחד מהנ""ל",na,,,,
D,TRUE,2003,b,a,5,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,E,na,6,h,na,1,"נתונה ערימת מקסימום (Heap), שבה לכל צומת שדה נוסף המכיל את המספר 1/(2^d) כאשר d הוא המרחק (בקשתות) של הצומת משורש הערימה.   אם נסכום את כל השדות הנ""ל של עלי הערימה בלבד נקבל מספר W. מהם החסמים (תחתון ועליון) ההדוקים ביותר עבור W ?
א. 0 <= W <= n
ב. 0.5 <= W <= 1
ג. 0.5 - 1/(2^h) <= W <= 1 כאשר h הוא גובה הערימה (בקשתות)
ד. 0.5 - 1/(2^h) <= W <= 0.5 כאשר h הוא גובה הערימה (בקשתות)
ה. 1 - 1/(2^h) <= W <= 1 כאשר h הוא גובה הערימה (בקשתות)
ו. 0.5 <= W <= 0.5 + 1/(2^h) כאשר h הוא גובה הערימה (בקשתות)",na,,,,
D,TRUE,2003,b,a,6,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,"
We want to convert a binary search tree into a red-black search tree. Assuming the comparison model, this can be done in the best possible time:

A. \(\Theta(n)\) W.C., average \(\Theta(n)\).
B. \(\Theta(n)\) W.C., average \(\Theta(n \log(n))\).
C. \(\Theta(n \log(n))\) W.C., average \(\Theta(n)\).
D. \(\Theta(n \log(n))\) W.C., average \(\Theta(n \log(n))\).
E. None of the above.
",A,na,6,"e,p",tested,1,"רוצים להפוך עץ חיפוש בינרי לעץ חיפוש אדום שחור. בהנחת מודל ההשוואות ניתן לעשות זאת בזמן (הטוב ביותר האפשרי):
א. θ(n) W.C., ממוצע θ(n).
ב. θ(n) W.C.,  ממוצע θ(nlog(n)).
ג. θ(nlog(n)) W.C., ממוצע θ(n).
ד. θ(nlog(n)) W.C., ממוצע θ(nlog(n)).
ה. אף אחד מהנ""ל",na,,,,
D,TRUE,2003,b,a,7,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,"
Given two sorted arrays of size \( n \). No value repeats itself. We want to find their common median (i.e., an element with exactly \( n \) elements smaller than it in the combined arrays).

This can be done in W.C. time (best possible):

A. \(\Theta(1)\)

B. \(\Theta(\log(n))\)

C. \(\Theta(n)\)

D. \(\Theta(n \log(n))\)

E. \(\Theta(n^2)\)
",B,na,5,"a,m",untested,1,"נתונים שני מערכים ממוינים בגודל n. אף ערך לא חוזר על עצמו. רוצים למצוא את החציון המשותף שלהם (כלומר איבר שיש בדיוק n איברים שקטנים ממנו בששני המערכים יחד).
ניתן לעשות זאת בזמן W.C. (הטוב ביותר):
א. θ(1)
ב. θ(log(n))  
ג. θ(n) 
ד. θ(nlog(n)) 
ה. θ(n^2)",na,,,,
D,TRUE,2003,b,a,8,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,D,na,5,f,na,1," נתון עץ AVLבגודל n. מבצעים פעולת רוטציה על שורש העץ. נזכיר שעומק של צומת הוא מרחקו מהשורש. 
כמה צמתים לא שינו את עמקם?

א. 0
ב. θ(1)  
ג. θ(log(n)) 
**ד. θ(n) 
ה. אף אחד מהנ""ל לא בהכרח נכון (תלוי בעץ עצמו).",na,,,,
A,TRUE,2003,b,a,9,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,na,na,na,na,na,1,"נתון מערך A המכיל n מספרים שלמים.  בהינתן מספרx  המופיע ב A, נגדיר את הריבוי שלx  במערך A בתור מספר המופעים של x ב-A. רוצים לייצר מערך ממוין B בגודל n, שיכיל את הריבוי של כל אחד מהמספרים המופיעים ב A. 

הציעו אלגוריתם שפותר את הבעיה בתוחלת זמן הטובה ביותר.","תאור האלגוריתם:
נכניס את איברי הקבוצה לטבלת Hash בגודל (n).  ערכים חוזרים יוחזקו על ידי מונה (כלומר בפעולת ההכנסה, נעבור על כל הרשימה בתא אליו הגענו, ורק אם הערך לא נמצא נוסיף איבר חדש לרשימה, עם מונה מאותחל לאחד). בסוף הכנסת כל האיברים, נעבור על הטבלא ונחלץ את כל הריבויים. כל הערכים הנ""ל הם שלמים בתחום 1 עד n לכן ניתן למינם בעזרת CountSort. הוכחת זמן ריצה :
הכנסה לטבלה – סה""כ צפוי  (ממוצע) O(n)
חילוץ ריבויים מהטבלה O(n) 
CountSort O(n)

סה""כ צפוי O(n)",,,,
A,TRUE,2003,b,a,10.a,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,na,na,na,na,na,1,"בהינתן שני מערכים A ו B, כל אחד בגודל n, מעוניינים לייצר מערך שלישי C בגודל n,  בעל התכונה הבאה: הערך הרשום ב C[i] שווה מספר איברי A הקטנים מ B[i].
לשאלה זו שני סעיפים! תארו אלגוריתם בעל סיבוכיות ה W.C. הטובה ביותר לפתרון הבעיה.","תיאור האלגוריתם:
נמיין את A בעזרת HeapSort.
עבור כל איבר ב-B נמצא כמה איברים קטנים ממנו בעזרת חיפוש בינארי ב O(lg n). 
חשוב מאוד: אם ב-A  יש איברים המופיעים יותר מפעם אחת, חיפוש בינארי רגיל לא יעבוד. לכן בכל דגימה של ערך, אם הערך הנדגם שווה לערך שמחפשים האלגוריתם לא יעצור אלא יבצע קריאה רקורסיבית על החצי השמאלי (שמכיל את האיברים הקטנים יותר.  הוכחת זמן ריצה:
מיון: (n lg n)
n חיפושים בינארים  (n lg n)
סה""כ (n lg n)
",,,,
A,TRUE,2003,b,a,10.b,https://docs.google.com/document/d/1DsdNOK2cTVO4bctkBjFCBCsjpJEvM3qR,TAU,na,na,na,na,na,na,na,1,"בהינתן שני מערכים A ו B, כל אחד בגודל n, מעוניינים לייצר מערך שלישי C בגודל n,  בעל התכונה הבאה: הערך הרשום ב C[i] שווה מספר איברי A הקטנים מ B[i].
לשאלה זו שני סעיפים! תנו חסם תחתון טוב ככל האפשר לאלגוריתם הפותר את הבעיה במודל ההשוואות:","הוכחת נכונות :

נראה שבעזרת אלגוריתם לפתרון הבעיה הנ""ל שפועל במודל ההשוואות בזמן f(n) ניתן למיין מערך המכיל את הערכים 1 עד n בזמן O(f(n)+n) ולכן בהכרח f(n)=(n lg n).

בהינתן מערך A המכיל את n המספרים הראשונים, נעביר לאלגוריתם שני עותקים של A (בתור A ו-B).
האלגוריתם פועל ב-f(n) ומחזיר מערך C  המכיל למעשה את הסדר הסטטיסטי של כל אחד מאברי A ולכן בזמן נוסף O(n) ניתן למיין את A.
",,,,
D,FALSE,2003,"a,b",b,1,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,6,a,na,1,"1. T(n) = T(n/7) + T(n/2) + 6n
T(n) = ?
א. θ(n^2)
ב. θ(nlog(n))
ג. θ(n)
ד. θ(log(n)*loglog(n))
ה. θ(log(n))
ו.  אף אחד מהנ""ל.",na,,,,
D,FALSE,2003,"a,b",b,2,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,"
Let \( f(n) = 2^{\log\log(n)} \), \( g(n) = 4^{(\log\log(n))^{0.5}} \). Which of the following is true?

1. \( f = \Theta(g) \) 
2. \( f = o(g) \) (small \( o \)).
3. \( g = o(f) \) (small \( o \)).
4. None of the above.
",na,na,4,a,tested,1,"
f(n) = 2^(loglog(n)), g(n) = 4^(loglog(n)^0.5)
מה מהבאים נכון ?

f = Θ(g .1) 
f = o(g)    (o .2 קטן).
g = o(f)   (o .3 קטן).
4. אף אחד מהנ""ל",na,,,,
D,FALSE,2003,"a,b",b,3,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,"\noindent Given a structure $A$ that supports the operations Insert, Delete, Find. If the amortized time for each operation is $\Theta(1)$, then it is possible that the Insert operation takes in the worst case: 
\begin{enumerate}
    \item $\Theta(\log\log(n))$
    \item $\Theta(\log(n))$
    \item $\Theta(n)$
    \item (1) + (2)
    \item (2) + (3)
    \item (1) + (2) + (3)
\end{enumerate}",na,na,6,b,tested,1,"נתון מבנה A שתומך בפעולות Insert, Delete, Find. אם נתון שזמן Amortized לפעולה הוא θ(1) , אז יתכן שפעולת Insert לוקחת ב-W.C.:
א. θ(loglog(n))
ב. θ(log(n)) 
ג. θ(n)
ד. א+ב
ה. ב+ג
ו. א+ב+ג",na,,,,
D,FALSE,2003,"a,b",b,4,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,"\textit{Given an array of size \( n^3 \) that contains \( n^2 \) distinct values. The Quick-Sort algorithm will run on it in the W.C. (Worst Case) time:} 
\begin{enumerate}
    \item \(\theta(n^2\log(n))\)
    \item \(\theta(n^3)\)
    \item \(\theta(n^3\log(n))\)
    \item \(\theta(n^3\log(n)^3)\)
    \item \(\theta(n^4)\)
    \item \(\theta(n^6)\)
\end{enumerate}",na,na,6,"a,j",tested,1,"נתון מערך בגודל n^3שבו יש n^2ערכים שונים. אלגוריתם  Quick-Sort, ירוץ עליו בזמן W.C. : 
א. θ(n^2log(n))
ב. θ(n^3) 
ג. θ(n^3log(n))
ד. θ(n^3log(n)^3)
ה. θ(n^4) 
ו. θ(n^6)",na,,,,
D,FALSE,2003,"a,b",b,5,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,5,"a,h",na,1,"נתונה ערימת מקסימום המכילה n איברים. מובטח שהערימה חוקית מבחינת מבנה, אך יתכן  שיש הפרה אחת (לכל היותר) של חוקיות הערכים בין אבא לבן. רוצים להכריע האם יש הפרה כזו. האלגוריתם היעיל ביותר לבדיקה הנ""ל ירוץ בזמן WC:
א. θ(n^2)
ב. θ(nlog(n)) 
ג. θ(n)
ד. θ(log(n))
ה.  אף אחד מהנ""ל.",na,,,,
D,FALSE,2003,"a,b",b,6,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,6,"e,f,g,h",na,1," נתון מבנה נתונים X המכיל n איברים. רוצים למצוא את האיבר הקטן ביותר שגדול מהאיבר המינימלי (כלומר השני בגודלו). איזה מבין המבנים הבאים יאפשר את הנ""ל בזמן W.C. המהיר ביותר ? (הכוונה לשימוש במבנה כמו שנלמד בכיתה, ללא שום שינוי)

א. ערימת מקסימום
ב. Perfect Hash
ג. עץ חיפוש מאוזן התומך בפעולות Order-Statistic
ד. תור
ה. מערך ממוין
ו. יש יותר מתשובה אחת נכונה.",na,,,,
D,FALSE,2003,"a,b",b,7,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,"\begin{flushleft}
Given a binary search tree (not necessarily balanced) of size \( n \) and height \( h \) (in edges). Each node has an additional field containing the number \( \frac{1}{2^d} \) where \( d \) is the distance (in edges) of the node from the root of the tree. If we sum all these fields for all the nodes in the tree, we get a number \( W \). What are the tightest bounds (lower and upper) for \( W \)?
\end{flushleft}

\begin{enumerate}
    \item \( 0.5 - \frac{1}{2^h} \leq W \leq 0.5 \)
    \item \( 0 \leq W \leq n \)
    \item \( 0 \leq W \leq 1 \)
    \item \( 1 - \frac{1}{2^h} \leq W \leq n\log(n) \)
    \item \( 1 - \frac{1}{2^h} \leq W \leq 1 \)
    \item \( 1 - \frac{1}{2^h} \leq W \leq n \)
\end{enumerate}",na,na,6,e,untested,1,"נתון עץ חיפוש בינרי (לאו דווקא מאוזן) בגודל n ובגובה h (בקשתות). לכל צומת שדה נוסף המכיל את המספר 1/(2^d) כאשר d הוא המרחק (בקשתות) של הצומת משורש הערימה.   אם נסכום את כל השדות הנ""ל של כל צמתי העץ נקבל מספר W. מהם החסמים (תחתון ועליון) ההדוקים ביותר עבור W ?
א. 0.5 - 1/(2^h) <= W <= 0.5
ב. 0 <= W <= n
ג.  0 <= W <= 1
ד. 1 - 1/(2^h) <= W <= nlog(n)
ה. 1 - 1/(2^h) <= W <= 1 
ו. 1 - 1/(2^h) <= W <= n ",na,,,,
A,FALSE,2003,"a,b",b,9,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,na,na,na,1," רוצים אלגוריתם יעיל ככל האפשר (WC) לבעיה הבאה:
קלט: מערך A בגודל n ומספר k.  
פלט: k האיברים הקרובים ביותר לחציון המערך שמרחקם שההפרש בינם לחציון לפחות 10.
מותר להניח ש-n אי זוגי  ושתמיד יש פתרון אחד בלבד.

לדוגמה: עבור הקלט   A  =  24, 23, 35, 32, 47, 10, 11,  k=3
הפלט יהיה  35,10,11

הציעו אלגוריתם שפותר את הבעיה בזמן WC הטוב ביותר.",na,,,,
A,FALSE,2003,"a,b",b,10.a,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,na,na,na,1,"ערימת-מקסימום תיקרא ""חזקה"" אם בכל שכבת צמתים, כל הצמתים קטנים מכל הצמתים בשכבה שמעליה.

תארו אלגוריתם בעל סיבוכיות ה W.C. הטובה ביותר לבניית ערימת-מקסימום חזקה.",na,,,,
A,FALSE,2003,"a,b",b,10.b,https://docs.google.com/document/d/1s1iM0bGmR04O6J6zz7iGmjYLOXhp4LqZ,TAU,na,na,na,na,na,na,na,1,"ערמת-מקסימום תיקרא ""חזקה מאד"" אם בכל שכבת צמתים, כל הצמתים קטנים מכל הצמתים בשכבה שמעליה,  וכן כל עלה בערימה  גדול מהעלה משמאלו.

תנו חסם תחתון הדוק ביותר לזמן ריצת WC של אלגוריתם לבניית ערימה חזקה מאוד (בהנחת מודל ההשוואות).",na,,,,
C,TRUE,2004,a,a,1,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,4,"\subsection*{A Ternary Tree}
A ternary tree is a tree in which each node has at most three children. A complete and balanced ternary tree, containing $N$ nodes, is given. The depth of a node is the number of edges between the node and the root (the depth of the root is 0). The height of a node is the number of edges between the node and the nearest leaf (the height of a leaf is 0). Let $D$ be the sum of the depths of all the nodes (including leaves), then:
\begin{enumerate}
    \item $D = \theta(N)$
    \item $D = \theta(N\log(N))$
    \item $D = \theta(N^2)$
    \item $D = \theta(N^2\log(N))$
    \item None of the above answers is correct.
\end{enumerate}",B,"
b. 
The depth of all the nodes is \(O(\log n)\). Therefore, the sum is \(O(n \log n)\).
On the other hand, the depth of all the leaves is \(\Omega(\log n)\) and there are \(\Omega(n)\) leaves, therefore the sum is also \(\Omega(n \log n)\).
",5,"e,p",untested,1,"עץ טרינארי הוא עץ שבו לכל צומת לכל היותר שלושה ילדים. 
נתון עץ טרינארי מלא ומאוזן, המכיל N צמתים.
העומק של צומת הינו מספר הקשתות בין השורש ובין הצומת (עומק השורש הינו 0). 
הגובה של צומת  הינו מספר הקשתות בין הצומת ובין העלה הקרוב ביותר (גובה עלה הינו 0). יהי D סכום העומקים של כל הצמתים (כולל עלים) אזי
א. D = θ(N)
ב. D = θ(Nlog(N)) 
ג. D = θ(N^2)
ד. D = θ(N^2log(N))
ה. אף אחת מהתשובות הנ""ל אינה נכונה.","ב. 
עומק כל הצמתים הוא O(lg n). לכן הסכום הוא O(n lg n).
מצד שני, עומק כל העלים הוא Ω(lg n) ויש Ω(n) עלים לכן הסכום הוא גם Ω(n lg n)",,,,
C,TRUE,2004,a,a,2,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,4,"
A ternary tree is a tree in which each node has at most three children.
Given a full and balanced ternary tree containing \( N \) nodes.
The depth of a node is the number of edges between the root and the node (the depth of the root is 0).
The height of a node is the number of edges between the node and the closest leaf (the height of a leaf is 0). Let \( H \) be the sum of the heights of all nodes (including leaves), then:
a. \( H = \theta(N) \)
b. \( H = \theta(N \log(N)) \)
c. \( H = \theta(N^2) \)
d. \( H = \theta(N^2 \log(N)) \)
e. None of the above answers is correct.
",A,"
The calculation is similar to the calculation of the running time of Build-Heap. We obtain a geometric series of the form \(\Theta(n) \times \sum_{i} \left(\frac{i}{3^i}\right)\).
",5,"e,p",untested,1,"עץ טרינארי הוא עץ שבו לכל צומת לכל היותר שלושה ילדים. 
נתון עץ טרינארי מלא ומאוזן, המכיל N צמתים.
העומק של צומת הינו מספר הקשתות בין השורש ובין הצומת (עומק השורש הינו 0). 
הגובה של צומת  הינו מספר הקשתות בין הצומת ובין העלה הקרוב ביותר (גובה עלה הינו 0). יהי H סכום הגבהים של כל הצמתים (כולל עלים) אזי
א. H = θ(N)
ב. H = θ(Nlog(N)) 
ג. H = θ(N^2)
ד. H = θ(N^2log(N))
ה. אף אחת מהתשובות הנ""ל אינה נכונה.","א.
החישוב בדומה לחישוב זמן הריצה של Build-Heap. מתקבלת סדרה הנדסית מהצורה Θ(n)xΣi(i/3i)",,,,
C,TRUE,2004,a,a,3,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,"
$T(n) = T(n/4) + T(3n/4) + 1$  
A. $T(n) = \theta(n)$  
B. $T(n) = \theta(n^{\log_3{4}})$  
C. $T(n) = \theta(n\log{n})$  
D. $T(n) = \theta(n^{0.75})$  
E. $T(n) = \theta(\log^2{n})$  
F. $T(n) = \theta(\log^{0.75}{n})$
",A,"
Part A.
",6,a,tested,1,"
T(n) = T(n/4) + T(3n/4) + 1
א. T(n) = θ(n)
ב. T(n) = θ(n^(log(4)/log(3))) 
ג. T(n) = θ(nlog(n))
ד. T(n) = θ(n^0.75)
ה. T(n) = θ(log(n)^2) 
ו. T(n) = θ(log(n)^0.75)",א.,,,,
C,TRUE,2004,a,a,4,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,na,C,na,6,"g,b",na,1,"נתונה טבלת Hash פתוחה בגודל B, שבה התנגשויות בכל תא נפתרות על ידי רשימה מקושרת. הטבלה תומכת בפעולות Insert, Delete, Find.
עבור סדרת פעולות באורך N, המורכבת ממספר שווה של כל אחת מהפעולות הנ""ל (N/3 מכל סוג), ומתחילה עם מבנה ריק, זמן Amortized לפעולה בודדת במבנה הוא:
(תזכורת: זמן Amortized  לפעולה הוא זמן W.C. של סידרה של N פעולות, חלקי N).
א. θ(1)
ב. θ(B) 
ג. θ(N)
ד. θ(B^2)
ה. θ(N^2)
ו. אף אחת מהנ""ל.","ג. כל פעולה במבנה לוקחת w.c. O(N) ולכן זהו חסם על זמן Amortized.. סידרה שמתחילה N/3 פעולות Insert שבה כל האיברים נופלים נופלים לאותו תא, וכל פעולות החיפוש כושלות אחרי סריקת הרשימה הארוכה, תיקח Θ(N2).",,,,
C,TRUE,2004,a,a,5,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,"
If \(\log(f(n)) = \theta(\log(g(n)))\) then necessarily:
a. \(f(n) = \theta(g(n + 1))\)
b. \(f(n) = \theta(g(n/2))\) 
c. \(f(n) = \theta(g(n^{0.5}))\)
d. a + b
e. a + b + c
f. None of the above
",F,"
\subsection{Counterexample}
\( f(n) = n! \), \( g(n) = n^n \)
",6,a,tested,1,"אם log(f(n)) = θ(log(g(n))) אז בהכרח:
א. f(n) = θ(g(n + 1))
ב. f(n) = θ(g(n/2)) 
ג. f(n) = θ(g(n^0.5))
ד. א + ב
ה. א + ב + ג
ו. אף אחת מהנ""ל","ו. 
דוגמה נגדית:
f(n) = n!  ,   g(n) = nn",,,,
C,TRUE,2004,a,a,6,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,"
Given a binary search tree that supports order statistic operations. The height of the tree in edges is \( h \) and it contains \( n \) elements. An in-order traversal is performed on the tree, but instead of printing the keys, the value of the Size field is printed.
The maximum value will necessarily be printed in the location:
\begin{enumerate}
    \item First
    \item Last
    \item One of the first \( h \) places.
    \item One of the last \( h \) places.
    \item \( n/2 \)
    \item None of the above.
\end{enumerate}
",F,"
6. The maximum Size value belongs to the root. The root can be of any statistical order, therefore it can appear anywhere in the Inorder printout.
",6,e,tested,1,"נתון עץ חיפוש בינארי התומך בפעולות סדר סטטיסטי (Order Statistic). גובה העץ בקשתות הוא h ויש בו n איברים. מבצעים על העץ סריקת LDR (In-order) , אלא שבמקום להדפיס את המפתחות, מדפיסים את ערך השדה Size.
הערך המקסימלי יודפס בהכרח במקום:
א. הראשון
ב. האחרון
ג. אחד מ-h המקומות הראשונים.
ד. אחד מ-h המקומות האחרונים.
ה. n/2
ו. אף אחד מהנ""ל.","ו.
הערך Size המקסימלי שייך לשורש. השורש יכול להיות כל סדר סטטיסטי, ולכן יכול להופיע בכל מקום בהדפסת Inorder",,,,
C,TRUE,2004,a,a,7,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,na,A,na,6,m,na,1,"נתון מערך ממוין שבו כל איבר מופיע n^0.5 פעמים. ניתן לבצע חיפוש איבר במערך זה בזמן W.C.  
א. θ(log(n))
ב. θ(log(n)^0.5) 
ג. θ(n^0.5)
ד. θ(n^0.5/log(n))
ה.  θ(loglog(n)) 
ו. θ(log(n)^2)",א. אם נבצע חיפוש בינארי רגיל (ונעצור אותו כשהדילוגים קטנים מ- EMBED Equation.DSMT4   זמן הריצה יהיה (W.C.)  EMBED Equation.DSMT4  ,,,,
C,TRUE,2004,a,a,8,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,"\noindent
Modify the QuickSort algorithm as follows: the pivot element will be selected by choosing the $n/4$ order statistic, using the Select function. The running time of the new algorithm will be:
\begin{itemize}
    \item[(a)] W.C.- $\Theta(n\log(n))$, Expected - $\Theta(n)$
    \item[(b)] W.C.- $\Theta(n^2)$, Expected - $\Theta(n^2)$ 
    \item[(c)] W.C.- $\Theta(n^2)$, Expected - $\Theta(n\log(n))$
    \item[(d)] W.C.- $\Theta(n\log(n))$, Expected - $\Theta(n\log(n))$
    \item[(e)] W.C.- $\Theta(n^{0.25}\log(n))$, Expected - $\Theta(n^{0.25}\log(n))$ 
    \item[(f)] W.C.- $\Theta(n^2\log(n))$, Expected - $\Theta(n^2\log(n))$
\end{itemize}",D,"The correct answer is D.\\

The runtime will be the same for the worst case and the average case – it will not actually be affected by the input or random choices.
The recurrence formula: \( T(n) = T\left(\frac{3n}{4}\right) + T\left(\frac{n}{4}\right) + \Theta(n) \) (rounded to integers).",6,j,tested,1,"נשנה את אלגוריתם QuickSort באופן הבא: בחירת איבר הציר (Pivot) תבוצע על ידי בחירת הסדר הסטטיסטי ה-n/4 , בעזרת פונקצית Select.    זמן ריצת האלגוריתם החדש יהיה:
א. W.C.- θ(nlog(n)), Expectet -θ(n)
ב. W.C.- θ(n^2), Expectet -θ(n^2) 
ג. W.C.- θ(n^2), Expectet -θ(nlog(n))
ד. W.C.- θ(nlog(n)), Expectet -θ(nlog(n))
ה. W.C.- θ(n^0.25log(n)), Expectet -θ(n^0.25log(n)) 
ו. W.C.- θ(n^2log(n)), Expectet -θ(n^2log(n))","ד. 
זמן הריצה יהיה זהה למקרה הגרוע ולמקרה הממוצע – למעשה לא יושפע מהקלט או מהגרלות.
נוסחת הנסיגה: T(n) = T(3n/4) + T(n/4) + Θ(n) (עד כדי עיגול לשלמים).",,,,
C,TRUE,2004,a,a,9,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,7,na,E,na,6,"a,c",na,1,"נוסחת הנסיגה של זמן הריצה של התכנית Select (מציאת סדר סטטיסטי כלשהו במערך לא ממוין) היא:
T(n) <= T(n/5) + T(7n/10 + c) + O(n) (c קבוע כלשהו).
נשנה את פעולת Select כך שבשלב הראשון החלוקה תהיה לשביעיות במקום לחמישיות. נוסחת הנסיגה המעודכנת תהיה:
א. T(n) <= T(n/7) + T(7n/10 + c) + O(n) (c' קבוע כלשהו).
ב. T(n) <= T(n/7) + T(n/2 + c) + O(n) (c' קבוע כלשהו).
ג. T(n) <= T(n/7) + T(n/10 + c) + O(n) (c' קבוע כלשהו).
ד. T(n) <= T(n/7) + T(2n/7 + c) + O(n) (c' קבוע כלשהו).
ה. T(n) <= T(n/7) + T(5n/7 + c) + O(n) (c' קבוע כלשהו).
ו. T(n) <= T(n/5) + T(7n/10 + c) + O(n) (c' קבוע כלשהו).","ה. מציאת חציון החציונים היא הפעלה רקורסיבית על מערך בגודל בערך n/7. יש בערך 4n/14 איברים בהכרח קטנים ממנו וכנ""ל גדולים (חצי מארבע שורותבגודל n/7 כל אחת) לכן הרקורסיה השניה פועלת על מערך בגודל בערך 5n/7",,,,
C,TRUE,2004,a,a,10,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,3,"
The same data as in the previous question. What is the W.C. runtime of the new program? 

a. \(\theta(\log(n))\)

b. \(\theta(n)\)

c. \(\theta(n\log(n))\)

d. \(\theta(n^2)\)

e. None of the above
",B,"
b. Proof by induction.
",5,"a,c",untested,1,"אותם נתונים כמו בשאלה הקודמת. מה זמן הריצה W.C. של התכנית החדשה?
א. θ(log(n))
ב. θ(n) 
ג. θ(nlog(n))
ד. θ(n^2)
ה. אף אחד מהנ""ל",ב. הוכחה באינדוקציה.,,,,
A,TRUE,2004,a,a,11,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,15,na,na,na,na,na,na,1,"רוצים להוסיף לעץ 2-3 רגיל (התומך בפעולות insert, delete, find) את הפעולה הבאה:
Change-Key(p,new-val). הפעולה מקבלת מצביע p לאיבר (עלה)  בעץ, וצריכה לעדכן את הערך השמור באיבר עליו מצביע p לערך new-val. שימו לב כי הפעולה מקבלת מצביע  לאיבר עליו יש לבצע את הפעולה. בסיום הפעולה, העץ צריך להיות עץ 2-3 חוקי.
הוכיחו חסמים עליונים ותחתונים הדוקים (כלומר זהים) לביצוע הפעולה הנ""ל במודל ההשוואות.","חסם עליון: O(log n)
הוכחה: ניתן למחוק את p.key ב O(log n) ולהכניס את new-val ב O(log n). סה""כ O(log n). חסם תחתון: Ω(log n)
הוכחה: נניח כי ניתן לבצע את הפעולה ב o(log n). בהינתן n מספרים לא ממוינים נמיינם באופן הבא: 
א.  נבנה עץ 2-3 חוקי שכל עליו מכילים את הערך 0. כפי שראינו ניתן לעשות זאת ב O(n)      . 
ב.  נקצה מערך נוסף B אשר יחזיק n מצביעים לעליו של העץ. גם את מערך זה ניתן      
      לבנות ב O(n) בזמן בניית העץ. 
ג.  נעבור על מערך הקלט ועבור האיבר ונבצע ChangeKey(B[i],A[i]). כך נקבל 
     עץ 2-3 חוקי המכיל את איברי המערך וזאת בזמן o(nlong).
ד. נוציא מהעץ רשימה מקושרת המכילה את עליו ב O(n).
סה""כ קיבלנו מיון ב o(nlogn) בסתירה לחסם התחתון של מודל ההשוואות.

הערה: סטודנטים רבים טעו בכך שלא השתמשו במערך הפוינטרים B (או בפתרון שקול אחר). במצב זה לא ניתן לתת לפונקציה ChangeKey מצביע לאיברים אותם יש לשנות. טעות נפוצה נוספת היתה ביצוע סריקה של רשימת העלים וביצוע ChangeKey לפי סדר. גם זה פתרון בעייתי, כי יש יתכן מצב בו נבצע ChangeKey יותר מפעם אחת על אותו עלה וכך נאבד את אחד מהערכים המקוריים.",,,,
A,TRUE,2004,a,a,12,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,5,na,na,na,na,na,na,1,"נתונים n  מפתחות שונים זה מזה וממוינים.  תארו מבנה נתונים יעיל  המתחזק מפתחות אלו (הניחו שהמבנה כבר בנוי, כלומר לא חשובה עלות בנייתו) והתומך בפעולת find_delete(key)המקבלת מפתח והמחזירה  false  אם המפתח אינו במבנה. אם הוא במבנה, הפעולה מחזירה true  ומוציאה אותו מהמבנה.    עלות נדרשת: O(log n) לפעולת find_delete(key).","תאור המבנה:
עץ חיפוש מאוזן.


סבוכיות הפעולה – הסבירו: 
מציאת איבר בעץ, וכן מחיקתו עולות O(logn).",,,,
A,TRUE,2004,a,a,13,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,10,na,na,na,na,na,na,1,"נגדיר פרמוטציה מסדר (n,m) באופן הבא (כפי שהוגדר בתרגול):
מסדרים את המספרים 1,2,3,…,n במעגל, ומצביעים על המספר 1.
מבצעים m צעדים לאורך המספרים שנותרו על המעגל.
מדפיסים את המספר אליו הגענו, ומוחקים אותו מהמעגל. אם נותרו מספרים חוזרים לב', ולא עוצרים. מספר שנמחק, אינו נספר במניין הצעדים בשלב ב'. 
      לדוגמא: הפרמוטציה מסדר (7,3) היא 4,7,3,1,6,2,5 (ודאו כי אתם מבינים מדוע!)
תארו אלגוריתם יעיל המקבל מספר n, ומחזיר את הפרמוטציה מסדר (n,n/2).
(שימו לב, שהרעיון לא בהכרח דומה לזה שנלמד בכיתה עבור הפרמוטציה (n,17)).","זמן ריצת האלגוריתם:  O(nlogn)
תיאור האלגוריתם והוכחת נכונות:
נחזיק את המספרים 1 עד n בעץ  חיפוש בינארי עם סדר סטטיסטי. ז""א כל קודקוד בעץ ישמור בנוסף את מספר הקודקודים שמתחתיו (+1) בשדה size, כמו שראינו בכיתה.
נתחיל כשפוינטר מצביע על האיבר 1.
כשאנחנו באיבר שאינדקסו I, נקפוץ לאיבר שאינדקס שלו הוא (I+n/2) mod k בעזרת OS_Select כאשר k הוא מספר האיברים שנותרו בעץ (כלומר size של השורש).
נדפיס את האיבר שהגענו אליו, ונמחוק אותו.
נבצע את 1 ו- 2 עד שלא יותרו איברים בעץ.
לאלג' יש n איטרציות. כל איטרציה עולה O(logn), וסה""כ O(nlogn).
טעויות נפוצות:
אלג' שזמנם O(n^2) – ניתנו 2 נק'
אלג' שלא בצעו את הנדרש לא הדפיסו את הפרמוטציה – לא קיבלו הנק'
טעויות בניתוח זמן ריצה – הורדו נק' לפי הטעות.
ציון Θ(.) ללא הוכחת זמן חסם תחתון – הורדו 2 נקודות.",,,,
A,TRUE,2004,a,a,14,https://docs.google.com/document/d/1XDB0oWMfvAxlym7XTAow0iF4PbwLN3qE,TAU,10,na,na,na,na,na,na,1,"תאר אלגוריתם הפותר את הבעיה הבאה: בהינתן קבוצה S של n מספרים, האלגוריתם בונה בזמן  ,W.C. O(n) מבנה נתונים התומך בפעולה find בלבד, באופן ש: זמן ה W.C של find הוא O(n), אולם על לפחות n/log n מהאיברים, זמן הריצה של find הוא O(log n). שימו לב כי המבנה אינו דינאמי, כלומר אינו צריך לתמוך ב insert ו delete.","תיאור האלגוריתם והוכחת נכונות:
לוקחים n/log n  איברים  ומכניסים לעץ חפוש מאוזן (למשל 2-3)  או למערך ממוין. עלות כוללת  היא O(n). שאר האיברים מוכנסים לרשימה.

בעת בצוע find  מחפשים קודם בעץ ואחר כך ברשימה. עלות חפוש על כל אבר בעץ היא O(log n). שאר האיברים – O(n).",,,,
C,TRUE,2004,b,"a,b",1,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,8,"
Solve the following recurrence formula:
\[ T(n) = T(c \cdot n) + T((1-c) \cdot n) + n \]
where \( c \) is a constant, \( 0 < c < 1 \).

\begin{enumerate}
    \item \( T(n) = \theta(n) \)
    \item \( T(n) = \theta(n \log n) \)
    \item \( T(n) = \theta(n^{1.5}) \)
    \item \( T(n) = \theta(n^2) \)
\end{enumerate}
",B,\noindent Proof by induction or by recursion tree.,4,a,tested,1,"פתרו את נוסחת הנסיגה הבאה:
T(n) = T(c*n) + T((1-c)*n) + n כאשר נתון ש-c קבוע, 0 < c < 1 
א. T(n) = θ(n)
*ב. T(n) = θ(nlog(n)) 
ג. T(n) = θ(n^1.5)
ד. T(n) = θ(n^2)",הוכחה באינדוקציה או על ידי עץ רקורסיה.,,,,
C,TRUE,2004,b,"a,b",2,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,8,"What is the asymptotic relationship between the following functions:
If there are multiple correct answers, choose the tightest one.
\( f(n) = \frac{n}{\log(n)}, \quad g(n) = \frac{n^2}{(\log(n))^{2004}} \)
\begin{enumerate}
    \item \( f(n) = O(g(n)) \)
    \item \( f(n) = \Omega(g(n)) \)
    \item \( f(n) = \Theta(g(n)) \)
    \item \( f(n) = o(g(n)) \)
    \item \( f(n) = \omega(g(n)) \)
\end{enumerate}",D,"
For all \( \epsilon > 0 \), it holds that \(\log n = o(n)\).
",5,a,tested,1,"מהו היחס האסימפטוטי בין הפונקציות הבאות:
אם יש כמה תשובות נכונות, בחרו את ההדוקה ביותר.
f(n) = n/log(n), g(n) = n^2/(log(n))^2004
א. f(n) = O(g(n))
ב. f(n) = Ω(g(n)) 
ג. f(n) = θ(g(n))
*ד. f(n) = o(g(n)) 
ה. f(n) = w(g(n))",לכל >0 מתקיים log n = o(n).,,,,
C,TRUE,2004,b,"a,b",3,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,9,"We modify the MergeSort algorithm so that if the array is sorted, the algorithm returns the array and does not make two additional recursive calls. Suppose we run the new algorithm on an array where each element appears exactly \( \frac{n}{\log n} \) times (therefore it contains \(\log n\) different elements). The runtime of the algorithm in the worst case (WC) is:
a. \(\Theta(n)\)  
b. \(\Theta(n \log \log n)\)  
c. \(\Theta(n \log n)\)  
d. \(\Theta(n^2)\)",C,"\noindent For the following input, the running time will be like in the original MergeSort algorithm: An array composed of $n/\log n$ parts, each part with $\log n$ values in descending order.",4,"a,k",untested,1,"משנים את אלגוריתם MergeSort כך שאם המערך ממוין האלגוריתם מחזיר את המערך ולא מבצע שתי קריאות רקורסיביות נוספות. נניח מריצים את האלגוריתם החדש על מערך בו כל איבר מופיע בדיוק n/logn פעמים (לכן הוא מכיל logn איברים שונים). זמן הריצה של האלגוריתם ב WC הינו:
א. Θ(n)
ב. Θ(n log log n)
*ג. Θ(n log n)
ד. Θ(n2)","עבור הקלט הבא, זמן הריצה יהיה כמו באלגוריתם MergeSort  המקורי:
מערך המורכב מ- n/lognחלקים, בכל חלק logn ערכים בסדר יורד.",,,,
C,TRUE,2004,b,"a,b",4,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,8,na,C,na,5,"a,k",na,1,"נגדיר מודל חישובי חדש בו נרצה למיין מערכים של מספרים בשם Only-Adjacent-Swaps. במודל אסור להחליף בין שני איברים כלשהם במערך,אלא רק בין זוג איברים סמוכים. אלגוריתם המיון המהיר ביותר במודל החדש רץ בזמן:
א. Θ(n log n) 
ב. Θ(n log2 n)
*ג. Θ(n2)
ד. Θ(n2 log n)
ה. Θ(n3)",מערך הממוין בסדר הפוך ידרוש Θ(n2) פעולות החלפה,,,,
C,TRUE,2004,b,"a,b",5,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,9,"Given an Order-Statistics Tree as defined in class, with the additional field size (i.e., the size of a node x is the number of nodes, including x, in the subtree for which x is the root). In how much time can we print the k nodes in the tree with the largest size field? It is allowed to assume that $k < n^{0.5}$.
A. \(\Theta(n)\).
B. \(\Theta(n \log n)\).
C. \(\Theta(k \log n)\).
D. \(\Theta(k \log k)\).
E. \(\Theta(k)\).",D,"
Similar to printing the $k$ largest elements from a max heap, we will use an auxiliary heap, which will contain the candidates for printing. At each step, we will print the maximum of the auxiliary heap, remove it from the auxiliary heap, and insert its two children from the tree into the auxiliary heap.
",5,p,tested,1,"נתון עץ Order-Statistics כפי שהוגדר בכיתה, עם השדה הנוסף size (כלומר size של צומת x הוא מספר הצמתים, כולל x, בתת העץ שזה ש-x הוא השורש שלו). בכמה זמן ניתן להדפיס את k הצמתים בעץ להם שדה size גדול ביותר. מותר להניח ש k < n^0.5.
א. Θ(n).
ב. Θ(n log n).
ג. Θ(k log n).
*ד. Θ(k log k).
ה. Θ(k).","בדומה להדפסת k האיברים הגדולים ביותר בערימת מקסימום. נשתמש בערימת עזר, שתכיל את המועמדים להדפסה, ובכל שלב נדפיס את המקסימלי של ערימת עזר, נמחק אותו מערימת העזר, ואת שני בניו מהעץ נכניס במקומו לערימת העזר.",,,,
C,TRUE,2004,b,"a,b",6,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,8,"\begin{quote}
We want a data structure that supports the operations Insert, Delete, and Find.

Two data structures are proposed:
The first supports all operations in W.C. time \( O(n) \) and in Amortized time per operation \( O(1) \).
The second supports all operations in W.C. time \( O(\log n) \) and in Amortized time per operation \( O(\log N) \).

We remind that \( n \) describes the number of elements in the structure, and \( N \) describes the number of operations performed on the structure.

The structure is needed for an algorithm that performs \( N \) operations on the structure. The structure is initialized to an empty state. At the beginning of the algorithm's run, \( N/10 \) insert operations are performed on it.

Which of the two structures is preferable in order to achieve the lowest W.C. time for the algorithm?
\begin{itemize}
    \item [a.] The first.
    \item [b.] The second.
    \item [c.] The answer for \( n = N/2 \) is different from the answer for \( n = N/4 \).
    \item [d.] None of the above answers.
\end{itemize}
\end{quote}",A,The first requires total time $O(N)$. The second requires total time $O(N \log N)$.,4,b,tested,1,"רוצים מבנה נתונים שתומך בפעולות Insert, Delete ו-Find.
מוצעים שני מבנים:
הראשון תומך בכל הפעולות בזמן W.C. O(n) ובזמן Amortized לפעולה O(1).
השני תומך בכל הפעולות בזמן W.C. O(log n) ובזמן Amortized לפעולה O(log N).
נזכיר ש-n מתאר את מספר האיברים במבנה, ו-N מתאר את מספר הפעולות שבוצעו על המבנה.

המבנה דרוש לאלגוריתם שמבצע N פעולות על המבנה. המבנה מאותחל למצב ריק. בתחילת ריצת האלגוריתם מבוצעות עליו N/10פעולות insert.

איזה משני המבנים עדיף, על מנת  להשיג זמן W.C. הנמוך ביותר לאלגוריתם?
*א. הראשון.
ב. השני.
ג. התשובה עבור n = N/2שונה מהתשובה עבור n = N/4.
ד. אף אחת מהתשובות הנ""ל.",הראשון דורש זמן כולל O(N). השני דורש זמן כולל O(N log N) .,,,,
C,TRUE,2004,b,"a,b",7,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,9,"
We are interested in the following problem:
Input: An array of size $n$.
Question: Are there 2 values in the array such that the number of their occurrences together is exactly 2004?

We want an algorithm that will solve the problem in the shortest expected time.
It can be done in expected time:
A. $\Theta(\log(n))$
B. $\Theta(n)$ 
C. $\Theta(n\log(n))$
D. $\Theta(n^2)$
E. None of the above
",B,"\noindent
Insert all elements into a Hash table of size $n$ (collision resolution using linked lists) in expected time $O(n)$. Duplicate values will be stored in the same list element by a counter. \\
The counters are integers between $1$ and $n$, so they can be sorted in an array using counting sort (CountSort) in time $O(n)$. Now, with the help of two indices, one can traverse the array from the beginning and the end, and check if there are two elements in the array whose sum is $2004$. \\",5,a,tested,1,"נתעניין בבעיה הבאה:
קלט: מערך בגודל n.
שאלה: האם יש במערך 2 ערכים שמספר המופעים של שניהם יחד הוא בדיוק 2004.

רוצים אלגוריתם שיפתור את הבעיה בתוחלת זמן הקצרה ביותר.
ניתן לעשות זאת בתוחלת זמן:
א. θ(log(n))
*ב. θ(n) 
ג. θ(nlog(n))
ד. θ(n^2)
ה. אף אחד מהנ""ל","נכניס את כל האיברים לטבלת Hash בגודל n (פתרון התנגשויות על ידי רשימות מקושרות) בתוחלת זמן O(n) . ערכים כפולים נשמור באותו איבר ברשימה על ידי מונה.
המונים הם שלמים בין 1 ל-n לכן אפשר למיין אותם במערך על ידי מיון מניה (CountSort) בזמן O(n). עכשיו בעזרת שני אינדקסים אפשר לרוץ על המערך מההתחלה ומהסוף, ולבדוק האם יש שני איברים במערך שסכומם 2004.",,,,
C,TRUE,2004,b,"a,b",8,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,8,"The recurrence formula for the running time of the Select algorithm (finding any order statistic in an unsorted array) is: \( T(n) \leq T(n/5) + T(7n/10 + c) + O(n) \) (where \( c \) is some constant).

We change the Select operation so that in the first step the division is into triplets instead of quintets. The updated recurrence formula will be:
\begin{enumerate}
    \item \( T(n) \leq T(n/3) + T(n/3 + c') + O(n) \) (where \( c' \) is some constant).
    \item \( T(n) \leq T(n/3) + T(2n/3 + c') + O(n) \) (where \( c' \) is some constant).
    \item \( T(n) \leq T(2n/3) + T(2n/3 + c') + O(n) \) (where \( c' \) is some constant).
    \item \( T(n) \leq T(n/3) + T(5n/6 + c') + O(n) \) (where \( c' \) is some constant).
    \item \( T(n) \leq T(n/3) + T(7n/6 + c') + O(n) \) (where \( c' \) is some constant).
    \item \( T(n) \leq T(n/3) + T(7n/10 + c') + O(n) \) (where \( c' \) is some constant).
\end{enumerate}",B,"
Finding the median of medians of the triplets: \( EMBED \ \text{Equation.DSMT4} \). It is guaranteed that at least (almost) \( n/3 \) of the elements are eliminated for the next step.
",6,m,untested,1,"נוסחת הנסיגה של זמן הריצה של התכנית Select (מציאת סדר סטטיסטי כלשהו במערך לא ממוין) היא: T(n) <= T(n/5) + T(7n/10 + c) + O(n)
 (c קבוע כלשהו).
נשנה את פעולת Select כך שבשלב הראשון החלוקה תהיה לשלישיות במקום לחמישיות. נוסחת הנסיגה המעודכנת תהיה:
א. T(n) <= T(n/3) + T(n/3 + c) + O(n) (c' קבוע כלשהו).
*ב. T(n) <= T(n/3) + T(2n/3 + c) + O(n) (c' קבוע כלשהו).
ג. T(n) <= T(2n/3) + T(2n/3 + c) + O(n) (c' קבוע כלשהו).
ד. T(n) <= T(n/3) + T(5n/6 + c) + O(n) (c' קבוע כלשהו).
ה. T(n) <= T(n/3) + T(7n/6 + c) + O(n) (c' קבוע כלשהו).
ו. T(n) <= T(n/3) + T(7n/10 + c) + O(n) (c' קבוע כלשהו).",מציאת חציון החציונים של השלשות:  EMBED Equation.DSMT4  . מובטח שלפחות (כמעט) n/3  מהאיברים מסולקים לקראת השלב הבא.,,,,
A,TRUE,2004,b,"a,b",9.a,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,7,na,na,na,na,na,na,1,"רוצים אלגוריתם יעיל ככל הניתן לבעיה הבאה:
קלט: n קטעים על הישר (כלומר n זוגות של נקודות התחלה וסיום).
שאלה: האם יש שלושה  קטעים בקלט שיש להם לפחות נקודת חיתוך אחת משותפת?","תאור האלגוריתם וניתוח זמן ריצה:
בונים מערך שמכיל את כל נקודות הקצה של כל הקטעים. מסמנים לכל נקודה אם היא הייתה נקודת התחלה או נקודת סיום. ראשית, ממיינים את המערך כך שהנקודות יהיו מסודרות משמאל לימין. אם יש ""תיקו"", כלומר נקודות שוות, אז שמים במערך את נקודות ההתחלה לפני נקודות הסיום. שנית, סורקים את המערך, ובכל שלב שומרים את מס' נקודות ההתחלה שעברנו פחות מס' נקודות הסיום שעברנו, פשוט ע""י הפחתה של 1 ממונה כשעוברים נק' סיום, והוספה של 1 בנק' התחלה. קל לראות שהמונה שווה בדיוק למס' הקטעים שהנק' הנוכחית נמצאת בהם, קל גם לראות שאם יש 3 קטעים שיש להם נקודה משותפת, אזי יש נקודה כזאת שהיא בפרט נק' קצה של קטע. לכן צריך להחזיר 'כן' אם ורק אם המונה מגיע באיזשהו שלב לערך שהוא לפחות 3. המיון לוקח זמן O(nlogn) והמעבר לוקח זמן לינארי, אז סה""כ זמן O(nlogn).

טעויות נפוצות: 1. היו פתרונות שמיינו את הקטעים לפי נק' התחלה, ואז בדקו אם ישנם שלושה קטעים סמוכים במערך שנחתכו באותה נקודה. זהו פתרון שגוי מכיוון שיכול להיות שיש שלשת קטעים שנחתכים באותה נק' בעוד שאין שלשה כזו של קטעים עם נק' התחלה שמוכות. למשל כמו בדוגמה הבאה:





2. היו גם פתרונות שבדקו רק אם יש שלשת קטעיםעוקבים שבה הראשון נחתך עם השני והשני נחתך עם השלישי, אך לא בדקו ששלושתם נחתכים בנקודה אחת. ",,,,
A,TRUE,2004,b,"a,b",9.b,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,10,na,na,na,na,na,na,1,"רוצים אלגוריתם יעיל ככל הניתן לבעיה הבאה:
קלט: n קטעים על הישר (כלומר n זוגות של נקודות התחלה וסיום).
שאלה: האם יש n/2 קטעים שיש להם לפחות נקודה אחת משותפת?","תאור האלגוריתם וניתוח זמן ריצה:
אותו פתרון מסעיף א' עובד גם כאן, רק שצריך לבדוק עבור הערך  EMBED Equation.DSMT4   במקום הערך 3. ",,,,
A,TRUE,2004,b,"a,b",9.c,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,9,na,na,na,na,na,na,1,"האם ניתן למיין n מספרים a1,…,an מהתחום [0,2] בזמן W.C. O(n) אם 
לכל i≠j מתקיים |ai-aj|>1/n2 ?","תשובה: כן

הוכחה:
לכל מספר ai ""נצמיד"" מספר ni כך שיתקיים ni/2n2<= ai<= (ni+1)/2n2. מהמנתון נקבל כי כל המספרים ni, הינם שונים, וברור כי מיון המספרים ni נותן מיון של המספרים ai. את המספרים ni ניתן למיין ב O(n) כפי שראינו בתרגול.",,,,
A,TRUE,2004,b,"a,b",9.d,https://docs.google.com/document/d/1LSxoxH2sEItqkTRlrCstcMk02LN676Jz,TAU,7,na,na,na,na,na,na,1,"תנו חסם תחתון במודל ההשוואות לבעיה האם ניתן למיין n מספרים a1,…,an מהתחום [0,2] בזמן W.C. O(n) אם 
לכל i≠j מתקיים |ai-aj|>1/n2","החסם:     nlogn

הוכחה:

במיון בהשוואות לא משנה מה הם ערכי האיברים, כי בהוכחת החסם התחתון משתמשים רק בעובדה שמותר רק להשוות זוגות איברים ועלות השוואה של שני מספרים היא פעולה אחת.   בשאלה הנידונה אפשר לראות שמספר האברים השונים זה מזה הינו N ולכן מספר הסדרים האפשריים, כמו בהוכחה המקורית הינו N!.  לכן ההוכחה המקורית תופסת גם כאן.",,,,
C,TRUE,2005,a,a,1,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,7,na,A,na,5,"a,k",na,1,"נתון מערך A ובו n  נתונים. בשאלה זו המשמעות של החלפה היא הפעולה Swap(i,j), כלומר החלפת איבר במקום כלשהו i במערך עם איבר המופיע במקום אחר j. נניח רוצים לתכנן אלגוריתם במודל ההשוואות שיבצע מספר קטן ככל האפשר של החלפות במערך (מספר ההשוואות אינו מעניין במקרה זה). מספר ההחלפות אותן מבצע האלגוריתם הטוב ביותר במקרה הגרוע ביותר הוא ?
א. θ(n)
ב. θ(nlog(n)) 
ג. θ(n^2)
ד. θ(n^0.5)
ה. θ(log(n)).",א. Selection sort,,,,
C,TRUE,2005,a,a,2,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,8,na,B,na,5,a,na,1,"תהא T(n) פונקציה המקיימת: T(n) = T(log(n)) + 1. נגדיר 
A(n) = log(T(n)) ו B(n) = T(log(n)). מה מהבאים נכון?
א. A = θ(B).
ב. A = o(B).
ג. A = w(B).
ד. התשובה תלויה ב-n.
ה. אף אחד מהנ""ל.",ב. כי B(n)=T(n)-1 A(n)=log(T(n)),,,,
C,TRUE,2005,a,a,3,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,9,na,B,na,5,"a,i",na,1,"השאלה הבאה מתייחסת לאלגוריתם המיון הבא המקבל מערך בגודל n (עם איברים a1,...,a2):
הגרל שני אינדקסים i,j i!=j בהסתברות אחידה מהמספרים 1,...,n. נניח בלי הגבלת הכלליות כי ai<aj.
חלק את המערך לשלושה חלקים כך שבחלקו השמאלי יהיו האיברים הקטנים מ ai, בחלקו הימני האיברים הגדולים-שווים מaj  ובחלקו האמצעי האיברים שקטנים מ aj וגדולים שווים מ ai.
הפעל את האלגוריתם רקורסיבית על כל אחד משלושת החלקים.
שימו לב: את השלב השני ניתן לבצע בO(n)  בדומה לפעולת ה Partition של QuickSort.
מהי תוחלת זמן הריצה של האלגוריתם?
א. θ(n)
ב. θ(nlog(n)) 
ג. θ(n^2)
ד. θ(n^2log(n))
ה. θ(n^(log(3)/log(2))).",ב. זהו quicksort,,,,
C,TRUE,2005,a,a,4,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,9,"
What is the height of the decision tree of the HeapSort sorting algorithm on an array of size \( n \)?
A. \( \theta(n) \)
B. \( \theta(n \log n) \)
C. \( \theta(n^2) \)
D. \( \theta(n!) \)
E. \( \theta((n!) \log n) \)
F. The HeapSort sorting algorithm does not fit the comparison model, thus the question is meaningless.
",B,"
b. Because this is the worst case complexity of the number of comparisons in this algorithm.
",6,"a,k",untested,1,"מהו הגובה של עץ ההחלטות של אלגוריתם המיון HeapSort על מערך בגודל n?
א. θ(n)
ב. θ(nlog(n)) 
ג. θ(n^2)
ד. θ(n!)
ה. θ((n!)*log(n))
ו. אלגוריתם המיון HeapSort לא מתאים למודל ההשוואות ולכן השאלה חסרת משמעות.",ב. כי זוהי סבוכיות הworst case  של מספר ההשוואות באלגוריתם זה.,,,,
C,TRUE,2005,a,a,5,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,8,"
In a max-heap, the median is necessarily located:

A. at the root.

B. at a depth of at most $\frac{\log(n)}{2} - 1$.

C. at a depth of at most $\frac{\log(n)}{2} + 1$.

D. in the two lowest layers.

E. none of the above.
",E,"\begin{itemize}
    \item[(e)] The median can be a direct child of the root (for example, if every right subtree is larger than every left subtree), and it can also be in one of the leaves (if the half smallest values are in the leaves).
\end{itemize}",5,h,tested,1,"בערימת מקסימום, החציון נמצא  בהכרח:
א. בשורש.
ב. בעומק לכל היותר log(n)/2 - 1 .
ג. בעומק לכל היותר log(n)/2 + 1
ד. בשתי השכבות הנמוכות ביותר.
ה. אף אחד מהנ""ל.","ה. החציון יכול להיות בן ישיר של השורש (למשל אם כל תת עץ ימין גדולים מכל תת עץ שמאל) ויכול גם להיות באחד העלים (אם חצי הערכים הקטנים ביותר נמצאים בעלים).
",,,,
C,TRUE,2005,a,a,6,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,8,"\noindent Let \( T \) be an AVL tree with \( n \) nodes. The height of a node is defined as the length of the longest path (in edges) from it to a leaf. For example, the height of a leaf is 0. Let \( m \) be the node that contains the minimum value in the tree. Then the height of \( m \) in \( T \) is: 

\begin{enumerate}
    \item necessarily \( 0 \).
    \item less than or equal to \( 1 \).
    \item exactly \( 1 \).
    \item less than or equal to \( 2 \).
    \item possibly \(\Theta(\log(n))\).
    \item possibly \(\Theta(n)\).
\end{enumerate}",B,"
b. The minimum has no left child. Therefore, it is a leaf or a node with a right child that must, according to the AVL definition, be a leaf.
",6,f,tested,1,"יהא T עץ AVL בעל n  צמתים. גבהו של צמת מוגדר כאורך המסלול (בקשתות) הארוך ביותר ממנו לעלה. לדוגמה – גבהו של עלה הינו 0. יהא m  הצומת שמכיל את ערך המינימום בעץ. אזי גבהו של m  ב-T הינו: 

א. בהכרח 0.
ב. קטן מ או שווה ל 1. 
ג. בדיוק 1.
ד. קטו מ או שווה ל 2.
ה. יכול להיות θ(log(n)).
ו. יכול להיות θ(n).","ב. למינימום אין בן שמאלי. לכן הוא עלה או צומת עם בן ימני שחייב, לפי הגדרת AVL , להיות עלה.",,,,
C,TRUE,2005,a,a,7,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,9,"\noindent Given an array $A$ containing $n$ distinct (unsorted) elements. A min-heap $H$ is given, containing the same elements. We want to take the smallest $n^{0.5}$ elements and sort them in the lowest worst-case time. Let $a(n)$ be the cost of performing the operation (with the best algorithm you know) on $A$ and let $h(n)$ be the cost of performing the operation (with the best algorithm you know) on $H$. Then:
\begin{enumerate}
    \item The cost of execution for both algorithms is identical.
    \item The cost of execution for both algorithms is asymptotically the same, but the constant factor for $a(n)$ is lower.
    \item The cost of execution for both algorithms is asymptotically the same, but the constant factor for $h(n)$ is lower.
    \item $a(n) = o(h(n))$.
    \item $h(n) = o(a(n))$.
\end{enumerate}",5,"
5. Perform ORDER STAT on \( A \) and then sort. Cost: \(\Theta(A \log A)\). Perform \(\Theta(H \cdot \log H)\) DELETEMIN on \( H \). Cost: \(\Theta(H \cdot \log H)\).
",5,"d,h",tested,1,"נתון מערך A ובו n  נתונים שונים זה מזה (לא ממוינים). נתונה ערימת מינימום H ובה אותם נתונים. מעוניינים לקחת את n^0.5 האיברים הקטנים ביותר ולמיינם בזמן Worst case  הנמוך ביותר. יהא a(n)  עלות ביצוע הפעולה (על ידי האלגוריתם הטוב ביותר שהנכם מכירים) על A ותהא h(n)  עלות היבצוע (על ידי האלגוריתם הטוב ביותר שהנכם מכירים)  על H. אזי:  
1. עלות הבצוע של שני האלגורתמים זהה. 
2. עלות הבצוע של שני האלגורתמים בסדר גודל  זהה אבל הקבוע של a(n) נמוך יותר.
3. עלות הבצוע של שני האלגורתמים בסדר גודל  זהה אבל הקבוע של h(n) נמוך יותר.
a(n)=o(h(n .4. )).
h(n)=o(a(n .5)).",ה. על A מבצעים ORDER STAT ואחכ מיון. עלות:  EMBED Equation.3  על H מבצעים  EMBED Equation.3   DELETEMIN . עלות:  EMBED Equation.3  ,,,,
A,TRUE,2005,a,a,8.I,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,15,na,na,na,na,na,na,1,"תארו מבנה נתונים המתחזק קבוצה של נקודות במישור, כאשר כל נקודה  piמיוצגת כזוג מספרים (xi,yi). מבנה הנתונים צריך לתמוך בפעולות insert(x,y), delete(x,y), find(x,y) בזמן גרוע ביותר O(log n), וכמו כן תומך בפעולה  CountPointsAtDistance(d1,d2), המבצעת את הפעולה הבאה: בהינתן שני מספרים d1,d2 מחזירה הפעולה את מספר הנקודות במבנה שמרחקן מהראשית גדול מ d1 וקטן מ d2 (זיכרו כי מרחק נקודה (x,y) מהראשית הוא (x^2 + y^2)^0.5).  
CountPointsAtDistance(d1,d2)  צריכה להתבצע בסיבוכיות הנמוכה ביותר האפשרית.","עץ חיפוש מאוזן (2-3  או AVL למשל) שבו המפתח הינו המרחק d. מתחת לכל עלה מוחזק עץ 2-3 שבו המפתחות המתאימים  (x,y) בסדר לקסיקוגרפי. 
העץ הראשי בנוי כעץ ORDER STAT בו בכל צומת שומרים את מספר המפתחות שנמצאים בתת העץ. כיצד ממומשת הפעולה CountPointsAtDistance ומה הסיבוכיות שלה:
מוצאים את הנקודה הרחוקה ביותר מהראשית שמרחקה קטן מ-d2.
מחשבית את הסדר הסטטיסטי שלה: a. 
מוצאים את הנקודה הקרובה ביותר לראשית שמרחקה גדול מ-d2.
מחשבית את הסדר הסטטיסטי שלה: b. 
מחזירים את a-b+1.
כל אחת מהפעולות הנ""ל מבוצעת בזמן O(log n) W.C. לכן זהו זמן ריצת הפעולה.",,,,
A,TRUE,2005,a,a,8.II.a,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,5,na,na,na,na,na,na,1,"יהא A אלגוריתם מיון כלשהו. עבור מספר כלשהו n, נגדיר את Compare(n,i) להיות מספר הפעמים הגדול ביותר (על פני כל הקלטים בגודל n) ש A משווה את האיבר שנמצא במקום i בקלט עם איבר כלשהו אחר. כמו כן נגדיר את Compare(n) להיות להיות המקסימום על פני כל i
של Compare(n,i).  עבור MergeSort, האם Compare(n)=O(log n)?הסבירו"," EMBED Equation.3  . בפאזה האחרונה אם מערך אחד מכיל אברים גדולים  מהשני, מוביל לעלות הזו.",,,,
A,TRUE,2005,a,a,8.II.b,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,4,na,na,na,na,na,na,1,"יהא A אלגוריתם מיון כלשהו. עבור מספר כלשהו n, נגדיר את Compare(n,i) להיות מספר הפעמים הגדול ביותר (על פני כל הקלטים בגודל n) ש A משווה את האיבר שנמצא במקום i בקלט עם איבר כלשהו אחר. כמו כן נגדיר את Compare(n) להיות להיות המקסימום על פני כל i
של Compare(n,i). האם ניתן לכתוב אלגוריתם מיון חדש B שמקבל גם את x בקלט, כך שO(logn)  =? Compare(n,x,I)
הסבירו.  ",כן. מיון שאר האיברים ובצוע binary search   ל-.x,,,,
A,TRUE,2005,a,a,8.II.c,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,6,na,na,na,na,na,na,1,"יהא A אלגוריתם מיון כלשהו. עבור מספר כלשהו n, נגדיר את Compare(n,i) להיות מספר הפעמים הגדול ביותר (על פני כל הקלטים בגודל n) ש A משווה את האיבר שנמצא במקום i בקלט עם איבר כלשהו אחר. כמו כן נגדיר את Compare(n) להיות להיות המקסימום על פני כל i
של Compare(n,i). האם יש אלגוריתם מיון במודל השוואות המקיים Compare(n)=O(log log n)? ","לא. זה יאפשר מיון בO(nlglgn)   השוואות. זמן הריצה אמנם יכול להיות גדול יותר, אבל הראינו שמספר ההשוואות לאלגוריתם מיום במודל זה הוא (n lg n) .",,,,
A,TRUE,2005,a,a,9,https://docs.google.com/document/d/1Ze9Vu1t-M8eGfSRY5m6GdpbIz9KUxnzN,TAU,12,na,na,na,na,na,na,1,"תארו אלגוריתם לפתרון הבעיה הבאה: 
קלט: קבוצה כלשהי {a1,...,an}=A של n מספרים. 
מטרה: האלגוריתם צריך לבנות בזמן ממוצע טוב ביותר מבנה נתונים DS בעל התכונה הבאה:             בהינתן אוסף S של m מספרים שאיבריו לקוחים מ A, ניתן להיעזר בDS  בכדי למיין את איברי S בזמן  O(max(m,n)) ב WC. שימו לב כי S יכולה להכיל איבר כלשהו של A מספר פעמים. על כן ייתכן כי מתקיים m>n.","תאור מבנה הנתונים DS:
Perfect hash של האיברים עבור ערכם. לכל איבר שומרים גם את הrank  שלו (הסדר הסטטיסטי). 
תאור בניית המבנה:
ממינים המערך –O(nlgn) – למציאת rank  של כל איבר. 
מכניסים את האיברים לperfecct hash O(n)בממוצע. 



כיצד ניתן למיין בעזרת מבנה הנתונים:
מוצאים את הסדר הסטטיסטי של כל איבר ב-S. ממינים את S לפי הסדרים הסטטיסטים בעזרת CountSort.
",,,,
D,TRUE,2005,"a,b",b,1,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,8,"\begin{flushleft}
Given an array representing a maximum heap of size \( n \). QuickSort is applied to it. The pivot element at each stage is chosen to be the first in the subarray on which the algorithm is applied. The worst-case runtime is:
\begin{enumerate}
    \item \(\Theta(n)\)
    \item \(\Theta(n \log n)\)
    \item \(\Theta(n^2)\)
    \item \(\Theta(n^2 \log n)\)
    \item \(\Theta(n^3)\)
\end{enumerate}
\end{flushleft}",3,na,5,"I,h",tested,1,"נתון מערך המייצג ערימת מקסימום בגודל n. מפעילים עליו את מיון QuickSort. איבר הציר בכל שלב נבחר להיות הראשון בתת המערך עליו מופעל האלגוריתם. זמן הריצה W.C. הוא:
א. θ(n)
ב. θ(nlog(n)) 
ג. θ(n^2)
ד. θ(n^2log(n))
ה. θ(n^3).",na,,,,
D,TRUE,2005,"a,b",b,2,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,na,1,na,5,"a,i",na,1,"נסתכל על אלגוריתם quicksort   המתבצע על מערך Aשבו מציאת הפיבוט מתבצעת כדלקמן: מצא את ערכי המינימום (min) ומקסימום (max) ב-A ובחר את הפיבוט להיות הממוצע של min  ו max. במידה והאלגוריתם מתבצע על מערך שבו נמצאים האברים 1,2,..,N (בסדר שרירותי) אזי סבוכיות quicksort  הינה:
א. θ(nlog(n)) =worst case ו-  θ(nlog(n))  =average case.
ב. θ(n^2) =worst case ו-   θ(nlog(n)) =average case.
ג. θ(n^2) =worst case ו-  θ(n^2)  =average case.
ד. worst case לא חסום ו-   θ(nlog(n)) =average
ה. אף אחת מהתשובות לעיל אינה נכונה. ",na,,,,
D,TRUE,2005,"a,b",b,3,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,"
Let \( T(n) \) be a function satisfying:
\[ T(n) = T(c \cdot n) + T(d \cdot n) + n \]
where \( c > 0, d > 0 \), and \( c + d < 1 \).

\( T(n) = ? \)

A. \( \theta(\log(n)) \).

B. \( \theta(\max\{n^c, n^d\}) \).

C. \( \theta(n) \).

D. \( \theta(n\log(n)) \).

E. \( \theta(n^{1/(c+d)}) \).

F. None of the above.
",3,na,6,a,tested,1,"תהא T(n) פונקציה המקיימת:
  T(n) = T(c*n) + T(d*n) + n
c > 0, d > 0
c + d < 1
T(n) = ?
א. θ(log(n)).
ב. θ(max{n^c, n^d}).
ג. θ(n).
ד. θ(nlog(n))
ה. θ(n^(1/(c+d)))
ו. אף אחד מהנ""ל",na,,,,
D,TRUE,2005,"a,b",b,4,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,"
Given a binary search tree (not necessarily balanced) of size \( n \) and height \( h \), where each node has a field \( Su \) pointing to the successor, but this field is incorrect. We want to fix the tree, i.e., correct the \( Su \) field of all the nodes in minimal worst-case time. It can be done in:

A. \( \Theta(\log(n)) \) \\
B. \( \Theta(n) \) \\
C. \( \Theta(n\log(n)) \) \\
D. \( \Theta(n^2) \) \\
E. \( \Theta(nh^2) \) \\
F. None of the above
",2,na,6,e,untested,1,"נתון עץ חיפוש בינרי (לא בהכרח מאוזן) בגודל n ובגובה h, שבו לכל צומת יש שדה Su המצביע לעוקב, אבל השדה הנ""ל שגוי.  רוצים לתקן את העץ, כלומר לתקן את השדה Su של כל הצמתים בזמן W.C. מינימלי. ניתן לעשות זאת בזמן
א. θ(log(n))
ב. θ(n) 
ג. θ(nlog(n))
ד. θ(n^2)
ה. θ(n*h^2)
ו. אף אחד מהנ""ל",na,,,,
D,TRUE,2005,"a,b",b,5,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,na,2,na,4,"e,f,g",na,1,"נתון מבנה נתונים A. 
טענה:
אם נמחק מ-A קודם את הערך 3 ואז נמחק את הערך 4 נקבל את אותו מבנה בדיוק  כמו במקרה שבו נמחק מ-A קודם את הערך 4 ואחר-כך את הערך 3 (הניחו שכל ערך מופיע לכל היותר פעם אחת).
הטענה נכונה תמיד כאשר A הוא:

א. עץ חיפוש בינרי.
ב. טבלת Hash שבה התנגשויות נפתרות ע""י רשימות מקושרות.
ג. א+ב
ד. אף אחד מהנ""ל.",na,,,,
D,TRUE,2005,"a,b",b,6,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,"
Claim: If \( f(n) = O(g(n)) \) then \( \sqrt{f(n)} = O(\sqrt{g(n)}) \).

a. The claim is always false

b. The claim is always true

c. The claim is sometimes true and sometimes false
",2,na,3,a,tested,1,"טענה: אם f(n)=O(g(n)) אזי f(n)1/2=O(g(n)1/2).

א. הטענה תמיד לא נכונה

ב. הטענה תמיד נכונה

ג. הטענה לפעמים נכונה ולפעמים לא נכונה
",na,,,,
D,TRUE,2005,"a,b",b,7,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,"
Claim: If we traverse a minimum heap (Min-Heap) in which all elements are distinct using LRD traversal (post-order), we will obtain a decreasing sequence of heap elements.

A. The claim is always false.

B. The claim is always true.

C. The claim is sometimes true and sometimes false.
",3,na,3,h,tested,1,"טענה: אם נסייר על ערימת מינימום (Min-Heap) שכל אבריה שונים זה מזה בסיור LRD (post-order) אזי נקבל סדרה יורדת של אברי הערימה

א. הטענה תמיד לא נכונה

ב. הטענה תמיד נכונה

ג. הטענה לפעמים נכונה ולפעמים לא נכונה",na,,,,
A,FALSE,2005,"a,b",b,8.a,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,12,na,na,na,na,na,na,1,"נתון מערך בגודל n, המחולק ל-n/k קטעים באורך k כל אחד. האיברים בכל קטע גדולים מכל האיברים בקטע משמאלו וקטנים מכל האיברים בקטע מימינו. נתעניין באלגוריתם מיון למערך כזה, המתאים למודל ההשוואות, וכן בחסם תחתון לאלגוריתמי מיון במודל ההשוואות למערך כזה. ניתוח זמן הריצה של האלגוריתם (כפונקציה של n ו-k):",na,,,,
A,FALSE,2005,"a,b",b,8.c,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,6,na,na,na,na,na,na,1,"נתון מערך בגודל n, המחולק ל-n/k קטעים באורך k כל אחד. האיברים בכל קטע גדולים מכל האיברים בקטע משמאלו וקטנים מכל האיברים בקטע מימינו. נתעניין באלגוריתם מיון למערך כזה, המתאים למודל ההשוואות, וכן בחסם תחתון לאלגוריתמי מיון במודל ההשוואות למערך כזה. הציעו אלגוריתם יעיל יותר, אם ידוע שבכל קטע, מספר הערכים השונים הוא לכל    היותר(( log(log(k:",na,,,,
A,FALSE,2005,"a,b",b,9.a,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,13,na,na,na,na,na,na,1,נתונה קבוצה S של n מספרים שונים. תארו אלגוריתם העובד ב-O(n) זמן כך שבהינתן מספר חיובי k (k<n) האלגוריתם מחזיר את k המספרים הכי קרובים לחציון של S.,na,,,,
A,FALSE,2005,"a,b",b,9.b,https://docs.google.com/document/d/1v9YBu71MdYUn2k2hxj7fgF-DeJsqsoZM,TAU,7,na,na,na,na,na,na,1,"אלגוריתם מיון נקרא יציב (stable) אם לכל שני מקומות במערך A :  A[j], A[i] שהמפתחות שלהם שווים, מתקיים שהם נשארים אחרי המיון בסדר בו היו לפני המיון. נתון אלגוריתם מיון ALG שרץ בזמן f(n). הראו כיצד ניצן ליצור ממנו אלגוריתם מיון יציב ALG2 שרץ בזמן f(n)+O(n).",na,,,,
C,TRUE,2006,a,a,1,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,na,A,na,6,a,na,1,"יהיו .	
נרצה להשוות את שתי הפונקציותf(n) = (n!)^2006,
g(n) = (n^2006)!.  מה מהבאים נכון?
א. f(n) = o(g(n))
ב. f(n) = w(g(n)) 
ג. f(n) = θ(g(n))
ד. ב + ג נכונים
ה. א + ג נכונים
ו. אף אחד מהנ""ל אינו נכון.","א. 
f(n) היא מכפלה של 2006n גורמים שכולם קנים או שווים n.
g(n) היא מכפלה של n2006 גורמים, שכולם למעט n מהם גדולים מ-n.",,,,
C,TRUE,2006,a,a,2,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,na,C,na,6,a,na,1,"נתונה נוסחת הנסיגה הבאה: T(n) = T(n/3) + T(a*n) + n		
מבין הערכים הבאים עבור  α, מהו הגבוה ביותר שעבורו מתקיים ש-T(n) = O(n)?
א. a = 1/4
ב. a = 1/3 
ג. a = 1/2
ד. a = 2/3
ה. a = 3/4 
ו. a = 2005/2006","ג. 
אם α הוא קבוע קטן מ-2/3 אז  EMBED Equation.DSMT4   (כמו שראינו בש""ב). 
אם α הוא קבוע 2/3 אז  EMBED Equation.DSMT4   (ניתוח בעזרת למשל עץ רקורסיה בדומה לחישוב זמן הריצה של MergeSort).",,,,
C,TRUE,2006,a,a,3,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,"
The recurrence formula \( T(n) = T(n/2) + T(n/2) + \theta(n) \) describes the W.C. running time of the following algorithms:
Note: For a specific algorithm, it is not enough that the complexity matches the solution of the recurrence formula. The recurrence formula must also fit the operation of the algorithm.
\begin{enumerate}
    \item QuickSort
    \item QuickSort where the pivot element is chosen to be the median using Select.
    \item Sorting by insertion into an AVL search tree and scanning the tree at the end.
    \item MergeSort
    \item b + d
    \item b + c + d
\end{enumerate}
",E,"
5. 
The recurrence formula describes both MergeSort and QuickSort, provided that the pivot element is chosen to be the median in linear time (for example, using Select). In standard QuickSort, the partitioning can be unbalanced, so the above recurrence formula is not suitable. Sorting using an AVL tree indeed takes \(O(n \log n)\), which is the solution of \(T\), but \(T\) does not fit to describe the runtime (for example, because it is not a recursive algorithm).
",6,"f,j",tested,1,"נוסחת הנסיגה T(n) = T(n/2) + T(n/2) + θ(n)  
מתארת את זמן W.C. הריצה של האלגוריתמים הבאים :
הערה: עבור אלגוריתם מסוים לא מספיק שסיבוכיות תהיה זהה לפתרון נוסחת הנסיגה. צריך גם שנוסחת הנסיגה תתאים לפעולת האלגוריתם.  
א. QuickSort
ב. QuickSort כאשר איבר הציר (Pivot) נבחר להיות החציון על ידי Select.
ג. מיון על ידי הכנסות לעץ חיפוש AVL וסריקת העץ בסוף.
ד. MergeSort
ה. ב + ד
ו.  ב + ג + ד ","ה.
נוסחת הנסיגה מתארת את MergeSort וגם את QuickSort בתנאי שאיבר הציר נבחר להיות החציון בזמן לינארי (למשל על ידי Select). ב-QuickSort רגיל החלוקה עלולה להיות לא מאוזנת ולכן נוסחת הנסיגה הנ""ל לא מתאימה.  מיון על ידי עץ AVL אמנם לוקח  EMBED Equation.DSMT4  , שזהו הפתרון של T, אבל T לא מתאימה לתיאור זמן הריצה (למשל, כי זה לא אלגוריתם רקורסיבי).",,,,
C,TRUE,2006,a,a,5,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,"
Given a 2-3 search tree where the root has exactly two children: left and middle. Let \( X \) denote the number of nodes in the middle subtree and \( Y \) denote the number of nodes in the left subtree. Which of the following is necessarily true? (If more than one answer is correct, choose the tightest one).

\begin{itemize}
    \item[A.] \( X = Y \)
    \item[B.] \( X \leq 1.5Y \)
    \item[C.] \( X \leq 2Y \)
    \item[D.] \( X \leq 6Y \)
    \item[E.] \( X \leq 2006Y \)
    \item[F.] None of the above.
\end{itemize}
",F,"\textbf{6.}\\
It is possible for one subtree of each node to have exactly two children and the other subtree to have exactly three children. Therefore, if the height of the tree is $h$, then in one subtree the number of nodes is $2^h - 1$ and in the other $3^h - 1$. That is, in the first there are $2^h - 1$ nodes, and in the second more than $2^h - 1$ nodes.

",6,f,tested,1,"נתון עץ חיפוש 2-3  שבו לשורש יש בדיוק שני בנים: שמאלי ומרכזי.
נסמן ב-X את מספר הצמתים בתת העץ המרכזי וב-Y את מספר הצמתים בתת עץ שמאל. מה מהבאים בהכרח נכון?
(אם יש יותר מתשובה אחת נכונה, בחרו את ההדוקה ביותר).
א. X = Y
ב. X <= 1.5*Y 
ג. X <= 2*Y
ד. X <= 6*Y
ה. X <= 2006*Y
ו. אף אחד מהנ""ל.","ו.
יתכן מצב שבו בתת עץ אחד לכל צומת יש בדיוק שני בנים ובתת העץ השני לכל צומת יש בדיוק 3 בנים. לכן אם גבה העץ הוא h אז בתת עץ אחד מספר הצמתים הוא  EMBED Equation.DSMT4  ובשני  EMBED Equation.DSMT4  . כלומר בראשון יש  EMBED Equation.DSMT4  צמתים ובשני יותר מ- EMBED Equation.DSMT4  צמתים.",,,,
C,TRUE,2006,a,a,6,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,na,C,na,6,"a,k",na,1,"נתייחס לאלגוריתם המיון הבא: 
בדוק האם הקלט ממוין על ידי השוואת כל איבר לבא אחריו במערך. 
אם כן – סיים. אחרת – הפעל את אלגוריתם MergeSort. 
מהו העומק הממוצע של עלה בעץ ההחלטות של אלגוריתם המיון הנ""ל על מערך בגודל n?
א. θ(log(n))
ב. θ(n) 
ג. θ(nlog(n))
ד. θ(n^2)
ה. θ(n!)
ו. האלגוריתם הנ""ל לא מתאים למודל ההשוואות ולכן השאלה חסרת משמעות.","ג.
עבור קלט ממוין מספר ההשוואות שמבצעים הוא n. כלומר העלה שמייצג מערך ממוין הוא בעומק n.
לכל קלט אחר מספר ההשוואות ש-MergeSort מבצע הוא  EMBED Equation.3  . כלומר כל עלה אחר הוא בעומק  EMBED Equation.3  . יש בעץ יש n!  סה""כ. לכן העומק הממוצע הוא:  EMBED Equation.3 ",,,,
C,TRUE,2006,a,a,7,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,"
Given a binary search tree (not necessarily balanced) with \( n \) nodes, where each node has two additional fields: Pred, Suc, which point to the predecessor and successor of the node. We want to implement the Delete operation on this tree in the best possible W.C. time, such that after the deletion all the fields in the tree are correct. The delete operation receives a pointer to the element intended for deletion. It is allowed to assume that all the regular fields exist, such as \texttt{Parent[x]}. The resulting time is:
\begin{enumerate}
    \item \(\Theta(1)\)
    \item \(\Theta(\log(n))\) independent of the height of the tree.
    \item \(\Theta(n)\) independent of the height of the tree.
    \item \(\Theta(h)\) where \( h \) is the height of the tree.
    \item \(\Theta(n\log(n))\)
    \item It is impossible to perform deletion on such a tree, because it is impossible to determine with certainty the new value for the Pred and Suc fields.
\end{enumerate}
",A,"
Let \( x \) be the deleted element. Remember its predecessor and successor in order to update their mutual pointers after deleting \( x \). If \( x \) has a single child or is a leaf – delete it in \( O(1) \) time as in a regular deletion. If \( x \) has two children – find its successor using the field \texttt{Suc} in \( O(\log n) \) time, and proceed as in a regular deletion: swap and delete in the new location. Total time - \( O(\log n) \).
",6,"a,e",tested,1,"נתון עץ חיפוש בינרי (לאו דוקא מאוזן) בעל n צמתים שבו לכל צומת זוג שדות נוספים: Pred, Suc שמצביעים לקודם ולעוקב של הצומת. רוצים לממש פעולת Delete על עץ זה בזמן W.C. הטוב ביותר האפשרי (כך שאחרי המחיקה כל השדות בעץ נכונים). פעולת המחיקה מקבלת מצביע לאיבר המיועד למחיקה. מותר להניח שקיימים כל השדות הרגילים, כמו Parent[x]. הזמן המתקבל הוא:
א. θ(1)
ב. θ(log(n)) ללא תלות בגובה העץ.
ג. θ(n) ללא תלות בגובה העץ.
ד. θ(h) כאשר h גובה העץ.
ה. θ(nlog(n))
ו. לא ניתן לבצע מחיקה בעץ כזה, כי אי אפשר לקבוע בוודאות את הערך החדש לשדות Pred ו-Suc."," א. 
נניח ש-x הוא האיבר הנמחק. נזכור את הקודם והעוקב של x כדי לעדכן את ההצבעה ההדדית שלהם אחרי מחיקת x. 
אם ל-x יש בן יחיד או הוא עלה – נמחק אותו בזמן  EMBED Equation.DSMT4  כמו במחיקה רגילה. אם ל-x יש שני בנים – נמצא את העוקב שלו בעזרת השדה Suc בזמן  EMBED Equation.DSMT4  , ונמשיך כמו במחיקה רגילה: החלפה ומחיקה במקום החדש. סה""כ זמן -  EMBED Equation.DSMT4  .",,,,
C,TRUE,2006,a,a,8,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,8,"\begin{itemize}
    \item What is the data structure with the worst-case search time?
    \item A. A hash table with collision resolution by linked lists.
    \item B. Perfect Hash
    \item C. A max heap implemented by an array.
    \item D. A+B
    \item E. A+C
    \item F. A+B+C
\end{itemize}",E,"\begin{itemize}
    \item[5.] The search time in the worst case for a hash table and the heap is $O(\log n)$. For a perfect hash, the search time is $O(1)$ in the worst case.
\end{itemize}",6,"e,f,g",untested,1,"לאיזה מהמבנים הבאים יש זמן חיפוש W.C. הגרוע ביותר ?
א. טבלת Hash שבה פתרון התנגשויות על ידי רשימות מקושרות.
ב. Perfect Hash
ג. ערימת מקסימום במימוש מערך.
ד. א+ב
ה. א+ג
ו. א+ב+ג","ה. 
לטבלת Hash ולערימה זמן חיפוש W.C.  EMBED Equation.DSMT4  . ל- Perfect Hashזמן חיפוש  EMBED Equation.DSMT4  W.C..",,,,
A,TRUE,2006,a,a,9,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,14,na,na,na,na,na,na,1,"נתונה ערימת מקסימום במימוש מערך (יש גישה לאיברי המבנה) בגודל n ונתון מספר k.
רוצים להדפיס את k האיברים הגדולים בערימה בזמן θ(klog(k)) W.C..
רמז:  אפשר להשתמש בערימה נוספת.","האלגוריתם:
נחזיק ערימת עזר. בערימת העזר נחזיק חלק מהמפתחות של הערימה המקורית, עם מצביעים לצמתים המתאימים בערימה המקורית. בהתחלה נעתיק לערימת העזר את שורש הערימה המקורית.
בכל שלב נבצע ExtractMax מערימת העזר. נדפיס את האיבר שיצא x. את שני בניו בערימה המקורית נכניס לערימת העזר. נחזור על הנ""ל עד שהודפסו k איברים.
הסבר נכונות: 
אם המפתח של צומת הוא לא בין k המפתחות הגדולים, אז לא צריך להדפיס אותו, ובהכרח גם את בניו לא צריך להדפיס. נשים לב שבכל שלב ערימת העזר מכילה את כל האיברים הפוטנציאלים להדפסה, כלומר את כל הבנים (מהערימה המקורית) של הצמתים שהודפסו. כל צומת שאביו יודפס – יכנס בעצמו לערימה, וכל צומת שאביו לא יודפס – לא יכנס לערימה. לכן האלגוריתם ידפיס את k הערכים הגדולים ביותר, ואפילו בסדר יורד. ניתוח זמן ריצה:
בכל שלב מוציאים מערימת העזר איבר אחד ומכניסים במקומו שניים. כלומר גודל ערימת העזר הוא לכל היותר k+1. לכן זמן פעולה בסיסית על הערימה הוא  EMBED Equation.DSMT4  . 
מציאת שני הבנים מבוצעת בזמן   EMBED Equation.DSMT4   (כי יש מצביע לאיבר המתאים בערימה המקורית). סה""כ  EMBED Equation.DSMT4  . 
בכל שלב של הריצה מבצעים שלוש פעולות על ערימת העזר (פעם אחת Extract ופעמיים Insert). יש k שלבים כאלה. סה""כ  EMBED Equation.DSMT4  .
לכן סה""כ זמן ריצה  EMBED Equation.DSMT4  .
נשים לב שב-k/2 השלבים האחרונים הערימה כבר בגודל לפחות k/2, לכן זמן פעולה בסיסית על הערימה הוא  EMBED Equation.DSMT4  , כלומר זמן הריצה הכולל הוא גם  EMBED Equation.DSMT4  , ולכן  EMBED Equation.DSMT4  .
",,,,
A,TRUE,2006,a,a,10.a,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,13,na,na,na,na,na,na,1,"תור-פרוטקציה הוא מבנה נתונים שתומך בפעולות של תור (Enqueue,Dequeue) ובנוסף – פעולת כניסה בפרוטקציה PEnqueue. 
פעולות Enqueue,Dequeue שומרות על סדר תור רגיל (הראשון שנכנס הוא הראשון שיוצא).
איבר שנוסף לתור בפעולת PEnqueue יצא מהתור לפני כל האיברים בתורשנכנסו בפעולת Enqueue וגם לפני כל האיברים בתור שנכנסו (לפניו) בפעולת PEnqueue.
לדוגמה, הפלט בעקבות הפעולות הבאות:
Enqueue(3), Enqueue(4), Enqueue(10), Dequeue, Penqueue(2006), Penqueue(2005), Dequeue, Dequeue, Dequeue
יהיה (משמאל לימין)
3, 2005, 2006, 4
הציעו מימוש למבנה זה המשתמש במספר מינימלי של מחסניות בלבד וכן O(1) זכרון נוסף.
על המחסנית מותר לבצע את הפעולות הרגילות אבל אין גישה למימוש.
זמן W.C. של פעולות Enqueue ו- PEnqueue צריך להיות θ(1). 
זמן W.C. של פעולת Dequeue – לא מוגבל.
זמן Amortized לפעולה צריך להיות θ(1).","שתי מחסניות A,B. 





מימוש פעולת Enqueue וניתוח זמן ריצתה:
Push למחסנית A. זמן ריצה  EMBED Equation.DSMT4  .


מימוש פעולת PEnqueue וניתוח זמן ריצתה:
Push למחסנית B. זמן ריצה  EMBED Equation.DSMT4  .




מימוש פעולת Dequeue:
אם מחסנית B לא ריקה – נבצע Pop ממנה.
אחרת – נעביר את כל האיברים ממחסנית A למחסנית B אחד אחרי השני ואז נבצע Pop מ-B ניתוח זמן Amortized לפעולה במבנה:
נסתכל על סדרה של N פעולות. בסדרה כזו נכנסו למבנה לכל היותר N איברים (על ידי פעולות Enqueue  ו-PEnqueue). 
אם איבר נכנס על ידי פעולת PEnqueue (כלומר למחסנית B) אז סה""כ מבוצעות עליו שתי פעולות לכל היותר: Push ל-B ואולי גם Pop מ-B.
אם איבר נכנס על ידי פעולת Enqueue (כלומר למחסנית A) אז סה""כ מבוצעות עליו ארבע פעולות לכל היותר: Push ל-A ואולי גם Pop מ-A ו-Push ל-B ואולי Pop מ-B.
כלומר בכל מקרה על כל איבר ""מבזבזים"" זמן O(1). 
לכן בכל סדרה של N פעולות זמן הריצה הוא O(N). ברור שזמן הריצה הוא גם  EMBED Equation.3  , כי כל פעולה בסדרה לוקחת  EMBED Equation.3  . 
לכן כל סדרה, ובפרט בסדרה הגרועה ביותר, לוקחת זמן ריצה  EMBED Equation.DSMT4  . 
 זמן Amortized לפעולה הוא לכן:  EMBED Equation.DSMT4  .

",,,,
A,TRUE,2006,a,a,10.b,https://docs.google.com/document/d/1altMUQBVybKQpoFz-rQsDmI_e0FWhzbu,TAU,9,na,na,na,na,na,na,1," נתון מבנה נתונים דינאמי  המאפשר Insert, Delete ו-FindMin.
תנו חסם תחתון לזמן Amortized לפעולה, בהנחה שהמבנה מתאים לשימוש במודל ההשוואות ","EMBED Equation.DSMT4  

הוכחה: יהי A מבנה נתונים דינמי נראה סדרה של פעולות שמאפשרת למיין מערך בגודל n:
1. נבצע n פעולות Insert.
2. נחזור n פעמים על הפעולה הבאה:
נבצע FindMin, נדפיס את האיבר שמצאנו ונמחק אותו מהמבנה.
הנ""ל הוא אלגוריתם מיון, וברור שהוא במודל ההשוואות (כי המבנה במודל ההשוואות).",,,,
D,TRUE,2006,a,b,1,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,7,"
Let \( f(n) = (n!)^{2006} \),
\( g(n) = (n^{2006})! \).
We wish to compare the \(\log\) of the two functions. Which of the following is correct?

A. \(\log(f(n)) = o(\log(g(n)))\)

B. \(\log(f(n)) = \omega(\log(g(n)))\)

C. \(\log(f(n)) = \Theta(\log(g(n)))\)

D. None of the above.
",1,na,4,a,tested,1,"יהיו f(n) = (n!)^2006,
g(n) = (n^2006)!.
נרצה להשוות את ה-log  של שתי הפונקציות.  מה מהבאים נכון?

א. log(f(n)) = o(log(g(n)))
ב. log(f(n)) = w(log(g(n))) 
ג. log(f(n)) = θ(log(g(n)))
ד. אף אחד מהנ""ל.",na,,,,
D,TRUE,2006,a,b,2,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,7,"
Solve the following recurrence relation:
\begin{equation}
T(n) = 3 \cdot T(n - 2) + 9
\end{equation}
\( T(1) = T(2) = 1 \)

What is \( T(n) \)?

a. \( \theta(n^3) \)

b. \( \theta(n^2) \)

c. \( \theta(3^n) \)

d. \( \theta(n^{1.5}) \)

e. \( \theta((3^{0.5})^n) \)
",5,na,5,a,tested,1,"פתרו את נוסחת הנסיגה הבאה:
T(n) = 3*T(n - 2) + 9
T(1) = T(2) = 1
T(n) = ?
א. θ(n^3)
ב. θ(n^2) 
ג. θ(3^n)
ד. θ(n^1.5)
ה. θ((3^0.5)^n)",na,,,,
D,TRUE,2006,a,b,3,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,8,"\textit{Given an empty AVL tree. We perform \( n \) Insert operations on it. Which of the following is true?}

\begin{enumerate}
    \item The total running time will be \(\theta(n)\) and the number of rotations is necessarily \(O(n)\).
    \item The total running time will be \(\theta(n \log n)\) and the number of rotations is necessarily \(O(n)\).
    \item The total running time will be \(\theta(n)\) and the number of rotations can be \(\Omega(n \log n)\).
    \item The total running time will be \(\theta(n \log n)\) and the number of rotations can be \(\Omega(n \log n)\).
\end{enumerate}",2,na,4,"a,f",tested,1,"נתון עץ AVL ריק. מבצעים עליו n פעולות Insert. מה מהבאים נכון?
א. זמן הריצה הכולל יהיה θ(n) ומספר הרוטציות בהכרח O(n).
ב. זמן הריצה הכולל יהיה θ(nlog(n)) ומספר הרוטציות בהכרח O(n).
ג. זמן הריצה הכולל יהיה θ(n) ומספר הרוטציות יכול להיות Ω(nlog(n)).
ד. זמן הריצה הכולל יהיה θ(nlog(n)) ומספר הרוטציות יכול להיות Ω(nlog(n)).
",na,,,,
D,TRUE,2006,a,b,4,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,8,"
Given an AVL search tree that supports Order Statistic operations, meaning each node also has the Size field. An LRD (postorder) traversal is performed on the tree, but instead of printing the keys, the Size fields are printed. Which of the following is correct?
A. The first number printed is the smallest.
B. The last number printed is the largest.
C. The numbers will be printed in monotonically increasing order.
D. A+B
E. A+B+C
",4,na,5,f,tested,1,"נתון עץ חיפוש AVL התומך בפעולות סדר סטטיסטי (Order Statistic), כלומר בכל צומת יש גם את השדה Size. מבצעים סריקת LRD על העץ, אבל במקום להדפיס את המפתחות, מדפיסים את השדות Size. מה מהבאים נכון?
א. המספר הראשון שיודפס הוא הקטן ביותר.
ב. המספר האחרון שיודפס הוא הגדול ביותר.
ג. המספרים יודפסו בסדר מונוטוני עולה.
ד. א+ב
ה. א+ב+ג",na,,,,
D,TRUE,2006,a,b,5,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,8,"
We are interested in the QuickSort sorting algorithm when the pivot element is chosen to be the first in the segment of the array on which the algorithm operates (and not chosen randomly).
What is the smallest depth of a leaf in the decision tree of this algorithm on an array of size \( n \)?
a. \( \theta(n) \) \\
b. \( \theta(n \log(n)) \) \\
c. \( \theta(n^2) \) \\
d. \( \theta(n!) \) \\
e. \( \theta((n!) \log(n)) \) \\
f. The above algorithm does not fit the comparison model, so the question is meaningless.
",2,na,6,"I,k",untested,1,"נתעניין באלגוריתם המיון QuickSort כאשר איבר הציר (Pivot) נבחר להיות הראשון בקטע המערך עליו האלגוריתם פועל (ולא נבחר על ידי הגרלה).
מהו העומק הקטן ביותר של עלה בעץ ההחלטות של אלגוריתם זה על מערך בגודל  n?
א. θ(n)
ב. θ(nlog(n)) 
ג. θ(n^2)
ד. θ(n!)
ה. θ((n!)log(n))
ו. האלגוריתם הנ""ל לא מתאים למודל ההשוואות ולכן השאלה חסרת משמעות.",na,,,,
D,TRUE,2006,a,b,6,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,8,"
The median, using the function NewSelect. The running time of NewSelect on an array of size \(n\) is \(\Theta(n^{2006/2005})\) W.C.. The running time of the new QuickSort algorithm will be:
a. \(\Theta(n)\) W.C.
b. \(\Theta(n \log(n))\) W.C.
c. \(\Theta(n^2)\) W.C.
d. \(\Theta(n^{2006/2005})\) W.C.
e. \(\Theta(n^{2006/2005} \log(n))\) W.C.
f. \(\Theta(n^{2 \times 2006/2005})\) W.C.
",4,na,6,"a,i",tested,1,"החציון, בעזרת פונקצית NewSelect. זמן הריצה של NewSelect על מערך בגודל n הואθ(n^(2006/2005))  W.C.. 	זמן הריצה של אלגוריתם QuickSort החדש יהיה:
א. θ(n) W.C. 
ב. θ(nlog(n)) W.C. 
ג. θ(n^2) W.C. 
ד. θ(n^(2006/2005)) W.C. 
ה.  θ(n^(2006/2005)log(n)) W.C. 
ו. θ(n^(2*2006/2005)) W.C. ",na,,,,
D,TRUE,2006,a,b,7,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,8,"\begin{itemize}
    \item[] Given \( n \) elements. We want to build a data structure from them. Which of the following structures will have the longest W.C. build time?
    \begin{enumerate}
        \item A hash table where collisions are resolved using linked lists.
        \item Perfect hash.
        \item Max-heap.
        \item AVL search tree.
        \item A+C
        \item A+B+C
    \end{enumerate}
\end{itemize}",2,na,6,"e,f,g",tested,1,"נתונים n איברים. רוצים לבנות מהם מבנה נתונים. איזה מהמבנים הבאים זמן הבניה W.C. יהיה הארוך ביותר? 
א. טבלת Hash שבה פתרון התנגשויות על ידי רשימות מקושרות.
ב. Perfect Hash
ג. ערימת מקסימום.
ד. עץ חיפוש AVL.
ה. א+ג
ו. א+ב+ג",na,,,,
A,FALSE,2006,a,b,8.a,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,15,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (כלומר הקלט הוא n זוגות (x,y) של נקודות התחלה וסיום).
קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו אלגוריתם שמחזיר את מספר הקטעים המרכזיים, בזמן ריצה W.C. הטוב ביותר שתוכלו.",na,,,,
A,FALSE,2006,a,b,8.b,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,15,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (כלומר הקלט הוא n זוגות (x,y) של נקודות התחלה וסיום).
קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו מבנה נתונים דינמי, המאפשרFind  Insert ו-Delete של קטעים על הישר בזמן O(log n) W.C. וכן בפעולה IsCentric(p) שמקבלת מצביע לקטע במבנה, ועונה האם הקטע הוא מרכזי, 
בזמן W.C. O(1).",na,,,,
A,FALSE,2006,a,b,8.c,https://docs.google.com/document/d/1N_8TPis-QeSok6nc6qH27CNnIWn_kOpH,TAU,15,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (כלומר הקלט הוא n זוגות (x,y) של נקודות התחלה וסיום).
קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הוכיחו שבהנחת מודל ההשוואות, לא קיים מימוש משופר לפעולת    ExtractMax (הוצאת האיבר המקסימלי והבאת הערימה למצב ערימה חוקית) בערימת מקסימום, שמבטיח זמן ריצה o(log(n)) W.C. (שימו לב – ה-o קטן).",na,,,,
C,TRUE,2006,b,b,1,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,na,B,na,4,p,na,1,"נתון עץ אדום-שחור ריק. מבצעים עליו n פעולות Insert, כאשר בפעולת Insert נתון רק מצביע לשורש העץ, והאלמנט  החדש. (כלומר, לא נתון מצביע למקום ההכנסה, או כל מידע נוסף). מה מהבאים נכון?
א. זמן הריצה הכולל יהיה θ(n) ומספר הרוטציות בהכרח O(n).
ב. זמן הריצה הכולל יהיה θ(nlog(n)) ומספר הרוטציות בהכרח O(n).
ג. זמן הריצה הכולל יהיה θ(n) ומספר הרוטציות יכול להיות Ω(nlog(n)).
ד. זמן הריצה הכולל יהיה θ(nlog(n)) ומספר הרוטציות יכול להיות Ω(nlog(n)). ","ב'. זמן הריצה של פעולה אחת הוא O(logn), ולכן של n פעולות יהיה O(nlogn). זה הדוק כי אם היה ניתן להכניס n מספרים לעץ חיפוש בזמן o(nlogn) אז אחרי זה היה ניתן לקרוא אותם בקריאת in-order בזמן לינארי, ולכן היה ניתן למיין בזמן o(nlogn).

מספר הרוטציות הוא O(n) בגלל שיכולה להתבצע רק רוטציה אחת בכל פעולת insert, כי רוטציה מתבצעת רק במקרה שהוא terminal, כלומר מקרה שאחריו  החוק האדום והחוק השחור מתקיימים והפעולה הסתיימה.",,,,
C,TRUE,2006,b,b,2,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,"
Given a red-black search tree where at each node \( v \) there is a field \texttt{Size} containing the number of nodes in the subtree rooted at \( v \) (including \( v \)). A post-order traversal (LRD) is performed on the tree, but instead of printing the keys, the \texttt{Size} fields are printed. 
(Reminder: A post-order traversal is a traversal where first a recursive post-order traversal is performed on the left subtree, then the right subtree, and finally the value at the node itself is printed.)

The question: Which of the following is true?
A. The first number printed is the smallest.
B. The last number printed is the largest.
C. The numbers are printed in monotonically increasing order.
D. The sum of the second-to-last number printed and the third-to-last number printed is one less than the last number printed.
E. A + B
F. A + B + C
",E,"
a. True because the first node doesn't have a son (i.e., it is a leaf), otherwise its son would have been traversed before it.

b. True because a parent is traversed after its children, thus the last node to be traversed must be an ""orphan"", that is, the root of the tree.

c. and d. are not true, for example, if we take a complete tree of height 2.
",6,p,untested,1,"נתון עץ חיפוש אדום-שחור  כאשר בכל צומת v נמצא שדה Size שמכיל את מס' הצמתים בתת-העץ ששורשו v (כולל v). מבצעים post-order (LRD) על העץ, אבל במקום להדפיס את המפתחות, מדפיסים את השדות Size
(תזכורת: סריקת post-order היא סריקה בה קודם מבצעים רקורסיבית סריקת post-order של תת-העץ השמאלי, אחרי כן של תת העץ הימני, ולבסוף מדפיסים את הערך בצומת עצמו).

השאלה: מה מהבאים נכון?
א. המספר הראשון שיודפס הוא הקטן ביותר.
ב. המספר האחרון שיודפס הוא הגדול ביותר.
ג. המספרים יודפסו בסדר מונוטוני עולה.
ד. סכום המספר הלפני-אחרון שיודפס עם המספר הלפני-לפני-אחרון שיודפס קטן באחד מהמספר האחרון שיודפס.
ה. א+ב
ו. א+ב+ג"," ה.
א' נכון כי לצומת הראשון אין בן (כלומר הוא עלה), אחרת בנו היה נסרק לפניו.
ב' נכון כי אבא נסרק אחרי בניו ולכן הצומת האחרון שנסרק חייב להיות ""יתום"", כלומר שורש העץ.
 ג' וד' לא נכונים, למשל, אם ניקח עץ שלם בגובה 2.",,,,
A,TRUE,2006,b,b,3,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,na,na,na,na,na,na,1,"בשאלה זו נעסוק באלגוריתם מיון Quicksort. לכל אורך השאלה נניח שהקלט הוא מערך באורך n, ונתעניין רק במערכים בהם כל האיברים שונים. כזכור, לכל אלגוריתם מיון מתאים עץ בינארי המתאר את ההשוואות שהאלגוריתם מבצע על כל הקלטים האפשריים.

נתעניין באלגוריתם המיון QuickSort כאשר איבר הציר (Pivot) נבחר להיות הראשון בקטע המערך עליו האלגוריתם פועל (ולא נבחר על ידי הגרלה), ובעץ ההשוואות המתאים.

א. מהו העומק הקטן ביותר של עלה בעץ השוואות זה כפונקציה של n?","), מאותה סיבה ש-quicksort הרגיל דורש O(nlogn) השוואות. במקרה הכי טוב מתבצעת חלוקה של המערך לשני חלקים בגודל O(n), ועדיין יהיו O(log n) שלבים, ומס' ההשוואות בכל שלב הוא O(n). 
",,,,
C,TRUE,2006,b,b,4,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,"
We run the QuickSort algorithm. At each stage, the pivot element is chosen to be the median. However, the median is found by a new function called NewSelect, whose worst-case running time on an array of size \(n\) is \(O(n^{1.5})\). The worst-case running time of the QuickSort algorithm we defined will be:
\begin{enumerate}
    \item \(O(n)\)
    \item \(O(n \log(n))\)
    \item \(O(n^2)\)
    \item \(O(n^{1.5})\)
    \item \(O(n^{1.5} \log(n))\)
    \item \(O(n^3)\)
\end{enumerate}
",D,"
The total running time is \( T(n) = 2T(n/2) + n^{3/2} \), and according to the master method, for example, we get \(\mathcal{D}\).
",6,"a,i",untested,1," מריצים את אלגוריתם QuickSort. בכל שלב איבר הציר נבחר להיות החציון. אבל, את החציון מוצאים על ידי פונקציה חדשה בשם NewSelect, שזמן הריצה שלה במקרה הגרוע על מערך בגודל n הוא O(n^1.5). זמן הריצה של אלגוריתם QuickSort שהגדרנו במקרה הגרוע יהיה:
א. O(n) 
ב. O(nlog(n)) 
ג. O(n^2)  
ד. O(n^1.5)  
ה. O(n^1.5log(n))   
ו. O(n^3)   ","זמן הריצה הכולל הוא  T(n)=2T(n/2) +n3/2, ולפי שיטת האב, למשל, מקבלים את ד'.
",,,,
C,TRUE,2006,b,b,5,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,"\begin{quote}
Given \( n \) numbers. We want to build a data structure from them. Which of the following structures will have the longest worst-case build time?
\begin{enumerate}
    \item A hash table where collisions are resolved using linked lists.
    \item Perfect Hash
    \item Max Heap
    \item AVL Search Tree
    \item 1 + 3
    \item 1 + 2 + 3
\end{enumerate}
\end{quote}",B,"b.
Balanced search tree requires a build time of $O(n\log n)$.
Data structures A and C require a build time of $O(n)$.
However, Perfect Hash may require unbounded time: each time, we randomly choose a hash function and test it, and may fail an unlimited number of times. Therefore, the worst-case build time is unbounded.",6,"e,f,g,h",tested,1,"נתונים n מספרים. רוצים לבנות מהם מבנה נתונים. איזה מהמבנים הבאים זמן הבניה
worst-case יהיה הארוך ביותר? 
א. טבלת Hash שבה פתרון התנגשויות על ידי רשימות מקושרות.
ב. Perfect Hash
ג. ערימת מקסימום.
ד. עץ חיפוש AVL.
ה. א+ג
ו. א+ב+ג","ב'. 
עץ חיפוש מאוזן דורש זמן בניה של O(nlogn).
מבנים א' ו-ג' דורשים זמן בנייה של O(n).
אבל Perfect Hash עלול לדרוש זמן בלתי מוגבל: כל פעם מגרילים פונקציית Hash ומנסים אותה, ועלולים להיכשל מספר בלתי מוגבל של פעמים. לכן זמן הבנייה  worst-case אינו חסום.",,,,
A,TRUE,2006,b,b,6,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,9,na,na,na,na,na,na,1,"תאר מימוש לפעולה DeleteMin בערימה (Heap) הממומשת כמו שתיארנו בכתה שמבצע  O(log(n)^0.5) השוואות במקרה הגרוע ביותר, או הוכח כי אין מימוש כזה.","אין מימוש כזה. אחרת היה אפשר למיין n איברים במודל ההשוואות בזמן o(nlogn) בניגוד למה שהוכחנו בכיתה. זאת על ידי בניית ערימה בזמן לינארי (כפי שלמדנו) ואז קריאה ל-DeleteMin n פעמים, והדפסת האיבר המתקבל בכל פעם. ",,,,
A,TRUE,2006,b,b,7.a,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,12,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (כל קטע נתון על ידי נקודות התחלה וסיום). לשם פשטות, נניח שכל 2n הנקודות שונות זו מזו.
קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו אלגוריתם שמחזיר את מספר הקטעים המרכזיים, בזמן ריצה worst-case הטוב ביותר שתוכלו.","אלגוריתם: זמן ריצה O(n).
מצא את האיבר ה-n/4 בגודלו מבין נקודות ההתחלה, נקרא לו a.
מצא את האיבר ה-n/43 בגודלו מבין נקודות הסיום, נקרא לו b.
סרוק את הקטעים בזה אחר זה וספור כמה מתחילים אחרי a ומסתיימים לפני b.
ניתוח זמן ריצה: מציאת האיבר ה-i בגודלו הוא O(n) בעזרת Select. הסריקה לוקחת O(n) כי כל בדיקה לוקחת שתי השוואות, כלומר  O(1).
",,,,
A,TRUE,2006,b,b,7.b,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,11,na,na,na,na,na,na,1,"נתונים n קטעים על הישר (כל קטע נתון על ידי נקודות התחלה וסיום). לשם פשטות, נניח שכל 2n הנקודות שונות זו מזו.
קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו מבנה נתונים דינמי, המאפשר Insert ו-Delete של קטעים על הישר בזמן O(log n) במקרה הגרוע וכן תומך בפעולה IsCentric(p) שמקבלת מצביע לקטע במבנה, ועונה האם הקטע הוא מרכזי, בזמן O(1) במקרה הגרוע.","תאור המבנה: 
עץ מאוזן שמכיל את כל נקודות ההתחלה, ומשמש גם למציאת order-statistic כפי שנלמד בכיתה, ע"" שמירת כמות הצאצאים של כל צומת. 
עץ נוסף כזה המכיל את נקודות הסיום. 
בעץ של נקודות ההתחלה יהיה מצביע p1 לצומת המייצג את האיבר ה-n/4 בגודלו
בעץ של נקודות הסיום יהיה מצביע p2 לצומת המייצג את האיבר ה-3n/4 בגודלו מימוש פעולת Insert וניתוח זמן ריצה:
מכניסים את נקודת ההתחלה של הקטע לעץ הראשון, ומעדכנים את כמות הצאצאים בכל צומת כפי שלמדנו בכיתה.
בנוסף, מחפשים את האיבר ה-n/4 בגודלו בעץ ומעדכנים את המצביע p1.
כנ""ל עבור נקודת הסיום והעץ השני, עם מצביע p2.
ההכנסה לעץ os לוקחת O(logn) כפי שנלמד בכיתה, ואותו זמן לוקח למצוא את האיבר המתאים.
סה""כ: 2*2*O(logn)=O(logn) זמן ריצה.
מימוש פעולת Delete וניתוח זמן ריצה: בדומה ל- Insert, מוחקים את ערך נקודת ההתחלה מהעץ הראשון, ומעדכנים את p1. באופן דומה עבור העץ השני.
מימוש פעולת IsCentric וניתוח זמן ריצה: 
בודקים אם ערך נקודת ההתחלה של הקטע הנתון גדול מ-p1 וקטן מ-p2. זמן: O(1), כי בסה""כ מבצעים 2 השוואות.
",,,,
A,TRUE,2006,b,b,8.a,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,12,na,na,na,na,na,na,1,"נממש מבנה נתונים המייצג אוסף של קבוצות זרות ותומך בפעולות הבאות:

Makeset(x): בהינתן איבר x בונה ומחזיר קבוצה המכילה רק את האיבר x.
Union(s1,s2): בהינתן שתי קבוצות s1 ו-s2 מחזיר קבוצה s שהיא איחוד של s1 ו-s2. הקבוצות s1 ו-s2 אינן קיימות לאחר ביצוע הפעולה.
Find(z): בהינתן מצביע לצומת המייצג איבר z, מחזיר את הקבוצה בה נמצא z. (שים לב – מניחים שמתקבל מצביע ישירות לצומת המייצג את z)

מייצגים כל קבוצה על-ידי עץ. בכל צומת בעץ נמצא איבר ונמצא מצביע לאביו בעץ. בשורש העץ מאוכסן גם גודל הקבוצה. שורש העץ משמש כ""מייצג"" של הקבוצה. לדוגמה: העץ

מייצג את הקבוצה {x,y,z,w,u} שגודלה 5.

מימוש Makeset מקצה צומת חדש שמהווה עץ חדש. בשורש נאחסן את האיבר x, ואת הגודל שהוא 1.
מימוש Union(s1,s2) יתבצע על-ידי הפיכת השורש של הקבוצה הקטנה יותר לבן של השורש של הקבוצה הגדולה יותר. כמו כן נשנה את הגודל של השורש בקבוצה הגדולה יותר להיות סכום גדלי שתי הקבוצות.
מימוש find(z) יתבצע על-ידי כך שנתקדם מהצומת z על-פי מצביעי האב עד לשורש ונחזיר את השורש.  מהו החסם על סיבוכיות הזמן במקרה הגרוע של כל פעולה. הוכח תשובתך.","( O(n2
בסיום כל שלב ברקורסיה ה-Pivot נמצא במקום הנכון, ולכן יהיו לכל היותר n קריאות רקורסיביות, שכל אחת תיקח זמן O(n). כלומר אין מקרה שבו נדרשים יותר מ-O(n2)  השוואות.
זהו חסם הדוק משום שעלה בעומק הזה הוא, למשל, העלה המתאים למערך ממוין או מערך ממוין ההפוך. Makeset ו-Union ייקחו O(1) כי המימוש שלהם לא תלוי בכמות האיברים בקבוצה.
Find ייקח O(log n), כאשר n הוא מספר הפעמים שנקראה הפעולה Makeset.
הוכחה: זמן הפעולה של Find(x) הוא עומקו של הצומת המייצג את-x. בכל פעם שעודכן השורש של העץ אליו שייך x  - גודל הקבוצה (העץ החדש) שאליה הוא שייך גדלה לפחות פי 2. מכאן, שאם השורש של x עודכן O(logn) פעמים יש לפחות O(n) איברים בקבוצה. במילים אחרות: בקבוצה בת n איברים עומק של עלה בעץ לא יכול להיות יותר מ-O(logn).
ראי גם קורמן כרך ב' עמ' 61 להסבר דומה שלמדנו בכיתה עבור רשימות מקושרות.
",,,,
A,TRUE,2006,b,b,8.b,https://docs.google.com/document/d/1KYPVPcemr20Z7bG9QDBCTCrVsMuMWnyH,TAU,11,na,na,na,na,na,na,1,"נממש מבנה נתונים המייצג אוסף של קבוצות זרות ותומך בפעולות הבאות:

Makeset(x): בהינתן איבר x בונה ומחזיר קבוצה המכילה רק את האיבר x.
Union(s1,s2): בהינתן שתי קבוצות s1 ו-s2 מחזיר קבוצה s שהיא איחוד של s1 ו-s2. הקבוצות s1 ו-s2 אינן קיימות לאחר ביצוע הפעולה.
Find(z): בהינתן מצביע לצומת המייצג איבר z, מחזיר את הקבוצה בה נמצא z. (שים לב – מניחים שמתקבל מצביע ישירות לצומת המייצג את z)

מייצגים כל קבוצה על-ידי עץ. בכל צומת בעץ נמצא איבר ונמצא מצביע לאביו בעץ. בשורש העץ מאוכסן גם גודל הקבוצה. שורש העץ משמש כ""מייצג"" של הקבוצה. לדוגמה: העץ

מייצג את הקבוצה {x,y,z,w,u} שגודלה 5.

מימוש Makeset מקצה צומת חדש שמהווה עץ חדש. בשורש נאחסן את האיבר x, ואת הגודל שהוא 1.
מימוש Union(s1,s2) יתבצע על-ידי הפיכת השורש של הקבוצה הקטנה יותר לבן של השורש של הקבוצה הגדולה יותר. כמו כן נשנה את הגודל של השורש בקבוצה הגדולה יותר להיות סכום גדלי שתי הקבוצות.
מימוש find(z) יתבצע על-ידי כך שנתקדם מהצומת z על-פי מצביעי האב עד לשורש ונחזיר את השורש. מוסיפים גם את הפעולה Delete(z) שמוחקת את האיבר המאוחסן בצומת אליו מצביע z. (שוב – כמו ב-Find, מקבלים מצביע ישירות ל-z).  כדי לתמוך בפעולה זו נרשה צמתים שבהם נמצאים איברים המסומנים כמחוקים (deleted). בשורש של קבוצה נרשום גם את מספר האיברים המחוקים בעץ. כמו-כן, בסעיף זה כל צומת יחזיק רשימת מצביעים לבניו בנוסף למצביע לאביו. (במימוש שתואר בסעיף הקודם לא היו מצביעים לבנים, רק לאב).

המימוש של Delete(z) מסמן את האיבר בצומת z כמחוק, ואחר-כך עוקבים אחר מצביעי-האב עד לשורש ומגדילים את מספר האיברים המחוקים בקבוצה ב-1. אם מספר האיברים המחוקים גדול מחצי מספר אברי הקבוצה, סורקים את כל העץ המייצג את הקבוצה, ומשחררים כל צומת המחזיק איבר מחוק. מבין האיברים שאינם מחוקים, בוחרים אחד שיהיה השורש, ואת כל שאר האיברים הלא-מחוקים הופכים להיות בנים שלו. 
לדוגמה, אם הקבוצה s={z,u,a,b} מיוצגת ע""י המבנה בצורה הבאה:

ומבצעים Delete(u) אזי העץ שמייצג את הקבוצה לאחר ביצוע הפעולה יהיה:

בהנחה ש-a נבחר להיות השורש.

כמה זמן לוקח לבצע סדרה של m פעולות, כאשר מספר האלמנטים בכל רגע לא עולה על n, וכאשר מס' הפעולות שהן Find או Delete הוא k? (שאר m-k הפעולות הן Makeset או Union). הוכח את תשובתך.","קל לראות שאם לא מתבצעים בכלל delete-ים, אז העלות הכוללת היא O(m+klogn). נבצע Amortized Analysis ונוכיח שגם אם כן מתבצעים delete-ים, העלות נשארת אותו דבר. נשתמש בשיטת הבנק. כל delete יפקיד שני מטבעות. delete  יקר, כזה שבונה מחדש את העץ, ימשוך מס' מטבעות כגודל העץ. נניח שעשינו delete יקר על עץ בגודל x, שבו x/2 מהצמתים מסוןמנים כמחוקים. אז הפעולות שגרמו להם להיות מחוקים הפקידו 2*x/2=x מטבעות, ולכן אף פעם לא נהיה באוברדרפט.

בסה""כ קיבלמו שהמחיר הכולל הוא  O(m+klogn).",,,,
C,TRUE,2007,a,a,1,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,na,C,na,5,a,na,1," יהיו f(n) = (n^0.5)^(n^0.5), 
g(n) = (n^0.5)!.
נרצה להשוות את ה-log  של שתי הפונקציות.  מה מהבאים נכון?

א. log(f(n)) = o(log(g(n)))
ב. log(f(n)) = w(log(g(n))) 
ג. log(f(n)) = θ(log(g(n)))
ד. אף אחד מהנ""ל.",ג.  EMBED Equation.DSMT4       EMBED Equation.DSMT4       EMBED Equation.DSMT4,,,,
C,TRUE,2007,a,a,2,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,na,C,na,6,a,na,1,"פתרו את נוסחת הנסיגה הבאה:
T(n) = (T(n/2)^2)*(2^n), T(1) = 2
T(n) = ?
א. 2^θ((log(n))
ב. 2^θ((n))
ג. 2^θ((nlog(n))
ד. 2^θ((n^2))
ה. θ(2^(n!))
ו. אף אחד מהנ""ל.","ג.אפשר להפעיל lg על שני הצדדים, להציב S(n) = lg (T(n) , ולקבל נוסחת נסיגה כמו של MergeSort.אפשר גם לפתח בשיטת האיטרציה, ואז המעריך מתנהג כמו הסכום המצטבר בפיתוח של MergeSort.ואפשר בעוד שיטות.",,,,
C,TRUE,2007,a,a,3,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,"\text{Given a max-heap of size } n. \text{ The keys of } $\frac{n}{4}$  of the leaves in the heap have been changed, so now the heap may no longer be valid. We want to make the heap valid with minimal worst-case running time. Assume there is access to the elements of the heap (i.e., the heap is not a black box). The worst-case running time will be: \\
a. \ $\theta(\log(n))$ \\
b. \ $\theta(\log(n)^2)$ \\
c. \ $\theta(n)$ \\
d. \ $\theta(n\log(n)$) \\
e. \ $\theta(n^3)$ \\
f. \ \text{None of the above.}",C,"
The time required to access each of the nodes in our list is \( O(n) \), therefore a faster solution is not possible. In \( O(n \log n) \) time, it is possible to perform BuildHeap again on all the elements.
",6,"a,h",tested,1,"נתונה ערימת מקסימום בגודל n. שינו את המפתחות של n/4 מהעלים בערימה, כך שעכשיו יתכן שהערימה כבר לא חוקית. נרצה להפוך את הערימה לחוקית בזמן ריצה W.C. מינימלי. הניחו שיש גישה לאברי הערימה (כלומר הערימה לא קופסה שחורה).
זמן הריצה W.C. יהיה:
א. θ(log(n))
ב. θ(log(n)^2) 
ג. θ(n)
ד. θ(nlog(n))
ה. θ(n^3)
ו. אף אחד מהנ""ל.",ג.הזמן שדרוש כדי לגשת לכל אחד מהצמתים ששושנו הוא   EMBED Equation.DSMT4      לכן לא יתכן פתרון מהיר יותר.בזמן   EMBED Equation.DSMT4     אפשר לבצע BuildHeap מחדש על כל האיברים.,,,,
C,TRUE,2007,a,a,4,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,na,A,na,5,p,na,1,"נתון עץ אדום שחור כמו שנלמד בכיתה (דוגמה מצורפת). 
הניחו שהשורש שחור ושלכל צומת  n   מוסיפים שדהsize(n)  הסופר את מספר הצמתים בתת העץ ששורשו בצומת (לא כולל את צמתי ה-nil).  הניחו שהעץ הוא אדום שחור חוקי (אך לא בהכרח נבנה בעזרת פעולות insert  שנלמדו בכיתה).  יהיו L,R   בניו של השורש (הניחו שהם קיימים ואינם nil). הננו מחפשים חסם ל size(R)  כפונקציה של size(L). איזה חסם מהחסמים הבאים הינו החסם ההדוק ביותר על size(R) :
א. 0.1*size(R) <= (size(L) + 1)^2
ב. 0.1*size(R) <= (size(L) + 1)*2
ג. 0.1*size(R) <= size(L)*(2^0.5)
ד. 0.1*size(R) <= 2^size(L)
ה. 0.1*size(R) <= (size(L) + 1)*1.5","א.גובה השחור של L ו-R חייב להיות שווה בכל מסלול מעלה לשורש. לכן, העץ הקטן ביותר האפשרי לגובה שחור מסוים h יהיה עץ ללא צמתים אדומים (וגודלו יהיה 2h). מצד שני, לכל צומת אדום יש אבא שחור. לכן העץ המקסימלי מתקבל על ידי שכבות צמתים אדומות ושחורות לסרוגין. גודלו יהיה לא יותר מ-22h+1 (הגובה 2h+1 כי במקרה של L ו-R גם השורש יכול להיות אדום).",,,,
C,TRUE,2007,a,a,5,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,"
We perform an LDR scan on a binary search tree of size \( n \) (not necessarily balanced), but at each step, instead of printing the key of the current node \( x \), we print the key of its parent. If \( x \) is the root of the tree, we do not print at that step. Which of the following is true?
A. Every key in the tree, except for the keys of the leaves and the root, is printed twice. \\
B. The values that are printed are in monotonically increasing order. \\
C. The number of keys that are printed twice is \( \Theta(n) \) for every tree. \\
D. A + C \\
E. A + B + C \\
F. None of the above.
",F,"
a. False, because any node that has a single child will be printed only once. b. False, for example the tree with root 3, left child 1 and right child of the left child 2. It will print 3 first and then 1. c. False, for example for a tree where each node is either a leaf or has a single child.
",6,e,untested,1,"נבצע סריקת LDR על עץ חיפוש בינרי בגודל n (לא בהכרח מאוזן), אבל בכל שלב, במקום להדפיס את המפתח של הצומת הנכחי x, נדפיס את המפתח של אבא שלו. אם x הוא שורש העץ, לא נבצע הדפסה באותו השלב. מה מהבאים נכון?
א. כל מפתח בעץ, למעט המפתחות של העלים והשורש, יודפס פעמיים.
ב. הערכים שיודפסו, יהיו בסדר מונוטוני עולה.
ג. מספר המפתחות שיודפסו פעמיים הוא θ(n) לכל עץ.
ד. א + ג
ה. א + ב + ג
ו. אף אחד מהנ""ל.","ו.א' לא נכון כי כל צומת שיש לו בן יחיד יודפס רק פעם אחת.ב' לא נכון, למשל העץ עם שורש 3, בן שמאלי 1 ולבן השמאלי בן ימני 2. יודפס קודם 3 ואחר-כך 1.ג' לא נכון, למשל עבור עץ שבו כל צומת הוא עלה או שיש לו בן יחיד.",,,,
C,TRUE,2007,a,a,6,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,"
Given a data structure \( A \) containing \( n \) keys. We want to find a pointer to an element whose key is the median of the keys, in the fastest worst-case time. For this purpose, it is preferable that \( A \) be:

a. A hash table of size \( n \) with collision resolution using 2-3 trees.

b. A doubly linked list sorted in ascending order.

c. An AVL tree with support for order-statistic operations.

d. A hash table of size \( n \) with collision resolution using doubly linked lists, and it is known that the values are the integers from 1 to \( n \).

e. a + d

f. b + c
",C,"The correct answer is c.

a – We need to scan all elements in the trees in the table, hence it will take \(O(n)\).

b – To reach the element in the middle of the list, we need to traverse half of it, so it will take \(O(n/2) = O(n)\).

c – Finding the order statistic \(n/2\) can be done in \(O(n)\).

d – The median is the \(n/2\)-th number. Finding the cell takes \(O(n/2) = O(n)\). Searching in the list takes \(O(n)\). Total \(O(n)\).",6,"e,f,g",untested,1,"נתון מבנה נתונים A המכיל n מפתחות. רוצים למצוא מצביע לאיבר שהמפתח שלו הוא חציון  המפתחות, בזמן W.C. המהיר ביותר. לשם כך עדיף ש-A יהיה:
א. טבלת Hash בגודל n עם פתרון התנגשויות על ידי עצי 2-3.
ב. רשימה דו כיוונית מקושרת ממוינת בסדר עולה.
ג. עץ AVL עם תמיכה בפעולות סדר-סטטיסטי.
ד.  טבלת Hash בגודל n עם פתרון התנגשויות על ידי רשימות מקושרות דו כיווניות, וידוע שהערכים הם המספרים השלמים 1 עד n.
ה.  א + ד
ו. ב + ג","ג.א – צריך לסרוק את כל האיברים שבעצים שבטבלה ולכן יקח   EMBED Equation.DSMT4     .ב- כדי להגיע לאיבר שבאצמצע הרשימה צריך לרוץ על חציה, לכן יקח   EMBED Equation.DSMT4     .ג – מציאת סדר סטטיסטי n/2 ניתנת לביצוע בזמן   EMBED Equation.DSMT4     .ד – החציון הוא המספר n/2. מציאת התא   EMBED Equation.DSMT4     . חיפוש ברשימה   EMBED Equation.DSMT4     . סה""כ   EMBED Equation.DSMT4    ",,,,
C,TRUE,2007,a,a,7,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,7,"\text{What is the lower bound in the comparison model of the worst-case runtime of a sorting algorithm, if it is known that }$ n^{0.5}$ \text{ of the smaller elements are already in the correct place?}
\begin{enumerate}
    \item $\theta(\log(n))$
    \item $\theta(n\log(n))$
    \item $\theta(n)$
    \item $\theta(n^{1.5})$
    \item $\theta(n\sqrt{\log(n)})$
    \item \text{None of the above.}
\end{enumerate}",B,"
b. We still need to sort an array of size \( k \). Sorting an array of size \( k \) under the comparison model takes \( O(k \log k) \). But \( O(k \log k) \)
",6,"a,k",tested,1,"מהו החסם התחתון במודל ההשוואות של זמן ריצה W.C. של אלגוריתם מיון, אם ידוע ש-n^0.5 האיברים הקטנים כבר במקום הנכון?
א. θ(log(n))
ב. θ(nlog(n)) 
ג. θ(n) 
ד. θ(n^1.5)
ה. θ(nlog(n)^0.5)
ו. אף אחד מהנ""ל.",ב.עדיין צריך למיין מערך בגודל   EMBED Equation.DSMT4     . מיון מערך בגודל k בהנחת מודל ההשוואות לוקח   EMBED Equation.DSMT4     . אבל   EMBED Equation.DSMT4,,,,
C,TRUE,2007,a,a,8,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,8,na,B,na,6,"a,m",na,1,"נתון מערך המכיל יצוג של n נקודות במישור (כל נקודה נתונה על ידי זוג (x,y) ). רוצים להכריע האם קיים ישר שעובר דרך ראשית הצירים (דרך (0,0)) כך שלפחות 0.75*n מהנקודות נמצאות על הישר. נרצה אלגוריתם שפותר את הבעיה בזמן W.C. מינימלי. זמן W.C. יהיה:
א. θ(log(n))
ב. θ(n) 
ג. θ(nlog(n))
ד. θ(n^2)
ה. θ(n^2log(n))
ו. אף אחד מהנ""ל."," ב.לכל נקודה נחשב בזמן   EMBED Equation.DSMT4      את השיפוע של הישר המחבר אותה לראשית הצירים.קיבלנו בזמן   EMBED Equation.DSMT4      מערך המכיל את כל השיפועים, ונרצה לדעת האם יש ערך שחוזר   EMBED Equation.DSMT4      פעמים.אם יש כזה הוא חייב להיות החציון. לכן, נפעיל את אלגוריתם Select למציאית החציון בזמן   EMBED Equation.DSMT4     , ונוודא על ידי סריקת המערך שערך זה אכן מופיע   EMBED Equation.DSMT4      פעמים. אם כן – נחזיר ""כן"" אחרת נחזיר ""לא"".סה""כ זמן ריצה   EMBED Equation.DSMT4     . ברור שאי אפשר מהר יותר כי צריך לקרוא את הקלט.",,,,
A,TRUE,2007,a,a,9.a,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,8,na,na,na,na,na,na,1,"נתונה ערימת מינימום, ללא מפתחות כפולים.
לכל צומת x יש שדה נוסף s, שמאותחל ל-nil. רוצים שהשדה s של כל צומת x יכיל מצביע לעוקב  של x. הניחו שיש גישה לאברי הערימה (כלומר הערימה לא קופסה שחורה). אין לשנות את מבנה הערימה. תנו חסם תחתון לזמן ריצה W.C. לפתרון הבעיה הנ""ל במודל ההשוואות.
 ","הוכחה: נראה חסם   EMBED Equation.DSMT4     . נסמן ב-T(n) את זמן הריצה W.C. של האלגוריתם הטוב ביותר לבעיה הנ""ל שפועל בהנחת מודל ההשוואות. נראה איך אפשר לבנות מאלגוריתם כזה אלגוריתם מיון:ניקח מערך בגודל n. נבנה ממנו ערימה בזמן W.C.   EMBED Equation.DSMT4     . נוסיף את המצביעים s בזמן T(n).נמצא את המינימום בזמן   EMBED Equation.DSMT4     .נסרוק את הערימה בעזרת המצביעים - נתחיל מהדפסת המינימום ובכל צעד נעבור לאיבר הבא בעזרת המצביע s ונדפיס אותו.קיבלנו אלגוריתם מיון שרץ בזמן   EMBED Equation.DSMT4     .כל הפעולות שביצענו על המפתחות המקוריים הן פעולות השוואה (גם בתוך האלגוריתם BuildHeap).לכן האלגוריתם מתאים להנחת מודל ההשוואות. לפי החסם שהראינו בכיתה אלגוריתם כזה דורש זמן W.C.   EMBED Equation.DSMT4     .לכן בהכרח   EMBED Equation.DSMT4     טעויות נפוצות: - הוכחת חסם עליון במקום תחתון (כלומר, הצעת אלגוריתם ספציפי שפותר את הבעיה בזמן הנ""ל)התעלמות מזמן בניית הערימה (ההוכחה בכיתה התחילה ממערך של n איברים, ולא ערימה שקיימת בה חוקיות מסוימת)הוכחה שלא יכול להיות שעדכון כל איבר ספציפי ייקח o(logn), כלומר, קיים איבר שעבורו ייקח יותר זמן. מזה לא נובע שאי אפשר לעדכן את כל האיברים בזמן o(nlogn).",,,,
A,TRUE,2007,a,a,9.b,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,10,na,na,na,na,na,na,1,"נתונה ערימת מינימום, ללא מפתחות כפולים.
לכל צומת x יש שדה נוסף s, שמאותחל ל-nil. רוצים שהשדה s של כל צומת x יכיל מצביע לעוקב  של x. הניחו שיש גישה לאברי הערימה (כלומר הערימה לא קופסה שחורה). אין לשנות את מבנה הערימה. הציעו אלגוריתם שמבצע את הנ""ל בזמן כולל W.C. כמה שיותר טוב, אם נתון שהמפתחות הם שלמים בתחום 1 עד 2n  . ","תיאור האלגוריתם:
I. נסרוק את הערימה (למשל DLR) ונעתיק את המפתחות למערך עזר. נזכור לכל מפתח מצביע למקומו המקורי בערימה.
II. נמיין את המערך על ידי שימוש באלגוריתם

 מיון בזמן לינארי, למשל  CountSort
 (או BinSort).
III. נסרוק את המערך משמאל לימין, ולכל איבר ניגש (בעזרת המצביע) לצומת המתאים לו בערימה ונעדכן את השדה s שיכיל את המצביע שבאיבר הבא במערך.",,,,
A,TRUE,2007,a,a,10,https://docs.google.com/document/d/15av3BYO1sip8j7xbHE3cwGQOEe2WyO9U,TAU,10,na,na,na,na,na,na,1,"נתון עץ 2-3 שבו בכל צומת מצוי שדהsize(x)  שמכיל את מספר הצמתים בתת העץ ששורשו בצומת x. מעוניינים להדפיס את k השדותsize  הגדולים ביותר במבנה.  מובטח ש: EMBED Equation.DSMT4  .
שימו לב: יתכן מצב שבין k הצמתים שיודפסו, לא יהיה הבן הימני של השורש.
הציעו אלגוריתם עם זמן ריצה W.C. הטוב ביותר שתוכלו .","תיאור האלגוריתם:
בדומה לאלגוריתם עבור הדפסת k האיברים הגדולים בערימת מקסימום.
נשים לב שהשדה Size של צומת תמיד גדול מהשדה Size של בניו. לכן השדה Size של צומת יודפס רק אחרי שיודפס השדה Size של אביו. 
נחזיק ערימת עזר A (ערימת מקסימום) שתכיל את המועמדים להדפסה. בכל שלב נוציא מ-A  את המקסימלי, נדפיס אותו, ובמקומו נכניס לערימה את השדה Size של שני בניו בעץ המקורי (אם יש לו רק בן אחד אז רק אותו ואם הוא עלה בעץ אז לא נכניס במקומו אף אחד). בנוסף נזכור, לכל ערך שהכנסנו ל-A, מצביע למיקומו בעץ.
נעצור אחרי שהדפסנו k ערכים, כאשר מתחילים עם הכנסת שורש העץ ל-A.",,,,
b,TRUE,2007,b,c,1-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,Either k+1 is the minimum son in x's right sub-stree or x is the maximum son in k+1's left sub tree,na,e,na,,,,1,0,2007_bc_1a,total points 20
b,TRUE,2007,b,c,1-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,Linear time,na,"a,h",na,,,,1,0,2007_bc_1b,total points 20
b,TRUE,2007,b,c,1-c,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"O(logn), the depth is logarithmic so surely each path is logarithmic in the worst case.",na,f,na,,,,1,0,2007_bc_1c,total points 20
b,TRUE,2007,b,c,1-d,T2/ds07b_moed_c_solution.doc,TAU,na,"Given a node \( v \) in a red-black tree. \( P_1 \) and \( P_2 \) are the lengths of the shortest path and longest path from \( v \) to a leaf, respectively. Provide a lower bound on the ratio between \( P_1 \) and \( P_2 \). Justify your answer.",na,\textit{Maximum twice the length because there is the same black length and no two consecutive reds},na,f,untested,,,,0,1,2007_bc_1d,total points 20
b,FALSE,2007,b,c,1-e,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,n,na,,,,0,0,2007_bc_1e,total points 20
b,TRUE,2007,b,c,1-f,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"number of nodes = Ω(phi^k)
k = O(logn)",na,i,na,,,,1,0,2007_bc_1f,total points 20
a,TRUE,2007,b,c,2-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2007_bc_2a,total points 16
a,TRUE,2007,b,c,2-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2007_bc_2b,total points 16
a,FALSE,2007,b,c,3-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,o,na,,,,0,0,2007_bc_3a,total points 16
a,TRUE,2007,b,c,3-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"1.	Every string that ends in an inner node is not unique
2.	Every string that includes the first letter of an leaf edge is unique
3.	So the algorithm is:
a.	Build a suffix tree
b.	Search for the lowest common ancestor of two leafs with the lowest label
c.	Extend the string by one letter  from the leaf edge",na,o,na,,,,1,0,2007_bc_3b,total points 16
a,FALSE,2007,b,c,3-c,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,p,na,,,,0,0,2007_bc_3c,total points 16
a,TRUE,2007,b,c,4-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"| Index | Linear Probing | Double Hashing |
| 0     | 11             | 11             |
| 1     | 22             | 22             |
| 2     | 33             | 22             |
| 3     | 3              | 3              |
| 4     | 18             | 18             |
| 5     |                |                |
| 6     | 33             | 33             |
| 7     | 7              | 7              |
| 8     | 18             | 18             |
| 9     |                |                |
| 10    |                |                |",na,g,na,,,,1,0,2007_bc_4a,total points 16
a,TRUE,2007,b,c,4-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"We'll get instances where the jump may be 0, therefore won't be able to insert items  into the table, even though there is still room",na,g,na,,,,1,0,2007_bc_4b,total points 16
a,TRUE,2007,b,c,4-c,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"When the GCD is 1, we can prove that when there's a collision in the hash table, a series of m-1 jumps will visit all the indexes in the hash table. So if there's at least one empty place in the table we will find it in O(m) time and the insertion will succeed.",na,g,na,,,,1,0,2007_bc_4c,total points 16
a,TRUE,2007,b,c,5-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"We need to find k-1 order-statistics. For example if k=2 we need to find the median, if k=4 we need to find the n/4, n/2, 3n/4 order statistics. In any case finding any order statistic is O(n) so O(kn) to find the order statistics and arrange the groups by them",na,m,na,,,,1,0,2007_bc_5a,total points 18
a,TRUE,2007,b,c,5-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"We can find the median x in O(n), then we can create a new array where each value v from the original array is turned into -> |v-x|, all we need to find now is the k order-statistic and pivot the array on it, so that every cell which is smaller than that must be one of the numbers we were looking for",na,m,na,,,,1,0,2007_bc_5b,total points 18
a,TRUE,2007,b,c,5-c,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,"Each interval is given as [a,b], we sort all the values together, 2n numbers total, but remember which one was beginning of an interval and which one the end. We then go linearly over the sorted numbers and count our ""depth"", i.e. how many beginning numbers we've seen so far minus closing numbers. When the number reaches 0 we add the length of this section and continue…",na,p,na,,,,1,0,2007_bc_5c,total points 18
b,TRUE,2007,b,c,6-a,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,O(nlogn),na,n,na,,,,1,0,2007_bc_6a,total points 14
a,FALSE,2007,b,c,6-b,T2/ds07b_moed_c_solution.doc,TAU,na,na,na,na,na,n,na,,,,0,0,2007_bc_6b,total points 14
c,FALSE,2009,b,b,1,T2/ds09b-b.doc,TAU,9,"This question deals with implementing a stack using extendable arrays (doubling the array when all cells are full - a method called doubling). To reduce the number of doubling operations, we suggest replacing doubling with quadrupling – that is, each time the array is full, a new array is allocated that is 4 times its size (instead of 2 times). The complexity of performing m PUSH operations in the worst case is:   
1. \(\Theta(m^2)\)  
2. \(\Theta(m)\)  
3. \(\Theta(m \log m)\)  
4. \(\Theta(m^4)\)  
5. None of the answers are correct  ",na,na,5,"a,d",tested,,,,0,1,2009_bb_1,na
c,FALSE,2009,b,b,2,T2/ds09b-b.doc,TAU,9,"For an input of size \( n \), three algorithms run in times \( T_1, T_2, T_3 \) such that:

\[
T_3 = \Theta(n^{0.999}), \quad T_2 = \Theta(n^{1.8\lg n}), \quad T_1 = \Theta\left(\frac{n}{\lg n}\right)
\]

This is the hierarchy of magnitude in (asymptotic) size correction such that:

1. \( T_1 > T_2 > T_3 \)  
2. \( T_1 > T_3 > T_2 \)  
3. \( T_2 > T_1 > T_3 \)  
4. \( T_2 > T_3 > T_1 \)  
5. \( T_3 > T_1 > T_2 \)  
6. \( T_3 > T_2 > T_1 \)",na,na,6,a,untested,,,,0,1,2009_bb_2,na
c,FALSE,2009,b,b,3,T2/ds09b-b.doc,TAU,7,"Given \( T(n) = 2T(n/2) + n^2 \). Then:

1. \( T(n) = \Theta(n^2) \)  
2. \( T(n) = \Theta(n \log n) \)  
3. \( T(n) = \Theta(n^2 \log n) \)  
4. \( T(n) = \Theta(n^3) \)",na,na,4,a,tested,,,,0,1,2009_bb_3,na
c,FALSE,2009,b,b,4,T2/ds09b-b.doc,TAU,7,na,na,na,5,f,na,,,,0,0,2009_bb_4,na
c,FALSE,2009,b,b,5,T2/ds09b-b.doc,TAU,7,"A series of operations is performed on a Fibonacci heap, during which ccc cuts were required (note that in each cascading cut, one or more cuts can occur). It is known that ddd of the operations were decrease-key operations, and no delete or delete-min operations were performed. What is the tightest bound on ccc (the most accurate answer)?

\begin{enumerate}
    \item[(a)] \( c = d \)
    \item[(b)] \( c \leq 2d \)
    \item[(c)] \( c \leq d \)
    \item[(d)] \( d \leq c \leq 2d \)
    \item[(e)] None of the above answers is necessary
\end{enumerate}",na,na,5,i,untested,,,,0,1,2009_bb_5,na
a,FALSE,2009,b,b,6-a,T2/ds09b-b.doc,TAU,7,na,na,na,na,g,na,,,,0,0,2009_bb_6a,na
c,FALSE,2009,b,b,6-b,T2/ds09b-b.doc,TAU,5,na,na,na,4,g,na,,,,0,0,2009_bb_6b,na
a,FALSE,2009,b,b,7-a,T2/ds09b-b.doc,TAU,na,na,na,na,na,m,na,,,,0,0,2009_bb_7a,total points 20
a,FALSE,2009,b,b,7-b,T2/ds09b-b.doc,TAU,na,na,na,na,na,l,na,,,,0,0,2009_bb_7b,total points 20
a,FALSE,2009,b,b,7-c,T2/ds09b-b.doc,TAU,na,na,na,na,na,k,na,,,,0,0,2009_bb_7c,total points 20
b,FALSE,2009,b,b,8-a,T2/ds09b-b.doc,TAU,4,na,na,na,na,"p,b",na,,,,0,0,2009_bb_8a,na
c,FALSE,2009,b,b,8-b,T2/ds09b-b.doc,TAU,8,"What is the overall time complexity, in the worst case, of executing a series of operations that includes n₁ op1 operations, n₂ op2 operations, and some number of undo operations? Choose one of the answers and justify the correctness of your choice.

\begin{enumerate}
    \item \(O(n_1 f_1 + n_2 f_2)\) but not necessarily \(O(n_1 g_1 + n_2 g_2)\)
    \item \(O(n_1 g_1 + n_2 g_2)\)
    \item \(\Theta(n_1 f_1 + n_2 f_2)\)
    \item \(\Theta(n_1 g_1 + n_2 g_2)\)
\end{enumerate}

Choose one of the answers. Justify the correctness of your answer.",na,na,4,"p,b",tested,,,,0,1,2009_bb_8b,na
a,FALSE,2009,b,b,8-c,T2/ds09b-b.doc,TAU,8,na,na,na,na,"p,b",na,,,,0,0,2009_bb_8c,na
c,FALSE,2009,b,b,9-a,T2/ds09b-b.doc,TAU,7,"A new method is proposed for inserting items into a hash table without linked lists.
To insert a key \( k \) into a table \( T \), using a hash function called \( h \), perform:

\[
i = h(k) ; \quad  j = i
\]
\[
\text{while } T[j] \text{ is not empty do}
\]
\[
\quad j = j + 1
\]
\[
T[j] = T[i] ; \quad T[i] = k
\]

The operation \( j+1 \) is performed modulo \( N \) (i.e., circularly), where \( N \) is the size of the table. Assume that the search operation is performed as defined in class as linear rehashing (i.e., if an element is not found in location \( i \), we search for it in location \( i+1, i+2, \ldots \), until we reach an empty location) and that there are no deletions from the table. Also assume that when inserting an item, the table is not full (there is at least one empty cell in the table).

Is this a correct implementation of a data structure that supports search and insertion operations?
Prove that it is, or provide an example where the data structure does not operate as required.",na,na,2,g,tested,,,,0,1,2009_bb_9a,na
c,FALSE,2009,b,b,9-b,T2/ds09b-b.doc,TAU,7,"\textit{A new method is proposed for deleting items from a hash table without linked lists.  
To delete the item located in the i-th cell of the table, perform:}

\begin{verbatim}
j = i 
while T[j] is not empty do 
  j = j + 1 
T[i] = T[j-1]; T[j-1] = nil
\end{verbatim}

\textit{The operation \(j+1\) is performed modulo \(N\), where \(N\) is the size of the table.  
Assume that the search and insertion operations from the table are performed in the original way.  
Also assume that the table is not full (there is at least one cell in the table that contains nil).  
Will the hash table work correctly with the new deletion method?  
Prove that it does, or provide an example where the data structure does not function correctly.}",na,na,2,g,untested,,,,0,1,2009_bb_9b,na
c,TRUE,2009,b,a,1,T2/ds2009ba-sol.doc,TAU,9,na,b,"B.
when constructing the Huffman code from these frequencies, we first join C and T into one tree of weight 0.2, we then join this tree with G resulting in a tree of weight 0.5, and then we join this tree with A. The resulting Huffman code is: A - 0, G - 10, C - 1110, T - 1111. If we randomly pick a string of letters of length N from the given distribution, we can denote the length of the i-th letter by the random variable X_i. By linearity of expectation, and since all X_i have the same distribution, the expected total length of the string is E(∑X_i) = ∑E(X_i) = NE(X_1). The expectation of the length of each of the letters is E(X_1) = 0.51 + 0.32 + 0.13 + 0.13 = 0.17, and therefore the expected total length is 1.7N.",4,p,na,,,,1,0,2009_ba_1,na
c,TRUE,2009,b,a,2,T2/ds2009ba-sol.doc,TAU,9,na,f,"Answer: f, answers (1),(3), and (5) are correct.
Explanation: Answers (1) and (3) cost O(N^2) as we have shown in class. Answer (2) costs O(Nlog(N)), as shown in class. Answer (5) costs O(N^2) since the first pivot partitions the data into two ordered arrays each of size N/2, and as we have shown in class an ordered array takes O(N^2) to sort using quicksort.",6,j,na,,,,1,0,2009_ba_2,na
c,TRUE,2009,b,a,3,T2/ds2009ba-sol.doc,TAU,na,na,a,Answer: T(N) = T(0.25N)+T(0.75N)+O(N) since we call the recursion with these two sizes and then we run a linear algorithm for the merge,4,j,na,,,,1,0,2009_ba_3,total points q3+4 9
c,TRUE,2009,b,a,4,T2/ds2009ba-sol.doc,TAU,na,na,b,"Answer: O(N log N)
Explanation: This can be shown by induction using the recursion formula: T(N) = T(0.25N)+T(0.75N)+O(N)",4,a,na,,,,1,0,2009_ba_4,total points q3+4 10
c,TRUE,2009,b,a,5,T2/ds2009ba-sol.doc,TAU,9,"We will discuss the implementation of a red-black tree where all the leaves are black (in the CORMEN implementation as taught in class, there is a layer of NILs that serves as the 'leaf layer' and is entirely black). What is the minimum ratio of black nodes to red nodes in a valid red-black tree?

\begin{itemize}
    \item[(A)] 1 black to 1 red.
    \item[(B)] 2 blacks to 1 red.
    \item[(C)] 5 blacks to 2 reds.
    \item[(D)] 1 black to 2 reds.
    \item[(E)] The ratio can be as small as we want.
\end{itemize}
",b,"\text{2 blacks for 1 red. Each red node in the tree has two children, both black thanks to the NIL layer.}",5,f,tested,,,,0,1,2009_ba_5,na
c,TRUE,2009,b,a,6,T2/ds2009ba-sol.doc,TAU,na,na,d,na,4,n,na,,,,0,0,2009_ba_6,total points q6+7 9
c,TRUE,2009,b,a,7,T2/ds2009ba-sol.doc,TAU,na,na,d,na,4,n,na,,,,0,0,2009_ba_7,total points q6+7 9
c,TRUE,2009,b,a,8,T2/ds2009ba-sol.doc,TAU,9,"\textbf{In an open hash table (chaining), we replace the linked lists of elements in each bucket with closed hash tables. The worst-case runtime for an operation on the hash table, where \( N \) is the number of elements and \( B \) is the number of buckets, is:}

\begin{enumerate}
    \item \( O(1) \)
    \item \( O(\log N) \)
    \item \( O(N) \)
    \item \( O(N \log N) \)
    \item \( O(B/N) \)
\end{enumerate}

\textbf{Brief justification:}",c,"\textit{O(N), in the worst case the elements will collide in two hash tables.}",5,g,untested,,,,0,1,2009_ba_8,na
c,TRUE,2009,b,a,9,T2/ds2009ba-sol.doc,TAU,9,"\text{Given an algorithm that receives an array of size } n \text{ of different unsorted numbers, along with an integer } k \text{ between } 1 \text{ and } n\text{. The algorithm prints the } k \text{ smallest numbers in the array in ascending order. A lower bound on the worst-case runtime of the algorithm (valid for any } k \leq n\text{) is:}
\text{a. } \Omega(n)
\text{b. } \Omega(k \log n)
\text{c. } \Omega(n \log k)
\text{d. } \Omega(n \log n)
\text{e. Answers a and b are correct}

\text{Reason:} ",e,"\text{The answer of the Lord is correct.} \\
\text{A is correct because it is clear that the algorithm must read the entire input in time } \Omega(n), \text{ because there is no way to know whether a number needs to be printed or not without reading it.} \\
\text{B is correct: by contradiction, suppose there exists an algorithm } A \text{ that solves the problem in time } o(k \log n) \text{ for some value of } k. \text{ According to A, it must be } k=\Omega(n/\log n), \text{ otherwise the algorithm } A \text{ does not read the entire input. We proved in class that sorting } k \text{ elements takes } \Omega(k \log k)=\Omega(k \log(n/\log n))=\Omega(k \log n) \text{ time, contradicting the assumption.} \\
\text{C is not correct: it is possible to find the } k\text{-th largest element using Select in time } O(n), \text{ extract the } k-1 \text{ smaller elements in time } O(n), \text{ and then sort the } k \text{ elements in time } O(k\log k). \text{ Total time is } O(n+k\log k). \text{ For, say, } k=n/\log n \text{ the running time is thus } o(n\log n) \text{ i.e., } O(n). \\
\text{D is not correct for the same reason that C is not correct.}",5,k,tested,,,,0,1,2009_ba_9,na
b,TRUE,2009,b,a,10,T2/ds2009ba-sol.doc,TAU,9,na,na,na,na,m,na,,,,0,0,2009_ba_10,na
a,TRUE,2009,b,a,11-a,T2/ds2009ba-sol.doc,TAU,na,na,na,na,na,"h,i",na,,,,0,0,2009_ba_11a,total points 14
a,TRUE,2009,b,a,11-b,T2/ds2009ba-sol.doc,TAU,na,na,na,na,na,"h,i",na,,,,0,0,2009_ba_11b,total points 14
b,TRUE,2009,b,a,12-a,T2/ds2009ba-sol.doc,TAU,na,"\text{Given an array } A[1..n] \text{ containing } n \text{ elements, all different from each other. A pair of indices } (i, j) \text{ is called an inversion if } i < j \text{ and } A[i] > A[j].

\text{Assume that the set of numbers is } \{1, 2, \ldots, n\}. \text{ Which array contains the highest number of inversions? How many inversions does it contain?}",na,"\textit{In a reversely sorted array, each such pair is an inversion. The number of such pairs is } $\theta(n^2)$.",na,d,tested,,,,0,1,2009_ba_12a,total points 14
b,TRUE,2009,b,a,12-b,T2/ds2009ba-sol.doc,TAU,na,"Suppose that \( A[6] \) contains the smallest element in the array (\( A[6]=1 \) in the example above), and \( A[4] \) contains the second largest element (\( A[4]=2 \) in the example above). How many inversions \( (i,j) \) exist such that \( j=4 \) or \( j=6 \)?",na,3+5=8,na,d,untested,,,,0,1,2009_ba_12b,total points 14
a,TRUE,2009,b,a,12-c,T2/ds2009ba-sol.doc,TAU,na,na,na,na,na,"d,p",na,,,,0,0,2009_ba_12c,total points 14
b,FALSE,2010,b,b,1-a,T2/ds10bb.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2010_bb_1a,total points 25
b,FALSE,2010,b,b,1-b,T2/ds10bb.doc,TAU,na,na,na,na,na,"f,b",na,,,,0,0,2010_bb_1b,total points 25
a,FALSE,2010,b,b,2-a,T2/ds10bb.doc,TAU,na,na,na,na,na,"h,i,d",na,,,,0,0,2010_bb_2a,total points 25
a,FALSE,2010,b,b,2-b,T2/ds10bb.doc,TAU,na,na,na,na,na,"f,d",na,,,,0,0,2010_bb_2b,total points 25
a,FALSE,2010,b,b,2-c,T2/ds10bb.doc,TAU,na,na,na,na,na,"k,b,d",na,,,,0,0,2010_bb_2c,total points 25
a,TRUE,2010,b,b,2-d,T2/ds10bb.doc,TAU,na,na,na,na,na,"d,b",na,,,,0,0,2010_bb_2d,total points 25
a,FALSE,2010,b,b,5-a,T2/ds10bb.doc,TAU,na,na,na,na,na,d,na,,,,0,0,2010_bb_5a,total points 25
a,FALSE,2010,b,b,5-b,T2/ds10bb.doc,TAU,na,na,na,na,na,p,na,,,,0,0,2010_bb_5b,total points 25
a,FALSE,2010,b,b,5-c,T2/ds10bb.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2010_bb_5c,total points 25
a,FALSE,2010,b,b,5-d,T2/ds10bb.doc,TAU,na,na,na,na,na,p,na,,,,0,0,2010_bb_5d,total points 25
b,FALSE,2010,b,b,7-a,T2/ds10bb.doc,TAU,na,"Nine elements were inserted into a hash table of size 10 using linear probing with the following hash function: h(x) = x mod 10.

| Index |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
|-------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| Value | 39  | 18  | 54  | 13  | 35  | 24  | 33  |     | 91  | 14  |

Find an insertion order that would result in this table, where the element 13 is inserted as early as possible.",na,na,na,g,tested,,,,0,1,2010_bb_7a,total points 25
b,FALSE,2010,b,b,7-b,T2/ds10bb.doc,TAU,na,"Find an insertion order that will create this table where the element 13 is inserted as late as possible.

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Cell & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
\hline
Element & 39 & 18 & 54 & 13 & 35 & 24 & 33 & & 91 & 14 \\
\hline
\end{tabular}",na,na,na,g,tested,,,,0,1,2010_bb_7b,total points 25
b,FALSE,2010,b,b,7-c,T2/ds10bb.doc,TAU,na,Describe the state of the table after deleting the key 24 using a deletion algorithm that does not use a deleted marker.,na,na,na,g,tested,,,,0,1,2010_bb_7c,total points 25
b,TRUE,2010,b,b,7-d,T2/ds10bb.doc,TAU,na,"The keys \( k_1, k_2, \ldots, k_n \) are inserted in a certain order into a hash table of size \( m \) using linear probing with the hash function \( h(x) \). After the insertion, the \( i \)-th position is empty. Is there a different order of key insertion where the \( i \)-th position in the table would be occupied?

If so, provide an example where such a situation occurs. If not, prove that such a situation is not possible.",na,"\textit{Assume by contradiction that there is an insertion order in which cell $i$ is occupied (in the original it was empty). There is no element mapped directly to cell $i$, otherwise, the cell would have been occupied in the original insertion. This means there is a contiguous segment immediately before position $i$ of length $x$, to which at least $x+1$ elements were mapped (otherwise, there would not have been overflow to position $i$). Those $x+1$ elements were mapped to the same locations in the original insertion, and they are $x$ cells. Each element occupies its own cell, it is impossible to place $x+1$ elements in $x$ cells, and hence the contradiction.}",na,g,untested,,,,0,1,2010_bb_7d,total points 25
b,TRUE,2010,b,a,1,T2/ds10ba.doc,TAU,10,"\textit{We insert into a binomial heap (initially empty) the sequence of numbers 1, 2, \ldots, n in ascending order. For two binomial trees in the heap created, with ranks i, j such that i < j, what is the relation between all the values in the tree of rank i and all the values in the tree of rank j? Explain.}",na,"All the nodes in the tree with rank \( j \) were inserted before all the nodes in the tree with rank \( i \). Therefore, the nodes in the tree with rank \( j \) are smaller than all the nodes in the tree with rank \( i \).",na,i,untested,,,,0,1,2010_ba_1,na
a,TRUE,2010,b,a,2-a,T2/ds10ba.doc,TAU,na,na,na,na,na,l,na,,,,0,0,2010_ba_2a,total points 25
a,TRUE,2010,b,a,2-b,T2/ds10ba.doc,TAU,na,na,na,na,na,k,na,,,,0,0,2010_ba_2b,total points 25
a,TRUE,2010,b,a,2-c,T2/ds10ba.doc,TAU,na,na,na,na,na,"m,c",na,,,,0,0,2010_ba_2c,total points 25
b,TRUE,2010,b,a,2-d,T2/ds10ba.doc,TAU,na,"\documentclass{article}
\usepackage[utf8]{inputenc}
\begin{document}

In this problem, we will sort strings in lexicographic order (dictionary order). A string is a list of characters over a known alphabet. For the sake of simplicity, assume all strings have the same length $t$. A string $s_1$ comes before a string $s_2$ in order if the first character in which they differ is smaller in $s_1$ than in $s_2$. For example, if $s_1=\text{CGTAA}$ and $s_2=\text{CGTCA}$ then $s_1$ comes before $s_2$. Assume that each character in every string can be accessed in constant time. Denote $n$ as the number of strings, and $m$ as the total length of all strings. Note that $m=n \cdot t$. Assume that the strings are given in an array $A$, that is $A[i]$ is a pointer to the $i+1$ string in the array. (Indices in $A$ start from 0.)

The following algorithm, which uses the routines $\text{find-median-char}$ and $\text{partition}$, sorts the strings at locations $k_1,k_1+1,\ldots,k_2$ in array $A$ according to the lexicographic order of the suffixes of these strings starting at position $j$, using comparisons between pairs of characters only. (The suffix of a string consists of the string's characters starting from a certain position $j$ to the end of the string.) To sort all the strings lexicographically, perform $\text{string-sort}(0,n-1,0)$. (The indices of the characters in the strings also start from 0.)

\begin{verbatim}
string-sort(k1,k2,j):
   C \leftarrow \text{find-median-char}(k1,k2,j)
   (p,q) \leftarrow \text{partition}(k1,k2,C,j)
   \text{If} (k1 < p) \text{string-sort}(k1,p-1,j);
   \text{If} (q < k2) \text{string-sort}(q+1,k2,j);
   \text{If} (j < t-1) \text{and} (p < q) \text{string-sort}(p,q,j+1);
\end{verbatim}

The routine $\text{find-median-char}(k1,k2,j)$ returns the median character in the set of characters at position $j$ of the strings at locations $k_1,\ldots,k_2$ in $A$. 

What is the running time of the algorithm as a function of $m$ and $n$, assuming that $\text{find-median-char}(k1,k2,j)$ and $\text{partition}(k1,k2,C,j)$ run in time $O(k_2-k_1)$? Prove your answer.

\end{document}",na,"\begin{quote}
The first two lines require time proportional to the size of the array we are currently dealing with. The first two recursive calls operate on an array whose size is at most half of the original size. The last line advances the letter \( j \) within the strings from \( p \) to \( q \); it is called up to \( t \) times for each string. From an analysis similar to Quicksort, plus \( O(nt) \) work, we get \( O(m+n\log n) \).
\end{quote}",na,"m,c,j",tested,,,,0,1,2010_ba_2d,total points 25
b,TRUE,2010,b,a,3-a,T2/ds10ba.doc,TAU,na,"\textit{A tournament containing \( n \) elements is a perfect binary tree of depth \( i \) where \( i = \lceil \log_2(n) \rceil \) (at distance \( k \) from the root there are exactly \( 2^k \) nodes). The elements are placed at the leaves. In each internal node, we place the smallest of the elements located in the children of that node. A leaf that does not contain a real element contains a dummy element denoted by \( \infty \), which is greater than any real element. We represent the tree using an array like a binary heap, where the children of the node represented by cell \( i \) are represented by the cells \( 2i+1 \) and \( 2i+2 \).

Given \( n \) elements, we construct a tournament containing them as follows. We allocate an array of appropriate size and initialize it entirely with the value \( \infty \). Then we insert the elements one by one. To add an element to the tournament, we place it in the next available leaf from left to right and update, if necessary, the elements located in the ancestors of that leaf.}

\textit{What is the worst-case runtime of this algorithm?}",na,"\text{For each element, we ascend in the worst case up to the root.} \\
\text{Therefore, the running time is } O(n\log n).",na,"a,e",tested,,,,0,1,2010_ba_3a,total points 20
a,TRUE,2010,b,a,3-b,T2/ds10ba.doc,TAU,na,na,na,na,na,"a,e",na,,,,0,0,2010_ba_3b,total points 20
b,TRUE,2010,b,a,3-c,T2/ds10ba.doc,TAU,na,"\[
\text{A tournament containing } n \text{ elements is a perfect binary tree at depth } i \text{ where } i = \lceil \log_2(n) \rceil \text{ (at distance } k \text{ from the root, there are exactly } 2^k \text{ nodes). The elements are placed at the leaves. In each internal node, we place the smallest of the elements located in the children of that node. A leaf that does not contain a real element contains an imaginary element denoted by } \infty \text{, which is larger than any real element.}
\]

\[
\text{We represent the tree with an array like a binary heap, where the children of the node represented by cell } i \text{ are represented by cells } 2i+1 \text{ and } 2i+2.
\]

\[
\text{Given } n \text{ elements, we construct a tournament containing them as follows. We allocate an array of suitable size and initialize it entirely with the value } \infty. \text{ We then insert the elements one by one. To add an element to the tournament, we place it at the next free leaf from left to right and update, if necessary, the elements located at the ancestors of that leaf.}
\]

\[
\text{Now assume that we do not know in advance the number of elements } n \text{ in the tournament, and they are given to us one by one. Since the size of the tournament is not known, we initially allocate an array of size 3 suitable for a tournament with at most 2 elements. If more than 2 elements arrive, we allocate an array of size 7 suitable for a tournament with at most 4 elements, copy the first two elements into it, and continue inserting the subsequent elements. We will continue in this manner; after more than } 2^i \text{ elements arrive, we will have a tournament suitable for at most } 2^{i+1} \text{ elements into which we will insert the next elements. Once more than } 2^{i+1} \text{ elements arrive, we will allocate a tournament double in size, copy the already inserted elements into it, and continue to insert the subsequent elements. Each element's insertion will be performed by the algorithm described above. What is the complexity of each insertion, in the worst-case and amortized?}
\]",na,"\textit{In the worst case, we will need to double the array and adjust its contents accordingly; the running time for this operation will be \(O(n)\). Under amortized analysis, we can charge the running time of doubling the array to the preceding operations that did not involve doubling the array, similar to the array doubling analysis taught in class. However, it is still possible that each element will need to percolate up to the root, resulting in an amortized running time per operation of \(O(\log n)\).}",na,"a,e",untested,,,,0,1,2010_ba_3c,total points 20
b,TRUE,2010,b,a,4-a,T2/ds10ba.doc,TAU,na,"\begin{itemize}
    \item In this question, we analyze a new deterministic algorithm for the Selection problem. The algorithm selects the k-th largest element from a set A consisting of n different elements.
    \item If \( n < 100 \), the algorithm sorts the n elements and returns the k-th largest element.
    \item Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects the third largest element from it. (If the quartet is \( a<b<c<d \), then the selected element is \( c \).) We denote the selected elements as set B.
    \item Among the \( m = n/4 \) elements of B, the algorithm selects, via a recursive call, the \((2/5)m\)-th largest element. We denote this element as \( x \). (\( x \) is greater than or equal to \((2/5)m\) elements of \( B \).)
    \item The element \( x \) is now compared with all elements of \( A \). We denote by \( A_1 \) the elements of \( A \) that are less than or equal to \( x \), and by \( A_2 \) the elements of \( A \) that are greater than \( x \). We also denote \( r = |A_1| \).
    \item If \( k \leq r \), the algorithm finds, via a recursive call, the k-th largest element in \( A_1 \) and returns it. Otherwise, the algorithm finds, via a recursive call, the \((k-r)\)-th largest element in \( A_2 \) and returns it.
    \item We can ignore partition problems. (It's convenient to assume that \( n \) is divisible by 4, that \( m \) is divisible by 5, and so on.)
    \item What is the largest \( a \) for which it always holds that \( r \geq an + O(1) \)? Prove your answer.
\end{itemize}",na,\(\frac{2}{5} \times \frac{3}{4} = \frac{3}{10}\),na,m,tested,,,,0,1,2010_ba_4a,total points 20
b,TRUE,2010,b,a,4-b,T2/ds10ba.doc,TAU,na,"\documentclass{article}
\begin{document}

In this question, we analyze a new deterministic algorithm for the Selection problem. The algorithm selects the k-th largest element from a set $A$ with $n$ distinct elements.

If $n<100$, the algorithm sorts the $n$ elements and returns the k-th largest element.

Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and chooses from it the third largest element. (If the quartet is $a<b<c<d$, then the chosen element is $c$.) Let $B$ be the set of chosen elements.

Among the $m=n/4$ elements of $B$, the algorithm selects, by a recursive call, the $(2/5)m$-th largest element. Let this element be $x$. ($x$ is greater than or equal to $(2/5)m$ of the elements of $B$.)

The element $x$ is now compared to all the elements of $A$. Let $A_1$ be the elements of $A$ that are less than or equal to $x$, and $A_2$ be the elements of $A$ that are greater than $x$. Also, let $r=|A_1|$.

If $k\leq r$, the algorithm finds, by a recursive call, the k-th largest element in $A_1$ and returns it. Otherwise, the algorithm finds, by a recursive call, the $(k−r)$-th largest element in $A_2$ and returns it.

You can ignore partition issues. (It is possible, when convenient, to assume that $n$ is divisible by 4, that $m$ is divisible by 5, and so on.)
What is the smallest $b$ such that $r\leq bn+O(1)$ always holds? Prove your answer.

\end{document}",na,\( 1 - \frac{3}{5} \cdot \frac{2}{4} = \frac{7}{10} \),na,m,tested,,,,0,1,2010_ba_4b,total points 20
b,TRUE,2010,b,a,4-c,T2/ds10ba.doc,TAU,na,"
In this question, we will analyze a new deterministic algorithm for the selection problem. The algorithm selects the k-th largest element from a set \( A \) with \( n \) distinct elements.

If \( n < 100 \), the algorithm sorts the \( n \) elements and returns the k-th largest element.

Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects the third largest element from it. (If the quartet is \( a < b < c < d \), then the selected element is \( c \).) We denote by \( B \) the set of selected elements.

Among the \( m = n/4 \) elements of \( B \), the algorithm selects, through a recursive call, the \((2/5)m\)-th largest element. We denote this element by \( x \). (\( x \) is greater than or equal to \((2/5)m\) elements of \( B \).)

The element \( x \) is now compared to all elements of \( A \). We denote by \( A_1 \) the elements of \( A \) that are less than or equal to \( x \), and by \( A_2 \) the elements of \( A \) that are greater than \( x \). We also denote \( r = |A_1| \).

If \( k \leq r \), the algorithm finds, through a recursive call, the k-th largest element in \( A_1 \) and returns it. Otherwise, the algorithm finds, through a recursive call, the \((k−r)\)-th largest element in \( A_2 \) and returns it.

We can ignore partitioning problems. (It is possible, when convenient, to assume that \( n \) is divisible by 4, that \( m \) is divisible by 5, and so on.)
Write a recurrence relation for the running time of the algorithm on a set with \( n \) elements.",na,"\text{The runtime consists of linear work on the array, a recursive call on B of size } n/4, \text{ and a recursive call on A1 or A2 whose size we have bounded in the previous sections. In total, } T(n)=O(n)+T(n/4)+T(7n/10).",na,"m,c,a",tested,,,,0,1,2010_ba_4c,total points 20
b,TRUE,2010,b,a,4-d,T2/ds10ba.doc,TAU,na,"\documentclass{article}
\begin{document}

In this question, we will analyze a new deterministic algorithm for the Selection problem. The algorithm selects the k-th largest element from a set A of n different elements.

If \( n < 100 \), the algorithm sorts the n elements and returns the k-th largest element.

Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects from it the third largest element. (If the quartet is \( a < b < c < d \), then the selected element is \( c \).) Let B denote the set of selected elements.

Among the \( m = n/4 \) elements of B, the algorithm selects, by a recursive call, the (2/5)m-largest element. Let this element be denoted by x. (x is greater than or equal to \((2/5)m\) of the elements of B.)

The element x is now compared to all the elements of A. Let \( A_1 \) denote the elements of A that are less than or equal to x, and let \( A_2 \) denote the elements of A that are greater than x. Also denote \( r = |A_1| \).

If \( k \leq r \), the algorithm finds, by a recursive call, the k-th largest element in \( A_1 \) and returns it. Otherwise, the algorithm finds, by a recursive call, the (k-r)-th largest element in \( A_2 \) and returns it.

Division issues can be ignored. (It is possible to assume for convenience that n is divisible by 4, m is divisible by 5, and so on.)
What is the runtime of the algorithm (as a function of n)? (An asymptotic answer in terms of \( O(.) \) is sufficient.)

\end{document}",na,"\text{Since } \frac{1}{4} + \frac{7}{10} < 1, \text{ the analysis is similar to that of the selection algorithm - } O(n).",na,"m,c,a",tested,,,,0,1,2010_ba_4d,total points 20
a,TRUE,2010,b,a,5-a,T2/ds10ba.doc,TAU,na,na,na,na,na,"d,p",na,,,,0,0,2010_ba_5a,total points 25
a,TRUE,2010,b,a,5-b,T2/ds10ba.doc,TAU,na,na,na,na,na,"e,f,p",na,,,,0,0,2010_ba_5b,total points 25
a,TRUE,2010,b,a,5-c,T2/ds10ba.doc,TAU,na,na,na,na,na,"g,p",na,,,,0,0,2010_ba_5c,total points 25
a,TRUE,2010,b,a,5-d,T2/ds10ba.doc,TAU,na,na,na,na,na,n,na,,,,0,0,2010_ba_5d,total points 25
c,FALSE,2010,a,b,1,T2/ds10ab.doc,TAU,9,na,na,na,5,"a,m",na,,,,0,0,2010_ab_1,na
c,FALSE,2010,a,b,2,T2/ds10ab.doc,TAU,8,"Given a matrix with $m$ rows and $n$ columns, where the elements of the matrix are numbers, we want to sort the columns of the matrix from smallest to largest (column A is smaller than column B if in the first row where they differ, the element in column A is smaller than that of column B). What is the tightest lower bound for this sorting, as a function of $m$ and $n$?

A. $\Omega(mn)$

B. $\Omega(mn \log n)$

C. $\Omega(mn^2 \log n)$

D. $\Omega(n \log n)$

E. $\Omega(m \log m)$

F. Both answers A and D are correct.",na,na,6,k,tested,,,,0,1,2010_ab_2,na
c,FALSE,2010,a,b,3,T2/ds10ab.doc,TAU,9,"A student received a sorted array of N distinct real numbers, g1<g2<...<gNg_1 < g_2 < ... < g_Ng1​<g2​<...<gN​. Assume that N is even. The student shuffled the scores by performing a series of swaps between elements, ensuring that in each swap, only neighboring elements in the array were swapped. An example of a valid swap sequence is: swap the first with the second, then the sixth with the seventh, and then the second with the third. The number of swaps is unbounded. After the shuffling, we are interested in sorting the array.

\begin{enumerate}
    \item The array can be sorted in $N$ operations.
    \item The array can be sorted in $N/2$ operations.
    \item Sorting the array requires $\Omega(N \log N)$ operations.
    \item Sorting the array requires $\Omega(\sqrt{N} \log N)$ operations.
    \item None of the answers are correct.
\end{enumerate}
",na,na,4,k,tested,,,,0,1,2010_ab_3,na
c,FALSE,2010,a,b,4,T2/ds10ab.doc,TAU,9,na,na,na,5,k,na,,,,0,0,2010_ab_4,na
c,FALSE,2010,a,b,5,T2/ds10ab.doc,TAU,9,"\[
\text{Given two binomial heaps, } H1 \text{ and } H2. \text{ Let } R1 \text{ and } R2 \text{ denote the number of roots of } H1 \text{ and } H2 \text{ respectively. } \text{ We merge } H1 \text{ and } H2 \text{ using the binomial heap union algorithm to obtain a heap } H. \text{ Let } R \text{ be the number of roots of } H. \text{ We want to know the relation between } R1+R2 \text{ and } R.
\]

\begin{enumerate}
\item[(A)] \( R = R1 + R2 \) always.
\item[(B)] \( R \neq R1 + R2 \) always.
\item[(C)] \( R \leq R1 + R2 \) always.
\item[(D)] \( R \geq R1 + R2 \) always.
\item[(E)] It is impossible to know.
\end{enumerate}
",na,na,5,i,untested,,,,0,1,2010_ab_5,na
c,FALSE,2010,a,b,6,T2/ds10ab.doc,TAU,9,"\text{Given the following function, where } n \text{ is a non-negative parameter, and } k \text{ is a constant:} \\
\text{func}(n): \\
\quad \text{if } n \leq 2010 \text{ then return} \\
\quad \text{else} \\
\quad\quad \text{func}(n/2) \\
\quad\quad \text{func}(n \cdot k) \\
\quad \text{end} \\
\text{Let the running time of the function be denoted by } T(n). \text{ We are given that } T(n) = O(n). \text{ What is } k? \\
\text{A. } 0 \leq k \leq 1 \\
\text{B. } \frac{1}{3} \leq k \leq \frac{2}{3} \\
\text{C. } 0 \leq k \leq 2 \\
\text{D. } k = \frac{1}{3} \\
\text{E. } \frac{1}{2} \leq k \leq 1 \\
\text{F. } 0 \leq k \leq \frac{1}{2}",na,na,6,"a,c",tested,,,,0,1,2010_ab_6,na
c,FALSE,2010,a,b,7,T2/ds10ab.doc,TAU,8,"\text{There are $N$ elements. We want to construct a data structure to contain these elements, and then perform $X$ search operations and $X$ extract-min operations in some order.} \\ \text{The data structure can be implemented using a red-black tree or a binary minimum heap (implemented within an array). We want to minimize the total running time of the construction and all search and extract-min operations.} \\ \text{Which data structure should be chosen when $X = N$? And when $X = \log \log N$?} \\ \text{A. A red-black tree in both cases} \\ \text{B. A binary minimum heap in both cases} \\ \text{C. A red-black tree when $X = N$ and a binary minimum heap when $X = \log \log N$} \\ \text{D. A red-black tree when $X = \log \log N$ and a binary minimum heap when $X = N$} \\ \text{E. A red-black tree when $X = N$ and it doesn't matter when $X = \log \log N$} \\ \text{F. A binary minimum heap when $X = N$ and it doesn't matter when $X = \log \log N$}",na,na,6,"f,h",tested,,,,0,1,2010_ab_7,na
c,FALSE,2010,a,b,8,T2/ds10ab.doc,TAU,9,"Given a 2-3 tree as learned in class (values only in leaves). It is given that the tree has \( n \) values and that they are linked in a linked list. Assume that for the sake of improving operations, there is an additional pointer that points to the minimum element and is updated with each deletion or insertion, so finding the minimum is done in \( O(1) \). Now we can implement the deletemin operation by accessing the minimum element through the pointer and deleting the element using the delete operation. A series of \( n \) deletemin operations is performed on the tree.

The cost of the deletemin operations (excluding the update of minimum values in the different nodes) is:
A. \( O(\log n) \) in the worst case, \( O(\log n) \) amortized.
B. \( O(1) \) in the worst case, \( O(1) \) amortized.
C. \( O(n) \) in the worst case, \( O(\log n) \) amortized.
D. \( O(\log n) \) in the worst case, \( O(1) \) amortized.
E. No answer is correct.",na,na,5,f,untested,,,,0,1,2010_ab_8,na
a,FALSE,2010,a,b,9-a,T2/ds10ab.doc,TAU,na,na,na,na,na,p,na,,,,0,0,2010_ab_9a,total points 14
a,FALSE,2010,a,b,9-b,T2/ds10ab.doc,TAU,na,na,na,na,na,p,na,,,,0,0,2010_ab_9b,total points 14
a,FALSE,2010,a,b,10-a,T2/ds10ab.doc,TAU,1,na,na,na,na,p,na,,,,0,0,2010_ab_10a,na
a,FALSE,2010,a,b,10-b,T2/ds10ab.doc,TAU,6,na,na,na,na,p,na,,,,0,0,2010_ab_10b,na
a,FALSE,2010,a,b,10-c,T2/ds10ab.doc,TAU,10,na,na,na,na,p,na,,,,0,0,2010_ab_10c,na
c,FALSE,2010,a,a,1,T2/ds10aa.doc,TAU,9,"\begin{itemize}
    \item What is the relationship between the following two functions:
    \[ g(n) = 2^{2\log_2(n)}, \quad T(n) = 4T(n/2) + n\log n \]
    \item 
    \begin{enumerate}
    \item \( g(n) = o(T(n)) \)
    \item \( g(n) = O(T(n)) \)
    \item \( g(n) = \Theta(T(n)) \)
    \item \( g(n) = \omega(T(n)) \)
    \item \( g(n) = \Omega(T(n)) \)
    \end{enumerate}
\end{itemize}",na,na,5,a,untested,,,,0,1,2010_aa_1,na
c,FALSE,2010,a,a,2,T2/ds10aa.doc,TAU,8,"\text{Given the following operation op. We start with } i=0 \text{ and perform op n times, what is the amortized cost of the operation op in the sequence?}
\text{op()}
\quad i = i + 1
\quad \text{if } (i = 2^k \text{ for an integer } k) \text{ then}
\quad\quad\text{for } j = 0 \text{ to } 2*i    
\quad\quad\quad\text{do some work in constant time}
\quad\quad\text{end for}
\quad\text{end if}
\text{A. } \Theta(1)
\text{B. } \Theta(\log n) 
\text{C. } \Theta(\log i)
\text{D. } \Theta(n)  
\text{E. } \Theta(n^2)  
\text{F. } \text{None of the answers is correct}",na,na,6,b,tested,,,,0,1,2010_aa_2,na
c,FALSE,2010,a,a,3,T2/ds10aa.doc,TAU,9,"We want to store a group $K$ of keys ($|K|=300$) in a hash table. We have a hash function that satisfies simple uniform hashing (""uniform distribution of keys,"" as learned in class). The table has $B=1000$ buckets.

For each key $k$, let $h(k)$ be the value computed by the hash function. Let $H(K)$ be the range of the function for $K$, i.e., $H(K)=\{h(k)|k\in K\}$. Let $|H(K)|$ be the size of the set $H(K)$.

The set $K$ was chosen arbitrarily and its keys were inserted into a) an open hash (chaining), b) a closed hash (open addressing) where linear rehashing is used (a colliding key searches for a place in the next cell).

For open hashing: Let $P_O$ be the probability that the 301st key will collide and $E_O$ the expected number of its collisions (expected number of keys in the bucket it falls into).
For closed hashing: Let $P_C$ be the probability that the 301st key will collide and $E_C$ the expected number of its collisions.
Choose the most correct answer.

\begin{itemize}
    \item[a.] If $|H(K)|=290$, then necessarily $P_O<P_C$ and necessarily $E_O<E_C$.
    \item[b.] If $|H(K)|=300$, then necessarily $E_O<E_C$.
    \item[c.] If $|H(K)|=300$, then it could be that $E_O<E_C$.
    \item[d.] If $|H(K)|=290$, then it might be that $E_O \ge E_C$.
    \item[e.] A and C are correct.
    \item[f.] None of the answers is correct.
\end{itemize}
",na,na,6,g,untested,,,,0,1,2010_aa_3,na
c,FALSE,2010,a,a,4,T2/ds10aa.doc,TAU,6,"Given a 2-3 tree with values only in the leaves and each leaf has one value. It is given that the tree has 2 values (2 leaves). A series of N insert operations is performed on the tree. Let #splits be the number of split operations performed. Then (you must choose the correct tightest inequality):
a.  #splits≤N+2-\log_2(N)
b.   #splits≤N
c.   #splits≤N/2 
d.   #splits≤2N/3
e. #splits≤(N\log_2(N))/2
f. None of the answers are correct",na,na,6,f,untested,,,,0,1,2010_aa_4,na
c,FALSE,2010,a,a,5,T2/ds10aa.doc,TAU,3,"\text{Given a 2-3 tree with values only in the leaves and each leaf has one value. It is given that the tree has 2 values (2 leaves). A series of } N \text{ insert operations is performed on the tree. Let } \#\text{splits be the number of split operations performed. The number of split operations per insert operation is:}
\begin{itemize}
    \item \text{A. } O(\log n) \text{ in the worst case, } O(1) \text{ amortized.}
    \item \text{B. } O(\log n) \text{ in the worst case, } O(\log n) \text{ amortized.}
    \item \text{C. } O(1) \text{ in the worst case, } O(1) \text{ amortized.}
    \item \text{D. } O(n) \text{ in the worst case, } O(\log n) \text{ amortized.}
    \item \text{E. None of the above answers is correct.}
\end{itemize}",na,na,5,f,tested,,,,0,1,2010_aa_5,na
c,FALSE,2010,a,a,6,T2/ds10aa.doc,TAU,8,"\textbf{A binomial heap with $n$ elements is given. We removed one element from the heap, and the number of trees in the heap increased. An upper bound on the difference between the new number of trees and the old number of trees is (give the tightest bound):} 
\begin{enumerate}
    \item $n$
    \item $\log_2 \log_2 n$
    \item $\log_2 n$
    \item $n/2$
    \item $1$
    \item None of the answers is correct.
\end{enumerate}",na,na,6,i,tested,,,,0,1,2010_aa_6,na
c,FALSE,2010,a,a,7,T2/ds10aa.doc,TAU,9,na,na,na,6,k,na,,,,0,0,2010_aa_7,na
c,FALSE,2010,a,a,8,T2/ds10aa.doc,TAU,8,na,na,na,6,n,na,,,,0,0,2010_aa_8,na
c,FALSE,2010,a,a,9,T2/ds10aa.doc,TAU,9,na,na,na,6,e,na,,,,0,0,2010_aa_9,na
a,FALSE,2010,a,a,10-a,T2/ds10aa.doc,TAU,3,na,na,na,na,"k,l,m",na,,,,0,0,2010_aa_10a,na
a,FALSE,2010,a,a,10-b,T2/ds10aa.doc,TAU,7,na,na,na,na,"k,l,m",na,,,,0,0,2010_aa_10b,na
a,FALSE,2010,a,a,10-c,T2/ds10aa.doc,TAU,5,na,na,na,na,"k,l,m",na,,,,0,0,2010_aa_10c,na
a,FALSE,2010,a,a,11-a,T2/ds10aa.doc,TAU,1,na,na,na,na,m,na,,,,0,0,2010_aa_11a,na
a,FALSE,2010,a,a,11-b,T2/ds10aa.doc,TAU,4,na,na,na,na,m,na,,,,0,0,2010_aa_11b,na
a,FALSE,2010,a,a,11-c,T2/ds10aa.doc,TAU,11,na,na,na,na,m,na,,,,0,0,2010_aa_11c,na
c,TRUE,2012,a,a,1,T2/ds12-AA.doc,TAU,9,"\textbf{Given} an input consisting of $n$ distinct arbitrary integers, we are interested in sorting it. \textbf{It is also given} that the number of inversion pairs, denoted by $\frac{n(n-1)}{2}$, the number of number pairs that are in reverse relative order, is $I = \frac{n(n-1)}{2} - 5n$. A pair of elements $a_i$ and $a_j$ is inverted if $a_i < a_j$ and $i > j$.

Choose the most correct answer (it is possible that among different options, the strongest correct one should be chosen).

a. A lower bound on the sorting time of the input is $\Omega(n \log n)$.
b. The input can be sorted in $O(n)$ time.
c. The input can be sorted in $O(n \log \log n)$ time.
d. The input can be sorted in $O(n \log(n))$ time.
e. Answers a and d are correct.
f. No answer is correct.",b,"\text{The answer is B. We will reverse the array, and we will find that the number of arrangements and the inverse arrangements have swapped. That means, currently the number of pairs in reverse order is } 5n. \text{ We will sort using finger trees and get } O(n + n \log(m/n)) = O(n + n \log 5) = O(n).",6,k,tested,,,,0,1,2012_aa_1,na
c,TRUE,2012,a,a,2,T2/ds12-AA.doc,TAU,9,na,c,na,6,f,na,,,,0,0,2012_aa_2,na
c,TRUE,2012,a,a,3,T2/ds12-AA.doc,TAU,6,na,e,na,6,n,na,,,,0,0,2012_aa_3,na
c,TRUE,2012,a,a,4,T2/ds12-AA.doc,TAU,6,na,d,na,6,n,na,,,,0,0,2012_aa_4,na
c,TRUE,2012,a,a,5,T2/ds12-AA.doc,TAU,6,"\textit{Suppose that the data structure of SUFFIX TREE is updated so that the LABEL of each edge is only one character (that is, instead of an edge with the label ""ck ... c1"" there will be k edges with the labels ""c1"", ""c2"", ..., ""ck""). And it is allowed for an internal node to have one child. What is the worst-case space complexity for this data structure for strings of length n?}

A. \(O(\log n)\)

B. \(O(n)\)

C. \(O(n \log n)\)

D. \(O(n^2)\)

E. \(O(n^3)\)

F. None of the answers are correct",d,"\text{The answer is D. The worst-case scenario can occur when no ""letter"" repeats twice, and it is required that the alphabet be larger than } n. \text{ In this case, we will get a star tree shape around the root, where each edge coming out of the root points to a leaf representing a different and unique substring. Therefore, at least } O(n(n+1)/2)=O(n^2) \text{ space is required.}",6,o,untested,,,,0,1,2012_aa_5,na
c,TRUE,2012,a,a,6,T2/ds12-AA.doc,TAU,9,"\[
Let \, T(n) \, be \, the \, recurrence \, relation \, T(n) = aT(n/a) + f(n) \\
where \, a \, is \, an \, integer \, greater \, than \, 1, \, and \, f(n) \, satisfies \, f(n) = \Theta(n(\log^k(n))) \, for \, an \, integer \, k \, greater \, than \, 1. \, Find \, a \, tight \, bound \, for \, T(n).
\]

\begin{enumerate}
    \item \Theta (n \log n)
    \item \Theta (n \log^k \log n)
    \item \Theta (n \log n / \log k)
    \item \Theta (n (\log^k n))
    \item \Theta (n (\log^{(k+1)} n))
    \item None \, of \, the \, above \, is \, correct
\end{enumerate}",d,"The answer is D.  
According to case 3 of the father's method.",6,"a,c",untested,,,,0,1,2012_aa_6,na
c,TRUE,2012,a,a,7,T2/ds12-AA.doc,TAU,9,na,c,na,6,i,na,,,,0,0,2012_aa_7,na
c,TRUE,2012,a,a,8,T2/ds12-AA.doc,TAU,9,na,e,na,6,f,na,,,,0,0,2012_aa_8,na
c,TRUE,2012,a,a,9,T2/ds12-AA.doc,TAU,9,na,e,na,6,"k,h",na,,,,0,0,2012_aa_9,na
a,FALSE,2012,a,a,10-a,T2/ds12-AA.doc,TAU,4,na,na,na,na,"b,g",na,,,,0,0,2012_aa_10a,na
a,FALSE,2012,a,a,10-b,T2/ds12-AA.doc,TAU,6,na,na,na,na,g,na,,,,0,0,2012_aa_10b,na
a,FALSE,2012,a,a,10-c,T2/ds12-AA.doc,TAU,4,na,na,na,na,"g,f",na,,,,0,0,2012_aa_10c,na
a,FALSE,2012,a,a,11a,T2/ds12-AA.doc,TAU,na,na,na,na,na,"m,k",na,,,,0,0,2012_aa_11a,total points 14
a,FALSE,2012,a,a,11b,T2/ds12-AA.doc,TAU,na,na,na,na,na,"m,k",na,,,,0,0,2012_aa_11b,total points 14
a,FALSE,2012,a,a,11c,T2/ds12-AA.doc,TAU,na,na,na,na,na,"m,k",na,,,,0,0,2012_aa_11c,total points 14
a,FALSE,2012,a,a,11d,T2/ds12-AA.doc,TAU,na,na,na,na,na,"m,k",na,,,,0,0,2012_aa_11d,total points 14
a,FALSE,2013,a,b,1-a,T2/ds13-AB.doc,TAU,na,na,na,na,na,d,na,,,,0,0,2013_ab_1a,total points 25
b,FALSE,2013,a,b,1-b,T2/ds13-AB.doc,TAU,na,"\begin{quote}
Define a structure of a dictionary containing \( n \) words. The dictionary is divided into \( n/k \) pages, with each page containing \( k \) words (assume \( k/n \) is an integer). The words are sorted such that every word on page \( i \) is lexicographically before all the words on page \( i+1 \), but within each page the words are not sorted. The pages are stored in an array, allowing direct access to them. Each page is also an array of words, and they too allow direct access. Assume that comparing words takes constant time (i.e., \( O(1) \)) and all words are distinct from each other.

What size of \( k \) will allow the best asymptotic running time?
\end{quote}",na,na,na,d,tested,,,,0,1,2013_ab_1b,total points 25
a,FALSE,2013,a,b,1-c,T2/ds13-AB.doc,TAU,na,na,na,na,na,d,na,,,,0,0,2013_ab_1c,total points 25
b,FALSE,2013,a,b,1-d,T2/ds13-AB.doc,TAU,na,"\textit{Define a structure of a dictionary containing \( n \) words. The dictionary is divided into \( n/k \) pages where each page contains \( k \) words (assume \( k/n \) is an integer). The words are sorted such that every word on page \( i \) is lexicographically before all the words on page \( i+1 \), but within each page, the words are not sorted. The pages are stored in an array, providing direct access to them, and each page itself is an array of words, also with direct access. Assume that comparing words takes constant time (i.e., \( O(1) \)) and all the words are distinct.

Now it is given that someone has shuffled the order of the pages in the array, though each page itself remains unchanged.

What size of \( k \) would allow for the best asymptotic runtime for the search operation?}",na,na,na,d,tested,,,,0,1,2013_ab_1d,total points 25
a,FALSE,2013,a,b,1-e,T2/ds13-AB.doc,TAU,na,na,na,na,na,d,na,,,,0,0,2013_ab_1e,total points 25
b,FALSE,2013,a,b,1-f,T2/ds13-AB.doc,TAU,na,"\text{We define an ""almost sorted"" array as follows: an array of size } n \text{ where each element in the array is at a distance of up to } n \log \text{ places from its position in a sorted array. In the following sections, you can assume that the elements are distinct from each other. Provide a lower bound in the comparison model for the problem of sorting an almost sorted array.}",na,na,na,"d,k",tested,,,,0,1,2013_ab_1f,total points 25
b,FALSE,2013,a,b,2-a,T2/ds13-AB.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2013_ab_2a,total points 25
b,FALSE,2013,a,b,2-b,T2/ds13-AB.doc,TAU,na,"Insert \( n \) elements, in a certain order, into a hashing table of size \( m \), where \( n < m \), using the chaining method with a hash function \( h \). Fortunately, each of the lists obtained had a length of at most \( q \) where \( q > 2 \) is a parameter, not a constant. Now use the hash function \( h'(k) = 2h(k) \) to insert the \( n \) elements, in the same order, into a second hash table of size \( 2m \) but this time using the linear probing method. Prove a bound as good as possible on the search time (successful or unsuccessful) in the resulting data structure.",na,na,na,g,tested,,,,0,1,2013_ab_2b,total points 25
b,FALSE,2013,a,b,2-c,T2/ds13-AB.doc,TAU,na,"Insert \( n \) elements, in a certain order, into a hash table of size \( m \) using the chaining method with the hash function \( h \). Fortunately, each of the resulting lists was at most of length 2. Now use the hash function \( h'(k) = 2h(k) \) to insert the \( n \) elements, in the same order, into a hash table of size \( 2m \) using the linear probing method. Prove the best possible bound on the search time for successful and unsuccessful searches in the resulting data structure. A successful search is a search for a key found in the data structure. An unsuccessful search is a search for a key not found in the data structure.",na,na,na,g,tested,,,,0,1,2013_ab_2c,total points 25
b,FALSE,2013,a,b,2-d,T2/ds13-AB.doc,TAU,na,"\textbf{Insert} \( n \) \textbf{elements, in a certain order, into two hashing tables of size} \( m \) \textbf{using the Cuckoo Hashing method with hash functions} \( h_1 \) \textbf{and} \( h_2 \). \textbf{For the sake of approximation, all insertions were successful. As a reminder, in Cuckoo Hashing, two tables} \( T_1 \textbf{ and} T_2 \) \textbf{and two hash functions} \( h_1 \textbf{ and} h_2 \) \textbf{are used such that an element} \( k \) \textbf{is inserted into} \( T_1[h_1(k)] \textbf{ or} T_2[h_2(k)] \).

\textbf{Define two functions} \( h_2'(k)=2 \cdot h_2(k)-1-2 \cdot h_1(k)-1 \) \textbf{and} \( h_1'(k)=2 \cdot h_1(k) \), \textbf{and consider the possibility of using the functions} \( h_1' \textbf{ and} h_2' \textbf{ to insert the elements in a different order into a hashing table of size} \( 2m \textbf{ using the double hashing method (as previously mentioned, the double hashing method uses two functions} \( h_1 \) \textbf{and} \( h_2 \textbf{to define the function} \( h(k,i) = ( h_1'(k)+i \cdot h_2'(k) ) \mod m \) \textbf{where} \( h(k,i) \textbf{is the index of the cell on the} ith \textbf{attempt to insert} \( k \textbf{and starting from attempt} i=0 \) \).

\textbf{Suggest an insertion order for the new double hashing table in which the elements can be inserted into the new table so that every successful search will be as efficient as possible. What is the successful search time obtained?}",na,na,na,g,tested,,,,0,1,2013_ab_2d,total points 25
b,FALSE,2013,a,b,3-a,T2/ds13-AB.doc,TAU,na,"\textbf{In this question we analyze a new deterministic algorithm for the Selection problem.} The algorithm selects the k-th largest element from a set \(A\) of \(n\) distinct elements. If \(n > 100\), the algorithm sorts the \(n\) elements and returns the k-th largest element. Otherwise, the algorithm partitions the elements into quartets. The algorithm sorts each quartet and selects the third largest element from each. (If the quartet is \(a < b < c < d\), then the selected element is \(c\).) Let \(B\) be the set of selected elements. Among the \(m = n/4\) elements of \(B\), the algorithm selects, via a recursive call, the \((2/5)m\)-th largest element. Let this element be \(x\). (\(x\) is greater than or equal to \((2/5)m\) of the elements of \(B\).) The element \(x\) is now compared to all elements of \(A\). Let \(A_1\) be the elements of \(A\) that are less than or equal to \(x\), and let \(A_2\) be the elements of \(A\) that are greater than \(x\). Also, let \(r = |A_1|\). If \(k \leq r\), the algorithm finds, via a recursive call, the k-th largest element in \(A_1\) and returns it. Otherwise, the algorithm finds, via a recursive call, the \((k-r)\)-th largest element in \(A_2\) and returns it. In all sections, partitioning issues can be ignored. (It is possible, when convenient, to assume that \(n\) is divisible by 4, that \(m\) is divisible by 5, and so on.)

What is the largest constant \(a\) for which it always holds that \(r \geq an + O(1)\)? Prove your answer.",na,na,na,k,untested,,,,0,1,2013_ab_3a,total points 25
b,FALSE,2013,a,b,3-b,T2/ds13-AB.doc,TAU,na,"\[
\text{In this problem, we analyze a new deterministic algorithm for the Selection problem. The algorithm selects the } k\text{-th largest element from a set } A \text{ of } n \text{ distinct elements.}
\]

\[
\text{If } n > 100 \text{, the algorithm sorts the } n \text{ elements and returns the } k\text{-th largest element.}
\]

\[
\text{Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects the third largest element from each. (If the quartet is } a < b < c < d\text{, the selected element is } c\text{.) Let } B \text{ denote the set of selected elements.}
\]

\[
\text{Among the } m = \frac{n}{4} \text{ elements of } B\text{, the algorithm selects, via a recursive call, the } \left(\frac{2}{5}\right)m\text{-th largest element. Denote this element by } x\text{. (} x \text{ is greater than or equal to } \left(\frac{2}{5}\right)m \text{ elements of } B\text{.)}
\]

\[
\text{The element } x \text{ is now compared to all elements in } A\text{. Let } A_1 \text{ denote the elements of } A \text{ that are less than or equal to } x\text{, and } A_2 \text{ the elements of } A \text{ that are greater than } x\text{. Also, let } r = |A_1|\text{.}
\]

\[
\text{If } k \le r\text{, the algorithm finds, via a recursive call, the } k\text{-th largest element in } A_1 \text{ and returns it. Otherwise, the algorithm finds, via a recursive call, the } (k-r)\text{-th largest element in } A_2 \text{ and returns it.}
\]

\[
\text{In all sections, division issues can be ignored. (It can be assumed that } n \text{ is divisible by 4, } m \text{ by 5, and so on, as convenient.)}
\]

\[
\text{What is the smallest constant } b \text{ such that } r \le bn + O(1) \text{ always holds? Prove your answer.}
\]",na,na,na,k,tested,,,,0,1,2013_ab_3b,total points 25
b,FALSE,2013,a,b,3-c,T2/ds13-AB.doc,TAU,na,"In this problem, we will analyze a new deterministic algorithm for the Selection problem. The algorithm selects the k-th largest element from a set A of n distinct elements.  
If \( n > 100 \), the algorithm sorts the n elements and returns the k-th largest element.  
Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects the third largest element from it. (If the quartet is \( a < b < c < d \), the selected element is \( c \).) We denote by B the set of selected elements. Out of the \( m = n / 4 \) elements of B, the algorithm selects, by a recursive call, the \( (2/5)m \)-th largest element. We denote this element by \( x \). (\( x \) is greater than or equal to \( (2/5)m \) elements of B.)  
The element \( x \) is now compared to all elements of A. We denote by \( A_1 \) the elements of A that are less than or equal to \( x \), and by \( A_2 \) the elements of A that are greater than \( x \). We also denote \( r = |A_1| \).  
If \( k \leq r \), the algorithm finds, by a recursive call, the k-th largest element in \( A_1 \) and returns it. Otherwise, the algorithm finds, by a recursive call, the \( (k-r) \)-th largest element in \( A_2 \) and returns it.  
In all sections, we can ignore division problems. (We can conveniently assume that \( n \) is divisible by 4, \( m \) is divisible by 5, and so on.)  

Write a recurrence formula for the running time of the algorithm on a set of n elements.",na,na,na,k,untested,,,,0,1,2013_ab_3c,total points 25
b,FALSE,2013,a,b,3-d,T2/ds13-AB.doc,TAU,na,"\documentclass{article}
\usepackage[utf8]{inputenc}
\begin{document}

In this question, we analyze a new deterministic algorithm for the selection problem. The algorithm selects the k-th largest element from a set A with n different elements. If \( n > 100 \), the algorithm sorts the n elements and returns the k-th largest element. Otherwise, the algorithm divides the elements into quartets. The algorithm sorts each quartet and selects the third-largest element from it. (If the quartet is \( a < b < c < d \), then the selected element is \( c \).) Let B denote the set of selected elements. Among the \( m=n/4 \) elements of B, the algorithm selects, through a recursive call, the \( (2/5)m \)-th largest element. We denote this element by x (x is greater than or equal to \( (2/5)m \) of the elements in B).

The element x is now compared to all elements of A. Let \( A_1 \) denote the elements of A that are less than or equal to x, and \( A_2 \) the elements of A that are greater than x. We also denote \( r = |A_1| \). If \( k \leq r \), the algorithm finds, through a recursive call, the k-th largest element in \( A_1 \) and returns it. Otherwise, the algorithm finds, through a recursive call, the \( (k-r) \)-th largest element in \( A_2 \) and returns it. 

In all parts, we can ignore division problems. (It is convenient, when necessary, to assume that \( n \) is divisible by 4, m is divisible by 5, and so on.)

What is the running time of the algorithm as a function of n? An asymptotic answer in terms of \( O() \) is sufficient.

\end{document}",na,na,na,k,tested,,,,0,1,2013_ab_3d,total points 25
a,FALSE,2013,a,b,4-a,T2/ds13-AB.doc,TAU,na,na,na,na,na,i,na,,,,0,0,2013_ab_4a,total points 25
a,FALSE,2013,a,b,4-b,T2/ds13-AB.doc,TAU,na,na,na,na,na,i,na,,,,0,0,2013_ab_4b,total points 25
b,FALSE,2013,a,b,4-c1,T2/ds13-AB.doc,TAU,na,na,na,na,na,i,na,,,,0,0,2013_ab_4c1,total points 25
b,FALSE,2013,a,b,4-c2,T2/ds13-AB.doc,TAU,na,na,na,na,na,i,na,,,,0,0,2013_ab_4c2,total points 25
a,FALSE,2013,a,b,4-d,T2/ds13-AB.doc,TAU,na,na,na,na,na,"i,b",na,,,,0,0,2013_ab_4d,total points 25
b,FALSE,2013,a,a,1-a,T2/ds13-AA.doc,TAU,na,"\textit{Modify the implementation of the quicksort algorithm so that it returns a binary search tree with the elements in the nodes as follows:}
\begin{verbatim}
Quicktree(A,p,r)
If (r<p) return NULL
 Else {
 	q = randomized-partition(A,p,r)
 	T1 = Quicktree(A,p,q-1)
 	T2 = Quicktree(A,q+1,r)
 	Allocate a new node N containing A[q]
 	N.left = T1
 	N.right = T2
 	Return N
 }
\end{verbatim}

\textit{Reminder: randomized-partition(A, p, r) randomly selects a pivot in the array $A[p..r]$. At the end of the operation, the pivot is located at place $q$ (the returned value), with values smaller than it on its left and values larger than it on its right. We perform $T=$Quicktree$(A,1,n)$ where $A$ is a given array with $n$ elements, starting at index 1.}

\textit{What is the expected number of comparisons this algorithm performs when running on $A$? Provide an asymptotic bound. Justify your answer.}",na,na,na,"j,f",untested,,,,0,1,2013_aa_1a,total points 25
a,FALSE,2013,a,a,1-b,T2/ds13-AA.doc,TAU,na,na,na,na,na,"j,f",na,,,,0,0,2013_aa_1b,total points 25
b,FALSE,2013,a,a,1-c,T2/ds13-AA.doc,TAU,na,na,na,na,na,"j,f",na,,,,0,0,2013_aa_1c,total points 25
b,FALSE,2013,a,a,1-d,T2/ds13-AA.doc,TAU,na,"\documentclass{article}
\usepackage{amsmath}
\begin{document}

Let's change the implementation of the quicksort algorithm so that it returns a binary search tree with the elements in the nodes as follows:
\begin{verbatim}
Quicktree(A, p, r)
If (r < p) return NULL
Else {
    q = randomized-partition(A, p, r)
    T1 = Quicktree(A, p, q - 1)
    T2 = Quicktree(A, q + 1, r)
    Allocate a new node N containing A[q]
    N.left = T1
    N.right = T2
    Return N
}
\end{verbatim}

Reminder: `randomized-partition(A, p, r)` chooses a pivot in the array \( A[p..r] \) randomly. At the end of the operation, the pivot is located at position \( q \) (the returned value), with values smaller than it on the left, and values larger than it on the right.
We perform \( T = \text{Quicktree}(A, 1, n) \) where \( A \) is a given array with \( n \) elements, starting at index 1.

Let \( Y_{1j} \) denote an indicator random variable that assumes the value 1 if and only if Quicktree compares the smallest element with the \( j \)-th largest element when the \( j \)-th element is chosen as the pivot. What is the expectation \( \mathbb{E}[Y_{1j}] \)? Provide an exact value.

\end{document}",na,na,na,"j,f",tested,,,,0,1,2013_aa_1d,total points 25
b,FALSE,2013,a,a,1-e,T2/ds13-AA.doc,TAU,na,"\textit{We will change the implementation of the quicksort algorithm to return a binary search tree with the elements at the nodes as follows:}

\textbf{Quicktree}(A,p,r)\\
\textbf{If} (r<p) \textbf{return} NULL\\
\textbf{Else} \{ \\
\hspace*{4mm} q = \textbf{randomized-partition}(A,p,r)\\
\hspace*{4mm} T1 = \textbf{Quicktree}(A,p,q-1)\\
\hspace*{4mm} T2 = \textbf{Quicktree}(A,q+1,r)\\
\hspace*{4mm} \textbf{Allocate} a new node N containing A[q]\\
\hspace*{4mm} N.\textbf{left} = T1\\
\hspace*{4mm} N.\textbf{right} = T2\\
\hspace*{4mm} \textbf{Return} N\\
\}

\textit{Reminder:} \textbf{randomized-partition}(A, p, r) selects a pivot in the array A[p..r] randomly. At the end of the operation, the pivot is located at position q (the returned value), to its left are values smaller than it, and to its right are values larger than it.\\

We perform T=\textbf{Quicktree}(A,1,n) where A is a given array with n elements, starting at index 1.

What is the expected length of the path from the root to the smallest element in the tree? Give an exact value (it is possible to leave a sum in the answer).",na,na,na,"j,f",tested,,,,0,1,2013_aa_1e,total points 25
b,FALSE,2013,a,a,1-f,T2/ds13-AA.doc,TAU,na,"We will modify the implementation of the quicksort algorithm so that it returns a binary search tree with the elements in the nodes as follows:
\[ 
\text{Quicktree}(A,p,r)
\]
\[
\text{If } (r<p) \text{ return NULL}
\]
\[
\text{Else }
\{
\]
\[
\quad q = \text{randomized-partition}(A,p,r)
\]
\[
\quad T1 = \text{Quicktree}(A,p,q-1)
\]
\[
\quad T2 = \text{Quicktree}(A,q+1,r)
\]
\[
\quad \text{Allocate a new node } N \text{ containing } A[q]
\]
\[
\quad N.\text{left} = T1
\]
\[
\quad N.\text{right} = T2
\]
\[
\quad \text{Return } N
\]
\[
\}
\]

Reminder: \text{randomized-partition}(A, p, r) selects a pivot in the array \( A[p..r] \) randomly. At the end of the procedure, the pivot is located at position \( q \) (the value returned), with values smaller than it to the left and values larger than it to the right.
We perform \( T=\text{Quicktree}(A,1,n) \) where \( A \) is a given array with \( n \) elements, starting at index 1.

What is the maximum path length from the root to a leaf (a leaf is a node with no children) that can be formed in the tree? Provide an exact value. Describe how such a path would be formed.",na,na,na,"j,f",untested,,,,0,1,2013_aa_1f,total points 25
a,FALSE,2013,a,a,1-g,T2/ds13-AA.doc,TAU,na,na,na,na,na,"j,f",na,,,,0,0,2013_aa_1g,total points 25
a,FALSE,2013,a,a,2-a,T2/ds13-AA.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2013_aa_2a,total points 25
a,FALSE,2013,a,a,2-b,T2/ds13-AA.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2013_aa_2b,total points 25
a,FALSE,2013,a,a,2-c,T2/ds13-AA.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2013_aa_2c,total points 25
a,FALSE,2013,a,a,2-d,T2/ds13-AA.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2013_aa_2d,total points 25
a,FALSE,2013,a,a,3-a,T2/ds13-AA.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2013_aa_3a,total points 25
a,FALSE,2013,a,a,3-b,T2/ds13-AA.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2013_aa_3b,total points 25
a,FALSE,2013,a,a,3-c,T2/ds13-AA.doc,TAU,na,na,na,na,na,f,na,,,,0,0,2013_aa_3c,total points 25
a,FALSE,2013,a,a,4-a,T2/ds13-AA.doc,TAU,na,na,na,na,na,"h,i,k",na,,,,0,0,2013_aa_4a,total points 22
a,FALSE,2013,a,a,4-b,T2/ds13-AA.doc,TAU,na,na,na,na,na,"b,i,k",na,,,,0,0,2013_aa_4b,total points 22
a,FALSE,2013,a,a,4-c,T2/ds13-AA.doc,TAU,na,na,na,na,na,"i,k",na,,,,0,0,2013_aa_4c,total points 22
a,FALSE,2013,a,a,4-d,T2/ds13-AA.doc,TAU,na,na,na,na,na,"i,k,f",na,,,,0,0,2013_aa_4d,total points 22
a,FALSE,2007,b,b,1-a,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_1a,total points 20
a,FALSE,2007,b,b,1-b,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_1b,total points 20
a,FALSE,2007,b,b,1-c,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_1c,total points 20
a,FALSE,2007,b,b,2-a,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_2a,total points 14
a,FALSE,2007,b,b,2-b,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_2b,total points 14
a,FALSE,2007,b,b,3-a,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_3a,total points 18
a,FALSE,2007,b,b,3-b,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_3b,total points 18
a,FALSE,2007,b,b,3-c,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_3c,total points 18
a,FALSE,2007,b,b,4-a,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_4a,total points 20
a,FALSE,2007,b,b,4-b,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_4b,total points 20
a,FALSE,2007,b,b,4-c,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_4c,total points 20
a,FALSE,2007,b,b,5,T2/ds07b_moed_b.pdf,TAU,14,na,na,na,na,na,na,,,,0,0,2007_bb_5,na
a,FALSE,2007,b,b,6-a,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_6a,total points 14
a,FALSE,2007,b,b,6-b,T2/ds07b_moed_b.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2007_bb_6b,total points 14
a,TRUE,2007,b,a,1-a,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_1a,total points 20
a,TRUE,2007,b,a,1-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_1b,total points 20
a,TRUE,2007,b,a,1-c,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_1c,total points 20
a,TRUE,2007,b,a,2-a,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_2a,total points 12
a,TRUE,2007,b,a,2-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_2b,total points 12
a,TRUE,2007,b,a,3-a,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_3a,total points 12
a,TRUE,2007,b,a,3-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_3b,total points 12
b,TRUE,2007,b,a,4-a,T2/ds07b_moed_a_solution.doc,TAU,na,"In the string $S$, the letter $A$ appears one million times, the letter $B$ 100,000 times, and the letter $C$ 1,000 times. Draw the Huffman tree of the string and calculate the encoding length of the string according to this tree.",na,"The encoding length is equal to:  
\(10^6 + 2 \times 10^5 + 2 \times 10^3 = 1202000\)",na,p,tested,,,,0,1,2007_ba_4a,total points 15
a,FALSE,2007,b,a,4-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_4b,total points 15
a,TRUE,2007,b,a,4-c,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_4c,total points 15
a,TRUE,2007,b,a,5,T2/ds07b_moed_a_solution.doc,TAU,8,na,na,na,na,na,na,,,,0,0,2007_ba_5,na
a,TRUE,2007,b,a,6-a,T2/ds07b_moed_a_solution.doc,TAU,6,na,na,na,na,na,na,,,,0,0,2007_ba_6a,na
a,TRUE,2007,b,a,6-b,T2/ds07b_moed_a_solution.doc,TAU,7,na,na,na,na,na,na,,,,0,0,2007_ba_6b,na
b,TRUE,2007,b,a,7-a,T2/ds07b_moed_a_solution.doc,TAU,na,"Mapping \( n \) elements using a universal hash function family to a table with \( m \) cells while resolving collisions by chaining. What is the expected number of pairs \((x, y)\) such that \(x\) and \(y\) are elements of the input, and both map to the same cell?",na,"Answer: \(\Theta(\sqrt[3]{n})\). We number the elements from 1 to \(n\). Let \(X_{i,j}\) be a random variable that equals 1 if element number \(i\) collides with element number \(j\), and equals 0 otherwise. Let \(X\) be the sum of these variables. Then \(X\) equals the number of collisions. According to the linearity of expectation, \( \mathbb{E}[X] = \sum_{i<j} \mathbb{E}[X_{i,j}] \). The probability that two specific elements collide is \( \frac{1}{\text{number of slots}} \). Therefore, \( \mathbb{E}[X_{i,j}] = \frac{1}{m} \) and thus \( \mathbb{E}[X] = \binom{n}{2} \cdot \frac{1}{m} \).",na,g,tested,,,,0,1,2007_ba_7a,total points 10
b,TRUE,2007,b,a,7-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,g,na,,,,0,0,2007_ba_7b,total points 10
a,TRUE,2007,b,a,8-a,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_8a,total points 10
a,TRUE,2007,b,a,8-b,T2/ds07b_moed_a_solution.doc,TAU,na,na,na,na,na,na,na,,,,0,0,2007_ba_8b,total points 10
a,FALSE,2008,a,a,1-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_1a,total points 14
b,FALSE,2008,a,a,1-b,T2/ds08aa.pdf,TAU,na,"\textit{This question refers to the find-union data structure presented in class. Each set is represented by a tree using union by rank and path compression. How much time is required, in the worst case, to perform a series of $m$ operations on $n$ elements where all the union operations are performed before any find operations? Explain your answer.}",na,na,na,n,tested,,,,0,1,2008_aa_1b,total points 14
a,FALSE,2008,a,a,1-c,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_1c,total points 14
a,TRUE,2008,a,a,2-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_2a,total points 14
a,TRUE,2008,a,a,2-b,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_2b,total points 14
a,TRUE,2008,a,a,2-c,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_2c,total points 14
a,FALSE,2008,a,a,3-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_3a,total points 15
b,FALSE,2008,a,a,3-b,T2/ds08aa.pdf,TAU,na,"\begin{quote}
We will modify the Fibonacci heap in the following manner. The trees in the heap will be binomial trees, but for each non-root node, the leftmost child may be missing. In other words, a node with degree \( r \) has \( r \) or \( r-1 \) children, with degrees \( 0, 1, \ldots, r-1 \) or \( 0, 1, \ldots, r-2 \), respectively. If a node with degree \( r \) has only \( r-1 \) children, we will call it a deficient node. Note that it is possible to determine whether a node is deficient by comparing its degree with the degree of its leftmost child. If the difference is 1, it is a regular node; otherwise, it is a deficient node.

We will modify the operation \((\Delta, h, x)\) key-decrease as follows. If the new key of \( x \) is smaller than that of its parent, we detach \( x \) from its parent, and the subtree rooted at \( x \) becomes a tree in the forest. If the degree of \( x \) was \( b \), then the parent of \( x \), \([p[x] = w]\), is now missing a child of degree \( b \). We will correct this according to the following cases:
\begin{itemize}
    \item[A:] \( w \) has a child \( y \) of degree \( b+1 \) and \( y \) is not deficient: Let \( z \) be the leftmost child of \( y \). The node \( z \) has degree \( b \). We detach it from \( y \), making \( y \) a deficient node, and make \( z \) a child of degree \( b \) of \( w \). The correction operation is complete.
    \item[B:] \( w \) has a child \( y \) of degree \( b+1 \) and \( y \) is deficient: We will make \( y \) a non-deficient node of degree \( b \). \( w \) is now missing a child of degree \( b+1 \). We will continue the correction process for it.
    \item[C:] \( w \) has no child \( y \) of degree \( b+1 \) and \( w \) is not deficient: \( w \) will become a deficient node (degree \( b+1 \)), and the correction operation is complete.
    \item[D:] \( w \) has no child \( y \) of degree \( b+1 \) and \( w \) is deficient: \( w \) will become a non-deficient node (degree \( b \)). If \( w \) is not a root, we detach \( w \) from its parent and continue the correction operation for \([p[w]\) which is now missing a node of degree \( b+2 \).
\end{itemize}

What is the worst-case time complexity of the key-decrease operation? Prove your answer.
\end{quote}",na,na,na,a,untested,,,,0,1,2008_aa_3b,total points 15
a,FALSE,2008,a,a,3-c,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_3c,total points 15
b,FALSE,2008,a,a,4-b,T2/ds08aa.pdf,TAU,na,na,na,na,na,a,na,,,,0,0,2008_aa_4b,total points 15 (part a is omitted since it is a coloring question of a tree)
b,FALSE,2008,a,a,4-c,T2/ds08aa.pdf,TAU,na,"```latex
In the implementation of Red-Black trees, we use, among other things, the following types of operations:
R - Reading a pointer. For example: \([x[\text{left}]\)
W - Assigning to a pointer. For example: \(\text{left}[x] \leftarrow y\)
A - Reading the color of a node. For example: \([x[\text{color}]\)
B - Assigning a color. For example: \(\text{color}[y] \leftarrow \text{RED}\)
C - Comparing two keys. For example: \(\text{if } k<\text{key}[x]\)

In the analysis presented in class, we assumed that the cost of all these operations, as well as all other basic operations, is constant.
Let's now assume that each of these five operations has a different cost. Assume that reading the value of a pointer requires \(R\) time units, assigning to a pointer requires \(W\) time units, reading the color requires \(A\) time units, and so forth. Also assume that the cost of any other operation is \(0\).

For example, performing a rotation requires reading and changing a constant number of pointers. Hence, the cost of the operation is \(O(R+W)\). Note that \(-B, A,\) and \(C\) do not appear in this expression because performing a rotation does not require reading or writing colors and does not require comparing keys.

In the analysis of the insert and delete operations, assume that the place of insertion/deletion is given and for every node \(x\), there is a pointer \([x[\text{p}]\) to its parent.

The cost of the operations insert and find in the amortized case, in terms of \(C, B, A, W, R\), and in terms of \(n\), the number of elements in the tree at the time of performing the operation, is:
\begin{align*}
\text{find:} \\
\text{insert:} \\
\text{Proof (explicitly state the potential function you use):}
\end{align*}
```",na,na,na,b,untested,,,,0,1,2008_aa_4c,total points 15 (a is omitted since it is a coloring question of a tree)
a,FALSE,2008,a,a,5-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_5a,total points 14
a,TRUE,2008,a,a,5-b,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_5b,total points 14
a,FALSE,2008,a,a,6-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_6a,total points 14
a,FALSE,2008,a,a,6-b,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_6b,total points 14
a,FALSE,2008,a,a,6-c,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_6c,total points 14
a,FALSE,2008,a,a,7-a,T2/ds08aa.pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_aa_7a,total points 14
b,FALSE,2008,a,a,7-b,T2/ds08aa.pdf,TAU,na,"\text{Let } T \text{ be a hash table with } m \text{ cells; collisions are handled using chaining. Map a set } S \text{ with } n \text{ elements to } A \text{ using a randomly chosen hash function } h \text{ from a universal family of hash functions. What is } n \text{ if the expected number of collisions in } T \text{ is } m \times P \times P^{1/2} \text{? Prove your answer.} \\
n = \\
\text{Proof:}",na,na,na,g,tested,,,,0,1,2008_aa_7b,total points 14
b,FALSE,2008,a,a,7-c,T2/ds08aa.pdf,TAU,na,"Let \( T \) be a hash table with \( m \) cells for handling collisions using chaining. A set \( S \) with \( n \) elements is mapped to \( A \) by a hash function \( h \) chosen randomly from a universal family of hash functions.

Assume that under the specific hash function chosen, there were indeed at most \( m^{1/2} \) collisions.

How many cells in the hash table can contain at least \( m^{1/8} \) elements? Prove your answer.",na,na,na,g,tested,,,,0,1,2008_aa_7c,total points 14
a,FALSE,2008,a,b,1-a,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_1a,total points 17
a,FALSE,2008,a,b,1-b,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_1b,total points 17
a,FALSE,2008,a,b,1-c,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_1c,total points 17
a,FALSE,2008,a,b,2-a,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,i,na,,,,0,0,2008_ab_2a,total points 17 (part c is omitted since the question requires an illustration)
a,FALSE,2008,a,b,2-b,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,i,na,,,,0,0,2008_ab_2b,total points 17 (part c is omitted since the question requires an illustration)
a,FALSE,2008,a,b,4-a,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_4a,total points 16
a,FALSE,2008,a,b,4-b,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_4b,total points 16
b,FALSE,2008,a,b,5-a,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,a,na,,,,0,0,2008_ab_5a,total points 17
b,FALSE,2008,a,b,5-b,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,a,na,,,,0,0,2008_ab_5b,total points 17
b,FALSE,2008,a,b,5-c,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,a,na,,,,0,0,2008_ab_5c,total points 17
a,FALSE,2008,a,b,6-a,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_6a,total points 16
a,FALSE,2008,a,b,6-b,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_6b,total points 16
a,FALSE,2008,a,b,6-c,T2/ds08ab(vaad).pdf,TAU,na,na,na,na,na,na,na,,,,0,0,2008_ab_6c,total points 16
d,TRUE,2011,a,a,1,T2/ds11AAsol.pdf,TAU,10,"\begin{itemize}
\item Given the following recurrence formula:
\[ T(N) = 
\begin{cases} 
8T(\lfloor n/4 \rfloor) & \text{if } n>1 \\
1 & \text{if } n=1 
\end{cases}
\]

A student claimed that the formula satisfies \( T(n)=O(n) \) and provided the following proof:
\begin{enumerate}
    \item[i.] For \( n=1 \) the claim holds immediately.
    \item[ii.] For \( 1<n \) we will prove by induction.
    \begin{enumerate}
        \item[a.] Assume \( T(i) < ci \) for all \( i < n-1 \).
        \item[b.] Substitute the recurrence formula with assumption a and get: \( T(n) \leq 8(cn/4)+n \).
        \item[c.] From b we get \( T(n)=O(n) \).
    \end{enumerate}
\end{enumerate}

Choose the most correct answer:
\begin{enumerate}
    \item[a.] The student was correct in the claim and in the proof.
    \item[b.] The student was wrong in the claim and in the proof. The incorrect part of the proof is ii.c.
    \item[c.] The student was wrong in the claim and in the proof. The incorrect part of the proof is i.
    \item[d.] The student was correct in the claim and wrong in the proof.
    \item[e.] The claim is incorrect but if we replace the number 8 with 4 in the recurrence formula, the claim would be correct.
    \item[f.] Answers b and c are correct.
\end{enumerate}
\end{itemize}",F,ו. Answers B+C are correct,6,a,tested,,,,0,1,2011_aa_1,na
c,TRUE,2011,a,a,2,T2/ds11AAsol.pdf,TAU,10,na,A,na,6,h,na,,,,0,0,2011_aa_2,the answer in the exam was in English.
c,TRUE,2011,a,a,3,T2/ds11AAsol.pdf,TAU,9,na,E,na,6,k,na,,,,0,0,2011_aa_3,na
c,TRUE,2011,a,a,4,T2/ds11AAsol.pdf,TAU,9,"\text{We implemented a binary search tree (not necessarily balanced) on } n \text{ elements. Let } k \text{ denote the number of elements in the tree for which the find operation takes constant time (i.e., independent of } n\text{). What is } k\text{?} \\
\text{A. } k=1 \\
\text{B. } k=O(1) \\
\text{C. } k=O(\log n) \\
\text{D. } k=\lfloor n/2 \rfloor \\
\text{E. } k=O(n) \\
\text{F. Insufficient data to determine} \\
\text{Justify your answer.}",B,\textbf{Answer B:} It is not possible for there to be more than a fixed number of nodes at a given depth because each node has at most 2 children.,6,e,tested,,,,0,1,2011_aa_4,na
c,TRUE,2011,a,a,5,T2/ds11AAsol.pdf,TAU,10,"\textbf{We want to color the nodes of a full binary search tree (i.e., each node has two children) in red and black, so that the coloring adheres to the rules of a red-black tree. Which of the following conditions is a sufficient condition for such a coloring to exist?}
A. All leaves are at the same distance from the root.  
B. The largest distance from the root to a leaf is at most twice the smallest distance from the root to a leaf.  
C. The depth of the right subtree of the root is at most twice the depth of the left subtree of the root.  
D. Answers A and B are correct.  
E. Answers A and C are correct.  
F. No answer is correct.",A,"\textbf{Answer A:} We will paint the entire tree black. It is possible to construct a tree that contradicts B, therefore D is not correct.",6,e,tested,,,,0,1,2011_aa_5,na
c,TRUE,2011,a,a,6,T2/ds11AAsol.pdf,TAU,9,"\text{We are given two 2-4+ trees, one with height } h_1 \text{ and the other with height } h_2. \text{ The heights } h_1 \text{ and } h_2 \text{ are known to us, and we also know that } h_1 > h_2, \text{ and that all elements in the first tree (height } h_1) \text{ are smaller than all elements in the second tree. We want to merge the two trees into one. In what running time can this be done? Choose the tightest answer.} \\
\text{a. } O(h_1) \\
\text{b. } O(h_2) \\
\text{c. } O(h_1h_2) \\
\text{d. } O(h_1/h_2) \\
\text{e. } O(h_1+h_2) \\
\text{f. } O(h_1-h_2) \\
\text{Explain your answer.}",F,\textbf{Answer V:} We will hang the small tree on the rightmost path of the large tree and correct upwards.,6,f,untested,,,,0,1,2011_aa_6,na
c,TRUE,2011,a,a,7,T2/ds11AAsol.pdf,TAU,10,"\begin{itemize}
    \item In this question, we discuss a tree with $100 < n$ nodes where the degree of the root is 2. 
    \item We define the imbalance of the tree as the ratio between the depth of the left subtree of the root and the depth of the right subtree of the root (ratio = the first number divided by the second number).
    \item In which of the following trees can we achieve the greatest imbalance:
    \begin{enumerate}
        \item A tree representing a red-black tree.
        \item A tree representing a 2-4 tree where the degree of the root is 2.
        \item A tree representing a find-union structure (with rank by union) where the degree of the root is 2.
        \item A tree representing a find-union structure without rank by union where the degree of the root is 2.
        \item Answers (a) and (b) are correct.
        \item Answers (c) and (d) are correct.
    \end{enumerate}
\end{itemize}",D,\textbf{Answer D: This is the only tree where there is no depth balance.},6,n,untested,,,,0,1,2011_aa_7,na
c,TRUE,2011,a,a,8,T2/ds11AAsol.pdf,TAU,9,"Let \( A \) be an array of \( N \) numbers. Let the number at the i-th position be denoted as \( A_i \). We say there is an inversion between \( A_i \) and \( A_j \) if \( i < j \) and \( A_i > A_j \). Let \( I \) denote the number of inversions in the array.

What is the runtime of the most efficient algorithm that takes \( A \) and returns the number of inversions, i.e., \( I \)? Choose the tightest upper bound for the runtime of the algorithm:

A. \( O(I) \)  
B. \( O(I + N) \)  
C. \( O(N \log N) \)  
D. \( O(\min\{I+N, N \log N\}) \)  
E. \( O(N + N \log (I/N)) \)  
F. None of the above.

Justify your answer.",E,"\textbf{Solution H'.} In the lecture, we saw insertion sorting using TREE FINGER. The overall runtime is $O(N+N\log(I/N))$ and for each insertion $O(\log(I_k))$, where $I_k$ is the number of inversions up to the $k$-th element. Two things need to be noted: the adjustments for a balanced tree in a red-black tree require a total linear time, and we have already considered the cost of the search. It is possible to perform the SIZE field update during the ascent in the search (using update debt memorization), and therefore it does not add to the cost.",6,a,tested,,,,0,1,2011_aa_8,na
b,TRUE,2011,a,a,9-a,T2/ds11AAsol.pdf,TAU,2,"The deterministic ""select"" algorithm operates as follows:
a. The array is divided into groups of size 5.
b. Each group is sorted.
c. A pivot is chosen as the median of the medians.
d. A ""Partition"" is performed with the chosen pivot.
Assume that instead of groups of size 5 we take groups of size \(\log(n)\). What will be the running time of the algorithm?
What is the cost of step b?",na,\text{Cost} = \Theta(n \log \log n): \text{Explanation: Each set of size} \log n \text{ is sorted in } \Theta (\log n  \cdot  \log \log n) \text{ time. There are } \frac{n}{\log n} \text{ such sets.},na,m,tested,,,,0,1,2011_aa_9a,na
b,TRUE,2011,a,a,9-b,T2/ds11AAsol.pdf,TAU,2,na,na,na,na,m,na,,,,0,0,2011_aa_9b,na
b,TRUE,2011,a,a,9-c,T2/ds11AAsol.pdf,TAU,8,"The ""select"" deterministic algorithm operates as follows:
a. The array is divided into groups of size 5.
b. Each group is sorted.
c. A pivot is chosen as the median of the medians.
d. A ""Partition"" is performed with the chosen pivot.
Suppose that instead of groups of size 5, we take groups of size \(\log(n)\). What will be the runtime of the algorithm? What is the total cost of the algorithm?",na,"\text{Cost: } O(n \log \log n). \text{ Explanation: It can be shown that the pivot is larger (and smaller) than at least } \frac{n}{4} \text{ elements, and therefore the recurrence formula is } T(n) \leq C \cdot n \log \log n + T\left(\frac{n}{\log n}\right) + T\left(\frac{3n}{4}\right). \text{ By induction it can be shown that this results in } T(n) = \Theta(n \log \log n).",na,m,tested,,,,0,1,2011_aa_9c,na
b,TRUE,2011,a,a,10-a,T2/ds11AAsol.pdf,TAU,2,"\textbf{Reminder:} In perfect hash, we choose a random universal hash function to map a given space \( U \) of size \( n \) to an array of size \( n \). Let \( n_i \) be the number of elements mapped to cell \( i \). Then, a random universal hash function is used to map the elements mapped to cell \( i \) to another array of size \( n_i^2 \).

\textbf{Question:} 

Define: A nearly universal family of functions is a family of functions from space \( U \) to \(\{0, \ldots, m-1\}\) such that for any pair of keys \( k_1, k_2 \) in \( U \) the condition \( \Pr(h[k_1] = h[k_2]) \leq 1/m^{0.5} \) holds. Suppose we have a nearly universal family when \( |U| = n \). We take a random function from the family and use it to map the elements of \( U \) to an array of size \( m \). What is the best upper bound on the expected number of collisions if \( m = n^4 \)?",na,"\text{Answer = 0.5. There are } \frac{n^2}{2} \text{ possible collisions and the probability for each is } \frac{1}{\sqrt{m}} = \frac{1}{n^2}, \text{ so by linearity of expectation we get 0.5.}",na,g,untested,,,,0,1,2011_aa_10a,na
b,TRUE,2011,a,a,10-b,T2/ds11AAsol.pdf,TAU,2,na,na,na,na,g,na,,,,0,0,2011_aa_10b,na
b,TRUE,2011,a,a,10-c,T2/ds11AAsol.pdf,TAU,8,na,na,na,na,g,na,,,,0,0,2011_aa_10c,na
d,TRUE,2011,a,b,1,T2/ds11-AB.pdf,TAU,9,"\textbf{Given an input sequence of} $N$ \textbf{distinct real numbers. The first} $0.99N$ \textbf{numbers in the sequence are given in a random arbitrary order (any order is equally likely). The last} $0.01N$ \textbf{numbers satisfy:} 

\textbf{A. They are all smaller than all of the first} $0.99N$ \textbf{numbers in the sequence.}

\textbf{B. They are sorted in ascending order.}

\textbf{Insert the numbers, in their given order, using the insert operation as learned in class, into a regular binary search tree (BST) (not necessarily balanced).}

\textbf{Choose the most accurate statement and provide a convincing argument:}

\textbf{A. The expected total cost of all insertions is} $\Theta(N \log N)$ \textbf{and the maximum cost of a single insertion in the sequence is} $\Theta(N)$

\textbf{B. The expected total cost of all insertions is} $\Theta(N^2)$ \textbf{and the maximum cost of a single insertion in the sequence is} $\Theta(N)$

\textbf{C. The expected total cost of all insertions is} $\Theta(N \log N)$ \textbf{and the maximum cost of a single insertion in the sequence is} $\Theta(\log N)$

\textbf{D. The expected total cost of all insertions is} $\Theta(N^2)$ \textbf{and the maximum cost of a single insertion in the sequence is} $\Theta(\log N)$

\textbf{E. The expected total cost of all insertions is} $\Theta(N)$ \textbf{and the maximum cost of a single insertion in the sequence is} $\Theta(\log N)$

\textbf{F. None of the answers are correct}",B,"\textbf{Answer:} \\
b. The expected total cost of all the revenues is \(\Theta(N^2)\). \\
The maximum cost of a single revenue in the series is \(\Theta(N)\).",6,e,untested,,,,0,1,2011_ab_1,na
d,TRUE,2011,a,b,2,T2/ds11-AB.pdf,TAU,9,na,E,na,6,f,na,,,,0,0,2011_ab_2,na
d,TRUE,2011,a,b,3,T2/ds11-AB.pdf,TAU,9,na,G,na,7,n,na,,,,0,0,2011_ab_3,na
d,TRUE,2011,a,b,4,T2/ds11-AB.pdf,TAU,3,na,C,na,6,j,na,,,,0,0,2011_ab_4,לא בדיוק quick sort.. אולי p?
d,TRUE,2011,a,b,5,T2/ds11-AB.pdf,TAU,7,"Given a pseudo code for a sorting algorithm named Min-Max-Sort. The algorithm takes as input an array \( A \) of \( n \) numbers, and two indices \( p, q \) that satisfy \( 1 \leq p \) and \( p \leq q \leq n \). The algorithm sorts the subarray \( A[p \ldots q] \). 
To sort the entire array \( A \), call Min-Max-Sort(A,1,n).

Min-Max-Sort(A,p,q)
\{
(r,s) \leftarrow \text{rearrange}(A,p,q)
// Rearranges the array A[p,q] such that all occurrences of the minimum are in positions A[p \ldots r-1],
// all occurrences of the maximum are in positions A[s+1 \ldots q], and the rest in A[r \ldots s], and returns r, s.
If(r \leq s)
\quad Min-Max-Sort(A,r,s)
\}

Example for the Rearrange algorithm:
Assume the array \( A \) is: 23 20 3 10 2 10 4 5 1 1
and call Rearrange(A,3,8), then a possible result is: 23 20 10 10 3 4 5 2 1 1
The returned indices are (4,6).
For every subarray \( A[p \ldots q] \), the procedure Rearrange runs in linear time in the size of \( A[p \ldots q] \).
Assume that there are \( k \) distinct values in the array \( A \).
What is the time complexity of the algorithm as a function of \( n \) and \( k \) in the worst case, when running Min-Max-Sort(A,1,n)?

A. \(\Theta(n \log(\frac{n}{k}))\)  
B. \(\Theta(n \log k)\)  
C. \(\Theta(n \log n)\)  
D. \(\Theta(nk)\)  
E. \(\Theta(n^2)\)  
F. None of the answers are correct",D,\textbf{Answer: D},6,a,tested,,,,0,1,2011_ab_5,na
d,TRUE,2011,a,b,6,T2/ds11-AB.pdf,TAU,9,"\begin{enumerate}
    \item If the array size is 1, stop.
    \item Divide the array into \(k\) parts of equal size (for simplicity, assume \(n\) is an integer power of \(k\)).
    \item Recursively sort each part using \(k\)-Merge-Sort.
    \item Merge the \(k\) parts into one sorted array (the merging is described below).
\end{enumerate}

\textbf{Merging \(k\) sorted arrays into one sorted array:}
\begin{enumerate}
    \item Keep a pointer to the beginning of each array.
    \item Insert the values pointed to into a binary minimum heap, along with the pointers, with the key being the value of the pointer.
    \item Perform \(n\) times:
    \begin{enumerate}
        \item Extract the minimum from the heap (denote the value as \(x\) from array \(A_i\)).
        \item Place \(x\) in the unified sorted array as the next value.
        \item Advance the pointer in array \(A_i\) and insert the value it points to into the heap. (If \(x\) is the last value in \(A_i\), do not insert another value into the heap).
    \end{enumerate}
\end{enumerate}

Choose the tightest upper bound possible for the running time of the \(k\)-Merge-Sort algorithm:
\begin{enumerate}
    \item \(O\left(\frac{n \log n}{\log k}\right)\)
    \item \(O(n \log n \cdot \log k)\)
    \item \(O(n \log k)\)
    \item \(O(n \log n)\)
    \item \(O(n (\log n)^k)\)
    \item None of the above
\end{enumerate}",D,\textbf{Answer: D},6,a,untested,,,,0,1,2011_ab_6,na
d,TRUE,2011,a,b,7,T2/ds11-AB.pdf,TAU,5,na,B,na,6,k,na,,,,0,0,2011_ab_7,na
d,TRUE,2011,a,b,8,T2/ds11-AB.pdf,TAU,5,"\textbf{In this question, we deal with ordered pairs of integers }$(x,y)$\textbf{. Two pairs }$(a,b)$\textbf{ and }$(c,d)$\textbf{ are called swapped pairs if }$a=d$\textbf{ and }$c=b$\textbf{. For example: }$(10,17)$\textbf{ and }$(17,10)$\textbf{ are swapped pairs. We have }$M$\textbf{ distinct pairs of numbers }$(x,y)$\textbf{ given as input. We want to write an algorithm to find if among the }$M$\textbf{ pairs there is at least one pair of swapped pairs. We are interested in an algorithm whose expected running time, for any input, is as low as possible. What is the expected running time of the algorithm?}

\textbf{A. }$\theta(\log n)$\textbf{ on average}
\textbf{B. }$\theta(n)$\textbf{ on average}
\textbf{C. }$\theta(n\log n)$\textbf{ on average}
\textbf{D. }$\theta(n(\log n)^2)$\textbf{ on average}
\textbf{E. }$\theta(n^2)$\textbf{ on average}
\textbf{F. None of the answers is correct}",B,\textbf{Answer: B},6,a,tested,,,,0,1,2011_ab_8,na
d,TRUE,2011,a,b,9,T2/ds11-AB.pdf,TAU,9,"\textbf{The following question pertains to the Fibonacci heap data structure as studied and analyzed in class. As a reminder, the operations supported by this data structure are:} make-heap \textbf{(creating an empty heap),} insert \textbf{(inserting a new element into an existing heap),} meld \textbf{(merging two heaps),} decrease-key \textbf{(decreasing the key of a given element),} find-min \textbf{(finding the element in the heap with the minimum key), and} delete-min \textbf{(deleting the element with the minimum key from the heap).} \\
\textbf{n operations are performed on a collection of Fibonacci heaps. Initially, the collection is empty. All the heaps are created by make-heap operations that create empty heaps. Then elements are inserted into the heaps, merged, keys are decreased, elements are deleted, and so on.} \\
\textbf{Choose the most correct statement:} \\
\text{a. The amortized cost of each meld operation is} \, O(\log n) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, \omega(n). \\
\text{b. The amortized cost of each meld operation is} \, O(1) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, \omega(n). \\
\text{c. The amortized cost of each meld operation is} \, O(1) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, \omega(\log n). \\
\text{d. The amortized cost of each meld operation is} \, O(1) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, O(1). \\
\text{e. The amortized cost of each meld operation is} \, O(\log n) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, O(\log n). \\
\text{f. The amortized cost of each meld operation is} \, O(n) \\
\text{\hspace{1em} A meld operation may have a true cost of} \, \omega(n). \\
",D,\textbf{Answer: D},6,i,tested,,,,0,1,2011_ab_9,na
d,TRUE,2011,a,b,10,T2/ds11-AB.pdf,TAU,6,"The given minimal heap H contains n distinct data elements. We are interested in taking the smallest root(n) elements and sorting them in the lowest possible worst-case time. The cost of performing the operation using the best algorithm you know on H is:  
a. O(root(n))  
b. O(root(n)logn)  
c. O(n)  
d. O(nlogn)  
e. O(n root(n))  
f. O(n root(n)logn)",B,\textbf{Answer: B},6,j,tested,,,,0,1,2011_ab_10,na
b,TRUE,2011,a,b,11-a,T2/ds11-AB.pdf,TAU,2,"The deterministic ""select"" algorithm, which we studied in class, works as follows:
a. The array is divided into groups of size 5
b. Sort each group
c. Choose a pivot as the median of the medians (recursively)
d. Perform ""partition"" with the chosen pivot
e. Recursively apply the algorithm on the relevant part.

Assume that instead of groups of size 5, we take groups of size 3. 
In this question, we will deal with the running time of the new algorithm with groups of size 3.
What is the cost of step b? 
Cost:
Explanation:",na,"\text{Cost: } O(N) \\
\text{Explanation: Sorting each triplet is fixed, and there are } N/3 \text{ triplets.}",na,m,tested,,,,0,1,2011_ab_11a,na
b,TRUE,2011,a,b,11-b,T2/ds11-AB.pdf,TAU,2,"\textbf{The deterministic ""select"" algorithm, which we studied in class, operates as follows:}  
a. The array is divided into groups of size 5  
b. Each group is sorted  
c. A pivot is chosen as the median of the medians (recursively)  
d. A ""partition"" is performed with the chosen pivot  
e. The algorithm is applied recursively on the relevant part.  

\textbf{Assume that instead of groups of size 5, we take groups of size 3.}  
In this question, we will discuss the running time of the new algorithm with groups of size 3.  
Let \( T(N) \) denote the running time of the algorithm on an array of size \( N \). What is the cost of step c, expressed in terms of \( T \)?  
\textbf{Cost:}  
\textbf{Explanation:}",na,"\text{Cost: } T(N/3) \\
\text{Explanation: Looking for a median among } N/3 \text{ numbers}",na,m,tested,,,,0,1,2011_ab_11b,na
b,TRUE,2011,a,b,11-c,T2/ds11-AB.pdf,TAU,8,na,na,na,na,m,na,,,,0,0,2011_ab_11c,na
a,TRUE,2011,a,b,12-a,T2/ds11-AB.pdf,TAU,5,na,na,na,na,na,na,,,,0,0,2011_ab_12a,na
b,TRUE,2011,a,b,12-b,T2/ds11-AB.pdf,TAU,6,"\textit{Given an array of size \( n \), divided into \( n/k \) segments, each of length \( k \). It is known that for any two of the \( k \) segments, either all the elements in the first segment are smaller than all the elements in the second segment, or all the elements in the first segment are larger than all the elements in the second segment.
We are interested in a sorting algorithm for arrays of this type, suitable for the comparison model, as well as a lower bound for sorting algorithms in the comparison model for arrays of this type.
Propose the best possible lower bound (as a function of \( n \) and \( k \)) and prove it.}",na,"The number of possible arrangements is \((k!)^{(n/k)} \cdot (n/k)!\).
Taking the log gives:
\(n \log k + \frac{n}{k} \log \frac{n}{k}\).",na,k,tested,,,,0,1,2011_ab_12b,na
b,TRUE,2011,a,b,12-c,T2/ds11-AB.pdf,TAU,6,"\[
\text{Given an array of size } n, \text{ divided into } \frac{n}{k} \text{ segments, each of length } k. \text{ It is known that for any two of the } k \text{ segments, either all the elements in the first segment are smaller than all the elements in the second segment, or all the elements in the first segment are larger than all the elements in the second segment.}
\]
\[
\text{We are interested in a sorting algorithm for arrays of this type, suitable for the comparison model, and also in a lower bound for sorting algorithms in the comparison model for arrays of this type.}
\]
\[
\text{Propose a more efficient algorithm, if it is known that the number of distinct values in each segment is at most } \log k. \text{ What is the running time of the algorithm?}
\]",na,\text{Sorting each segment can now be done in }O(k\log\log k)\text{ time.},na,k,tested,,,,0,1,2011_ab_12c,na
c,TRUE,2011,b,a,1,T2/ds11-BA-sol.pdf,TAU,10,"\begin{enumerate}
    \item A Fibonacci heap is given as learned in class. It is given that it is empty. We perform n insert operations and then two del-min operations. You need to choose the answer that contains:
    \begin{enumerate}
        \item The worst-case running time of the first min-del operation among the two.
        \item The worst-case running time of the second min-del operation among the two.
        \item Justify your answer.
    \end{enumerate}
    
\end{enumerate}

\begin{itemize}
    \item [A.] First w.c \(O(1)\) Second w.c \(O(1)\)
    \item [B.] First w.c \(O(\log n)\) Second w.c \(O(\log n)\)
    \item [C.] First w.c \(O(n)\) Second w.c \(O(n)\)
    \item [D.] First w.c \(O(\log n)\) Second w.c \(O(1)\)
    \item [E.] First w.c \(O(n)\) Second w.c \(O(\log n)\)
    \item [F.] First w.c \(O(n)\) Second w.c \(O(1)\)
\end{itemize}",E,"\textbf{Answer: h}
After one min-del operation, there will be trees up to degree \(\log n\), at most one of each degree.
Therefore, the successive linking in the next phase will take at most \(\log n\). The first operation
will take \(O(n)\) because each element is in its own tree.",6,i,tested,,,,0,1,2011_ba_1,na
c,TRUE,2011,b,a,2,T2/ds11-BA-sol.pdf,TAU,3,"The students were asked to design a new deterministic (non-random) sorting algorithm using comparisons and construct its comparison tree. The number of items to sort is \(N\) and they are all different from each other.

Student A proposed Algorithm A and constructed Tree A for it. The number of leaves in the tree is \(2^{(N \log \log N)}\).  
Student A proposed Algorithm B and constructed Tree B for it. The number of leaves in the tree is \(2^N\).  
Student A proposed Algorithm C and constructed Tree C for it. The number of leaves in the tree is \(N!\).

The three trees were examined and found to accurately reflect the algorithms. It is not known whether the algorithms are correct. Choose the correct answer and justify your answer:

Statement: The number of comparisons in the worst case of Algorithm C is \(O(N \log N)\).  
a. The statement is always true  
b. The statement is not necessarily true",B,"\textbf{Answer: B} \newline
The comparison tree can be balanced or unbalanced, and therefore it is not possible to bound the running time of algorithm G with \(O(N \log N)\).",2,k,tested,,,,0,1,2011_ba_2,na
c,TRUE,2011,b,a,3,T2/ds11-BA-sol.pdf,TAU,3,na,B,na,2,k,na,,,,0,0,2011_ba_3,na
c,TRUE,2011,b,a,4,T2/ds11-BA-sol.pdf,TAU,4,"The students were asked to design a new deterministic sorting algorithm (not random) using comparisons and to build its comparison tree. The number of elements to sort is \( N \) and they are all different from each other.

Student A proposed Algorithm A and built Tree A for it. The number of leaves in the tree is \( 2^{N \log \log N} \).  
Student A proposed Algorithm B and built Tree B for it. The number of leaves in the tree is \( 2^N \).  
Student A proposed Algorithm C and built Tree C for it. The number of leaves in the tree is \( N! \).

The three trees were examined and found to accurately reflect the algorithms. It is not known whether the algorithms are correct. Choose the correct answer and justify your choice:

A. Algorithm A is an incorrect algorithm.  
B. Algorithm A may be correct.",A,"\textbf{Answer: A}\\
Algorithm A' is incorrect because there are not enough leaves in its comparison tree.",2,k,tested,,,,0,1,2011_ba_4,na
c,TRUE,2011,b,a,5,T2/ds11-BA-sol.pdf,TAU,10,"Two binary heaps are given: heap 1 with \( n_1 \) elements, and heap 2 with \( n_2 \) elements. 
Also, it is given that \( n_1 = n_2^2 \). 
Each heap is maintained in an infinite array. What is the best running time for merging the two heaps, that is, an operation that results in one array (it can be one of the heap arrays, there is no need to preserve the original heaps) containing all the elements, such that they represent a heap?
Choose the correct answer and justify your answer. 
A. \( O(\log(n_1) + \log(n_2)) \) 
B. \( O(n_2) \)
C. \( O(n_1) \) 
D. \( O(n_1 + n_2) \) 
E. \( O(n_2 \log n_1) \) 
F. \( O(n_1 \log n_2) \) ",E,\textbf{Answer:} We will insert the elements of the smaller heap into the larger heap one by one.,6,h,tested,,,,0,1,2011_ba_5,na
c,TRUE,2011,b,a,6,T2/ds11-BA-sol.pdf,TAU,10,"\begin{enumerate}
    \item To remind you, the select(k) selection algorithm we learned in class operates as follows:
    \begin{enumerate}
        \item Divide the given array into groups of five, namely into disjoint arrays each with five elements.
        \item Find the medians of each of the fives.
        \item Find the median of medians recursively.
        \item Use the median of medians as a pivot to partition the array.
        \item Apply the algorithm recursively to the appropriate part.
    \end{enumerate}
    A student implemented the algorithm we learned in class. Let's assume a mistake occurred in the implementation of step 2 of the algorithm, so that for epsilon of the fives, the algorithm chooses an element from the five that is not necessarily the median. For example, if epsilon=1/2, the algorithm will choose any element among the five in at most half of the fives, and accordingly, in at least half of the fives, the algorithm will correctly choose the median. Apart from this, the implementation of the algorithm is correct.
    What is the highest bound on epsilon such that the incorrect implementation still returns a correct answer in linear time with respect to the input size, among the following options? Justify your answer.
\end{enumerate}

\begin{itemize}
    \item[a.] $\epsilon = 0$ meaning the algorithm works correctly and in linear time only if the correct medians are always chosen in step 2.
    \item[b.] $\epsilon \leq 0.1$
    \item[c.] $\epsilon \leq 0.2$
    \item[d.] $\epsilon \leq 0.4$
    \item[e.] $\epsilon \leq 0.9$
    \item[f.] $\epsilon \leq 1$ meaning the algorithm will work correctly and in linear time even if in each of the fives a non-median element is chosen.
\end{itemize}",C,"\text{Answer: C} \\
\text{The runtime is } T(n) = O(n) + T(n/5) + T(n - 3n/10 + 2\epsilon/5) \text{ thus answer C} \\
\text{is the largest such that the runtime is linear. The result of the minimization holds in any case.}",6,m,tested,,,,0,1,2011_ba_6,na
c,TRUE,2011,b,a,7,T2/ds11-BA-sol.pdf,TAU,3,na,A,na,2,g,na,,,,0,0,2011_ba_7,na
c,TRUE,2011,b,a,8,T2/ds11-BA-sol.pdf,TAU,3,"\noindent We want to implement a dictionary with the operations Search(), Delete(), Insert() on elements whose keys are integers. We will choose one of the implementations as we have seen them in class. Determine whether the statement is true or false and justify. 

\noindent Statement: 

\noindent \quad If it is important to us that the worst-case runtime for each operation is as low as possible (asymptotically), implementing with a hash table is preferable over implementing with a balanced binary search tree.

\noindent a. True

\noindent b. False",B,"\textbf{Answer: B} A hash table asymptotically improves the expected running time, but not the other two parameters, compared to a balanced binary search tree.",2,g,tested,,,,0,1,2011_ba_8,na
c,TRUE,2011,b,a,9,T2/ds11-BA-sol.pdf,TAU,3,"We want to implement a dictionary with the operations Search(), Delete(), and Insert() on elements whose keys are integers. We will choose one of the implementations, as we saw them in class. Determine for the statement whether it is true or false and justify.

Statement:
If we care about minimizing memory space (asymptotically), implementation with a hash table is preferable over implementation with a balanced binary search tree.
a. True
b. False",B,"\textbf{Answer: B} \\
A hash table asymptotically improves the expected runtime, but not the other two parameters compared to a balanced binary search tree.",2,g,tested,,,,0,1,2011_ba_9,na
c,TRUE,2011,b,a,10,T2/ds11-BA-sol.pdf,TAU,10,"This question refers to an implementation given in class of the union-find data structure that supports the operations find(), union(), make-set(). We are given that in every union operation, it receives two roots and the size of the smaller set among the two being merged is at most 21. The running time of each operation in the worst case should be as good as possible. \( n \) denotes the number of elements in the structure. Choose from the options what the running times of the operations are in the worst case, and justify your answer:

a. The operations find(), union(), make-set() are all in time \( O(1) \).
b. The make-set() operation is in time \( O(1) \), the union(), find() operations are in time \( O(\alpha(n)) \).
c. The make-set(), union() operations are in time \( O(1) \), the find() operation is in time \( O(\log n) \).
d. The make-set() operation is in time \( O(1) \), the union(), find() operations are in time \( O(\log n) \).
e. The union(), find(), make-set() operations are all in time \( O(\log n) \).
f. The make-set(), union(), find() operations are all in time \( O(n) \).",A,"\textbf{Answer: A} \\
The depth of the small tree in the union is bounded by a constant.",6,n,untested,,,,0,1,2011_ba_10,na
c,TRUE,2011,b,a,11,T2/ds11-BA-sol.pdf,TAU,2,na,B,na,6,f,na,,,,0,0,2011_ba_11,na
c,TRUE,2011,b,a,12,T2/ds11-BA-sol.pdf,TAU,8,na,F,na,6,f,na,,,,0,0,2011_ba_12,na
b,TRUE,2011,b,a,13-a,T2/ds11-BA-sol.pdf,TAU,5,na,na,na,na,k,na,,,,0,0,2011_ba_13a,na
a,TRUE,2011,b,a,13-b,T2/ds11-BA-sol.pdf,TAU,7,na,na,na,na,na,na,,,,0,0,2011_ba_13b,na
b,TRUE,2011,b,a,13-c,T2/ds11-BA-sol.pdf,TAU,4,"\textit{A revolutionary computer architecture has been invented that includes a revolutionary operation called COMP that takes} \( \sqrt{N} \) \textit{keys appearing consecutively somewhere in the array and sorts them in ascending order in that place. The COMP operation takes} \( O(1) \) \textit{time to execute. Show how you can efficiently sort} \( N \) \textit{keys. What is the complexity of the algorithm? Hint: Given an array of size} \( N \), \textit{consider how you can rearrange the array so that} \( 0.5 \times \sqrt{N} \) \textit{smallest keys are sorted at the beginning of the array.} 

\textbf{Complexity:}

\textbf{Explanation:}",na,"\textbf{Complexity:} \(O(N)\) \\
We will perform this process on every \(\frac{\sqrt{N}}{2}\) in the array from the left end to the finish. \\
Each such process is bounded by \(O(\sqrt{N})\) and it is performed \(2\sqrt{N}\) times, therefore the total runtime is linear.",na,a,untested,,,,0,1,2011_ba_13c,na
b,TRUE,2011,b,a,14-a,T2/ds11-BA-sol.pdf,TAU,2,"\textit{We will implement an n-bit binary counter. The counter is initialized to the value 0...00. The Inc operation advances the counter, i.e., increases its value by 1 as follows. The operation searches sequentially for the rightmost 0, turns it into a 1, and turns all the 1s to its right into 0s. If the state of the counter is 1...11, then advancing it will change its state to 00...0. For example, if n=5 and the counter state is currently 00111, then after the Inc operation, the counter state will be 01000. After another Inc operation, the counter state will be 01001. The cost of an operation is defined as the number of bits whose value is changed by the operation. For example, the cost of advancing the counter in the example from 00111 to 01000 is 4, since 4 bits changed their value. The answers to the following sections should be exact, not asymptotic in terms of O(). What is the cost of the Inc operation in the worst case? Explain.}",na,"The answer is: \( N \) because it is the number of bits in the numerator, and they can all change in one operation.",na,a,untested,,,,0,1,2011_ba_14a,na
b,TRUE,2011,b,a,14-b,T2/ds11-BA-sol.pdf,TAU,3,na,na,na,na,b,na,,,,0,0,2011_ba_14b,na
b,TRUE,2011,b,a,14-c,T2/ds11-BA-sol.pdf,TAU,5,"\textbf{We will implement a binary counter with $n$ bits. The counter is initialized to the value $0 \ldots 00$. The Inc operation advances the counter, meaning it increases its value by 1 as follows. The operation sequentially searches for the rightmost 0, turns it into a 1, and converts all 1's to its right into 0's. If the counter's state is $1 \ldots 11$, then advancing it will change its state to $00 \ldots 0$. For example, if $n=5$ and the counter state is currently $00111$, then after the Inc operation the counter state will be $01000$. After another Inc operation, the counter state will be $01001$. The cost of an operation is defined as the number of bits whose value is changed by the operation. For instance, the cost of advancing the counter in the example from $00111$ to $01000$ is 4, as 4 bits changed their value. The answers to the following sections need to be precise, not asymptotic in terms of $O(.)$. We will define a Double-Inc operation that calls for two consecutive Inc operations. What is the cost of the Double-Inc operation in the worst case? Explain.}",na,"\textbf{Answer:} n+1 \\
Any two operations necessarily include an operation where only the first bit changes, and therefore in the worst case, it's n+1.",na,a,untested,,,,0,1,2011_ba_14c,na
b,TRUE,2011,b,a,14-d,T2/ds11-BA-sol.pdf,TAU,5,"\text{We implement a binary counter with } n \text{ bits. The counter is initialized to the value } 0...00. \text{ The operation} \\
\text{Inc advances the counter, meaning it increases its value by 1 in the following manner. The operation} \\
\text{systematically searches for the rightmost 0, changes it to 1, and changes all the 1's to its right to 0.} \\
\text{If the state of the counter is } 1...11, \text{ then advancing it will change its state to } 00...0. \\
\text{For example, if } n = 5 \text{ and the current state of the counter is } 00111, \text{ then after the Inc operation} \\
\text{the state of the counter will be } 01000. \text{ After an additional Inc operation, the state of the counter will be} \\
01001. \text{ The cost of an operation is defined as the number of bits whose value is changed by the operation.} \\
\text{For example, the cost of advancing the counter in the example from } 00111 \text{ to } 01000 \text{ is } 4, \text{ since} \\
4 \text{ bits changed their value.} \\
\text{The answers to the following sections need to be precise, not asymptotic in terms of } O(.). \\
\text{Define Double-Inc as an operation that calls two consecutive Inc operations.} \\
\text{What is the amortized cost of the Double-Inc operation? Explain.}",na,"\textbf{Answer: 4} It is exactly the same analysis, except for the two operations, and therefore 4. Indeed, in every two operations, there will be two bits that change from 0 to 1 (two different ones!) - they rise by two, and we place two coins for flipping from 1 to 0 in the future. Anyone who has changed from 1 to 0 has already been funded in the past.",na,b,tested,,,,0,1,2011_ba_14d,na
d,FALSE,2012,b,b,1,T2/ds12-B.pdf,TAU,9,"\documentclass{article}
\begin{document}
Given $n$ arbitrary distinct integers in an array (of size $n$). It is known that all the first $n/2 - \sqrt{n}$ elements are in their places and all the last $n/2 - \sqrt{n}$ elements are in their correct place. Regarding the $2\sqrt{n}$ numbers in the ""middle,"" it is known that the number of pairs that are in reversed relative order is $I = n/10$. We want to sort the array and auxiliary memory can be used. Choose the most correct answer (between different times, choose the tightest).

a. A lower bound on the sorting time of the array is $\Omega(n \log n)$

b. The array can be sorted in $O(n \log n)$ time

c. The array can be sorted in $O(\sqrt{n} \log n)$ time

d. A lower bound on the sorting time of the array is $\omega(n)$

e. The array can be sorted in $O(n \log(I/n) + n)$ time
\end{document}",na,na,5,k,untested,,,,0,1,2012_bb_1,na
d,FALSE,2012,b,b,2,T2/ds12-B.pdf,TAU,9,"\begin{quote}
The Wonder-red-black-tree (Wonder-RBT) is a data structure identical to the red-black tree structure learned in class, with the following modification: the structure supports the operation w-insert(x), which is identical to insert as learned in class except that it reaches the location where x should be inserted directly. Therefore, w-insert does not include the search costs included in regular insert. We are interested in using the wonder-RBT to sort n elements. Choose the most correct answer; among different times, choose the tightest correct one: 
a. With wonder-RBT, it is possible to sort in W.C time in O(nlogn) and on average in O(nlogn) 
b. With wonder-RBT, it is possible to sort in W.C time in O(n^2) and on average in O(nlogn) 
c. With wonder-RBT, it is possible to sort in W.C time in O(nlogn) and on average in O(n) 
d. With wonder-RBT, it is possible to sort in W.C time in O(n) and on average in O(n) 
e. A lower bound on sorting time is \omega(nlogn) 
f. Both answer a and answer e are correct.
\end{quote}",na,na,na,f,tested,,,,0,1,2012_bb_2,na
d,FALSE,2012,b,b,3,T2/ds12-B.pdf,TAU,9,"As mentioned in the lecture, Dijkstra's algorithm is used to find the shortest distances from a given vertex in a graph. Let \( m = \) the number of edges in the graph and \( n = \) the number of vertices. The algorithm uses a priority queue \( Q \) and performs \( m \) decrease-key operations and \( n \) delete-min operations on it. The other operations take linear time in \( O(n+m) \).

For implementing the algorithm, we implement \( Q \) as a heap. In the lecture, we saw that implementing \( Q \) as a binary heap requires \( O((m+n)\log n) \) time for the entire algorithm, and implementing as a Fibonacci heap requires \( O(m+n\log n) \) time.

In the homework, we encountered a d-ary heap. This is a heap implemented like a binary heap, except that each vertex, except for the leaves and at most one vertex on the next-to-last level, has \( d \) children. Note that \( d \) is not fixed, but a parameter in the question.
What is the runtime of Dijkstra's algorithm when implemented with a d-ary heap?
\begin{enumerate}
\item \( O((m+n)\log n) \)
\item \( O(m+n\log n) \)
\item \( O(d(m+n)\log n) \)
\item \( O((m+n)\log_d(n)) \)
\item \( O((m+dn)\log_d(n)) \)
\item \( O(m+n\log_d(n)) \)
\end{enumerate}",na,na,6,p,tested,,,,0,1,2012_bb_3,na
d,FALSE,2012,b,b,4,T2/ds12-B.pdf,TAU,6,"\textbf{What is the best running time for sorting n integers in the range 0 to }(n^4)-1\textbf{? Choose the tightest bound possible.} \\
a. \(O(n)\) \\
b. \(O(n \log \log n)\) \\
c. \(O(n \log n)\) \\
d. \(O(n^2)\) \\
e. \(O(n^4)\) \\
f. \textit{None of the answers are correct}",na,na,6,l,tested,,,,0,1,2012_bb_4,na
d,FALSE,2012,b,b,5,T2/ds12-B.pdf,TAU,6,"\textbf{Given} a union-find data structure according to the definitions learned in class. The implementation is identical to the one learned in class, but does not include path compression in find. Moreover, the implementation of the UNION operation is different. Here is the pseudocode for the new operation:

\texttt{Union(x, y)} \\
\texttt{\hspace{5mm} B = 1 with prob. 1/2} \\
\texttt{\hspace{5mm} If (B == 1)} \\
\texttt{\hspace{10mm} link(find(x), find(y))} \\
\texttt{\hspace{5mm} Else} \\
\texttt{\hspace{10mm} link(find(y), find(x))}

\texttt{link} is the same operation learned in class, meaning it attaches one root to the other. In other words, the operation attaches the root of group 1 to the root of group 2 with probability 0.5, and vice versa with probability 0.5 as well. 
It is given that we start with $n$ groups of size one each. We denote the different elements as $e_i$ where $1 \leq i$ and $i \leq n$. The union operations performed are union($e_1$, $e_i$) for every $i$ satisfying $i \geq 2$ and $i \leq n$.

What is the worst-case runtime of the FIND operation on the new implementation of UNION and the additional data in the question? Choose the tightest bound.

A. $O(1)$ \\
B. $O(\alpha(n))$ \\
C. $O(\log^* n)$ \\
D. $O(\log n)$ \\
E. $O(n)$ \\
F. None of the answers are correct",na,na,6,n,untested,,,,0,1,2012_bb_5,na
d,FALSE,2012,b,b,6,T2/ds12-B.pdf,TAU,6,"\textbf{Given} a union-find data structure according to the definitions learned in class. The implementation is identical to what was learned in class, but does not include path compression in find. Furthermore, the implementation of the UNION operation is different. Here is the pseudocode for the new operation:
\[
\text{Union (x, y)}
\]
\[
B = 1 \text{ with probability } \frac{1}{2}
\]
\[
\text{If } (B == 1)
\]
\[
\text{link(find(x), find(y))}
\]
\[
\text{Else}
\]
\[
\text{link(find(y), find(x))}
\]

\text{The link is the same operation learned in class, meaning it hangs one root under the other. In other words, the operation attaches the root of group 1 to the root of group 2 with probability 0.5, and vice versa with probability 0.5 as well.}

\text{It is given that we start with } n \text{ groups of size one each. We denote the different elements } e_i \text{ where } 1 \leq i \text{ and also } i \leq n.
\text{ The union operations performed are } union(e_1,e_i) \text{ for all } i \text{ such that } i \leq n \text{ and } i \geq 2.

\text{What is the expected height of the tree representing the group after completing the series of union operations? Choose the tightest bound.}

a. \(O(1)\)

b. \(O(\alpha(n))\)

c. \(O(\log^*n)\)

d. \(O(\log n)\)

e. \(O(n)\)

f. \text{None of the answers is correct}",na,na,6,n,tested,,,,0,1,2012_bb_6,na
d,FALSE,2012,b,b,7,T2/ds12-B.pdf,TAU,9,"\begin{itemize}
    \item Let us consider a 2-4 tree at a depth significantly greater than 2.
    \item Let $n$ be the number of elements in the structure. Let $v$ be a ""grandchild"" node of the root, i.e., a node at a distance of two edges from it.
    \item The number of values in the subtree of $v$ is at least:
    \begin{enumerate}
        \item $\omega(n)$
        \item $\omega(n^{0.5})$
        \item $\omega(n^{0.25})$
        \item $\omega(\log n)$
        \item $\omega(\log \log n)$
        \item $\omega(1)$
    \end{enumerate}
\end{itemize}",na,na,6,f,untested,,,,0,1,2012_bb_7,na
d,FALSE,2012,b,b,8,T2/ds12-B.pdf,TAU,9,"\text{Given } n \text{ distinct numbers. We want to construct a data structure from them. Which of the following structures will have the longest worst-case build time?} \\
\text{a. A hash table with collision resolution by linked lists} \\
\text{b. Perfect hash} \\
\text{c. Max heap} \\
\text{d. Red-black tree} \\
\text{e. Answers a + c} \\
\text{f. Answers a + b + c}",na,na,6,g,untested,,,,0,1,2012_bb_8,na
d,FALSE,2012,b,b,9,T2/ds12-B.pdf,TAU,9,"\textbf{Given a binary heap implementation using an array, as we learned in class. The heap is represented by an array, with the root sitting at position 1, and the children of a node at position \(i\) being at positions \(2i\) and \(2i+1\). Additionally, a variable SIZE is given, which holds the position of the last leaf.}

\textbf{We wish to implement the following function: whereToInsert(key). This function receives a key, which is a number, and returns the position in the array where the key will sit at the end of the insert(key) operation. The function does not modify the heap, but merely answers what the position in the array will be where the key will enter. What is the best runtime for implementing the whereToInsert function? Choose the tightest bound.}

\textbf{A. \(O(1)\)}

\textbf{B. \(O(\log\log n)\)}

\textbf{C. \(O(\log n)\)}

\textbf{D. \(O(n)\)}

\textbf{E. \(O(n\log\log n)\)}

\textbf{F. \(O(n\log n)\)}",na,na,6,h,tested,,,,0,1,2012_bb_9,na
b,FALSE,2012,b,b,10-a,T2/ds12-B.pdf,TAU,3,"The ""select"" algorithm, which searches for the i-th element in an array, operates as follows:
a. The array is divided into groups of size .0
b. Sort each group using merge-sort.
c. Select a pivot as the median of the medians recursively, using the same select algorithm.
d. Perform a ""Partition"" with the chosen pivot. \( m \) is the position of the pivot afterward.
e. If \( i=m \), then return the pivot. Otherwise, continue recursively on the left part if \( i<m \) and search for element \( i \); otherwise, on the right part and search for element \( i-m \).

Assume that instead of groups of size 5, we take groups of size \( \sqrt{n} \). Let \( T(n) \) denote the run time of the algorithm on an array of size \( n \).

What is the cost of step b?  
Cost:  
Explanation:",na,na,na,m,tested,,,,0,1,2012_bb_10a,na
b,FALSE,2012,b,b,10-b,T2/ds12-B.pdf,TAU,3,"\begin{quote}
The ""select"" algorithm, which searches for the i-th element in an array, operates as follows:
\begin{enumerate}
    \item The array is divided into groups of size $0$.
    \item Each group is sorted using merge-sort.
    \item A pivot is chosen as the median of the medians recursively, using the same select algorithm.
    \item Perform ""Partition"" with the chosen pivot. Let $m$ be the position of the pivot afterwards.
    \item If $i = m$, then return the pivot. Otherwise, continue recursively on the left part if $i < m$ and search for element $i$, otherwise on the right part and search for element $i - m$.
\end{enumerate}
Assume that instead of groups of size $5$ we take groups of size $\sqrt{n}$. Let $T(n)$ denote the running time of the algorithm on an array of size $n$. What is the cost of step c?

Cost:

Explanation:
\end{quote}",na,na,na,m,tested,,,,0,1,2012_bb_10b,na
b,FALSE,2012,b,b,10-c,T2/ds12-B.pdf,TAU,8,"The algorithm ""select"", which searches for the i-th element in an array, operates as follows: 
a. The array is divided into groups of size .0 
b. Each group is sorted using merge-sort. 
c. Choose a pivot as the median of the medians recursively, using the same select algorithm. 
d. Perform ""Partition"" with the chosen pivot. Let m = the position of the pivot afterward. 
e. If i=m, then return the pivot. Otherwise, continue recursively on the left part if i<m and search for the i-th element, otherwise on the right part and search for the i-m element. 
Assume that instead of groups of size 5, we take groups of size \(\sqrt{n}\). Let T(n) denote the running time of the algorithm on an array of size n. 
What is the total cost of the algorithm? 
Cost: 
Explanation:",na,na,na,m,untested,,,,0,1,2012_bb_10c,na
a,FALSE,2012,b,b,11-a,T2/ds12-B.pdf,TAU,3,na,na,na,na,na,na,,,,0,0,2012_bb_11a,na
b,FALSE,2012,b,b,11-b,T2/ds12-B.pdf,TAU,3,na,na,na,na,o,na,,,,0,0,2012_bb_11b,na
a,FALSE,2012,b,b,11-c,T2/ds12-B.pdf,TAU,8,na,na,na,na,na,na,,,,0,0,2012_bb_11c,na
c,TRUE,2012,b,a,1,T2/ds12ba-sol,TAU,9,"\textbf{Define a d-ary minimum heap:} Each node is smaller than its children, and each node has d children (except for a few nodes in the last and penultimate levels). All levels are full, except possibly the last one, which is filled from the left. For \(d=2\), this is the binary heap that was taught in class. We encountered the d-ary heap in homework.

\textbf{Formally:} Define a data structure Q with two fields. \(Q.size\) is the number of elements in the structure. \(Q.A\) is the array representing the heap. The root is in position 0. The children of node \(i\) are in positions \(di+1\) to \(di+d\) consecutively.

\textbf{Define the d-ary heap construction process:} Traverse the levels from the last level to the top, and at each level from right to left, perform heapify-down on each node. This process is identical to building a binary heap for \(d=2\).

\textbf{Formally:} Assume the array \(Q.A\) is initialized with the input values and the size field as well, then the process is:

\begin{verbatim}
BuildHeap(Q)
for i=Q.size-1 to 0 do
    heapify_down(Q, i)

heapify_down(Q, i)
min = i
j=di+1
while (j > min(Q.size, d(i+1)+1))
    if (Q.A[j] > Q.A[min])
        min = j
    j++
if (min > i)
    swap(Q.A[i], Q.A[min])
    heapify_down(Q, min)
\end{verbatim}

What is the worst-case runtime of the construction process we defined?
A. \(\Theta(n)\)
B. \(\Theta(n\log{d})\)
C. \(\Theta(n\log{n}/\log{d})\)
D. \(\Theta(n\log{n})\)
E. \(\Theta(nd)\)
F. \(\Theta(nd\log{n}/\log{d})\)

\textbf{Brief explanation:}",F,"\textbf{Answer:} \\
We note that in the worst case, we will perform \( n \) iterations, where in each iteration we go through \( d \) elements.",6,h,untested,,,,0,1,2012_ba_1,na
d,TRUE,2012,b,a,2,T2/ds12ba-sol,TAU,9,na,E,na,6,c,na,,,,0,0,2012_ba_2,na
d,TRUE,2012,b,a,3,T2/ds12ba-sol,TAU,9,"Define an infinite binary array, like the binary counter we saw in class, which supports the operation add(k), receiving a positive integer parameter k and adding k to the value n represented in the binary counter. For example, a call add(1), meaning with parameter k=1, is exactly the increment operation of the binary counter. What is the best time complexity in which the operation add(k) can be implemented as a function of k and n?
a. In the worst case O(logn) and amortized O(logk)
b. In the worst case O(log(n+k)) and amortized O(logk)
c. In the worst case O(log(n+k)) and amortized O(logn)
d. In the worst case O(lognlogk) and amortized O(logn)
e. In the worst case O(lognk) and amortized O(logn)
f. In the worst case O(n) and amortized O(k)",B,\textbf{Answer: B},6,b,tested,,,,0,1,2012_ba_3,na
c,TRUE,2012,b,a,4,T2/ds12ba-sol,TAU,9,"\textbf{How can we detect a substring that repeats exactly twice in a suffix tree?} \\
A. A leaf with exactly two possible paths to it. \\
B. A node with exactly two children. \\
C. An edge whose label is exactly two characters long. \\
D. A node whose subtree has a size of exactly two. \\
E. A node in whose subtree there are exactly two leaves. \\
F. This problem cannot be efficiently solved using a suffix tree.",E,"\textbf{Answer: h} \\
In other words, there are exactly two clauses that contain this substring.",6,o,untested,,,,0,1,2012_ba_4,na
c,TRUE,2012,b,a,5,T2/ds12ba-sol,TAU,9,na,A,na,6,m,na,,,,0,0,2012_ba_5,na
d,TRUE,2012,b,a,6,T2/ds12ba-sol,TAU,3,"\begin{quote}
B-tree search trees, as we learned in class, are defined with a parameter \(d\), such that every internal node, except for the root, has between \(d\) and \(2d\) children. For example, 2-4 trees, 3-6 trees, 1024-2048 trees. We will change the definition of the structure so that the number of allowed children will be between \(d_1\) and \(d_2\) for two natural numbers, where it is not necessarily the case that \(d_2=2d_1\). Apart from this change and adjustments derived from it, the rest of the implementation remains unchanged. Are 9-17 trees possible? 
A. Yes 
B. No
\end{quote}",A,"Answer: \\
A - Yes",2,f,untested,,,,0,1,2012_ba_6,na
d,TRUE,2012,b,a,7,T2/ds12ba-sol,TAU,3,"\textit{B-tree} search trees as we learned in class are defined with parameter \( d \), such that each internal node, except for the root, has between \( d \) and \( 2d \) children. For example, \( 2\text{-}4 \) trees, \( 3\text{-}6 \) trees, \( 1024\text{-}2042 \) trees. We will change the definition of the structure so that the number of allowed children is between \( d_1 \) and \( d_2 \) for two natural numbers, when \( d_2=2d_1 \) does not necessarily hold. Except for this change and adjustments derived from it, the rest of the implementation remains the same.
Are \( 9\text{-}99 \) trees possible?
A. Yes
B. No",A,"\textbf{Answer:} \\
A - Yes",2,f,untested,,,,0,1,2012_ba_7,na
d,TRUE,2012,b,a,8,T2/ds12ba-sol,TAU,3,na,B,na,2,f,na,,,,0,0,2012_ba_8,na
c,TRUE,2012,b,a,9,T2/ds12ba-sol,TAU,9,na,A,na,6,g,na,,,,0,0,2012_ba_9,na
d,TRUE,2012,b,a,10,T2/ds12ba-sol,TAU,9,"\textit{Given a lazy binomial heap with $n$ elements, we deleted the minimum element (via the del-min operation), and the number of trees in the heap increased. An upper bound on the difference between the new number of trees and the old number of trees is (give the tightest bound):}
\begin{enumerate}[label=\alph*.]
  \item $n$
  \item $\log n \cdot \log n$
  \item $\log n$
  \item $n/2$
  \item $1$
  \item \textit{none of the above}
\end{enumerate}",C,\textbf{Answer: C},6,i,tested,,,,0,1,2012_ba_10,na
b,FALSE,2012,b,a,11-a,T2/ds12ba-sol,TAU,6,na,na,na,na,m,na,,,,0,0,2012_ba_11a,na
b,FALSE,2012,b,a,11-b,T2/ds12ba-sol,TAU,8,"\begin{quote}
Define the problem Pisga\_i: constructing a peak array at index i. The input to the problem is an array A with n numbers. The index i, where 1 \leq i and i \leq n, is part of the problem definition (i.e., not part of the input). The array must be modified so that it contains all the numbers in array A as follows: up to index i, the numbers are in ascending order, and from index i to the end of the array, the numbers are in descending order. Prove a lower bound for the problem Pisga\_i (as a function of n). Note that the proof must be valid for any value of i between 1 and n. Lower bound: Proof:
\end{quote}",na,na,na,k,tested,,,,0,1,2012_ba_11b,na
d,TRUE,2013,b,a,1,T2/ds13BA-sol.pdf,TAU,5,na,C,na,6,i,na,,,,0,0,2013_ba_1,na
c,TRUE,2013,b,a,2,T2/ds13BA-sol.pdf,TAU,5,na,A,na,6,i,na,,,,0,0,2013_ba_2,na
d,TRUE,2013,b,a,3,T2/ds13BA-sol.pdf,TAU,5,"\begin{itemize}
    \item Define a binary counter with the operation increment(i). The counter is implemented by an infinite array of bits, starting from index 0, where the least significant bit is in position 0 (defined as: the right side of the array). The operation increment(i) increases the value in the counter by 2^i.
    \item The implementation of the operation: starting from position i in the array, change all consecutive 1s starting at i and extending to the left to 0s, and change the first 0 to the left of the consecutive ones to 1 (pseudo-code follows). For example, if the array contains the value ...01101011101 and increment(2) is performed, then the new value will be ...01101100001.
    \item Assume we started with a counter whose value is 0 and performed n Increment(j) operations with arbitrary values of j. After these, increment(i) is performed. What is the worst-case time for this increment(i) operation?
\end{itemize}

\begin{verbatim}   
Increment(A, i)
j \leftarrow i
While (A[j] = 1)
    A[j] \leftarrow 0
    j \leftarrow j+1
A[j] \leftarrow 1
\end{verbatim}

Choose the correct answer (among different times, choose the tightest one).
\begin{enumerate}
    \item O(1)
    \item O(\log i)
    \item O(\log n - \log i)
    \item O(\log n)
    \item O(n-i)
    \item O(n)
\end{enumerate}",F,"\textbf{Answer:} \\
6. \(O(n)\)",6,a,untested,,,,0,1,2013_ba_3,na
c,TRUE,2013,b,a,4,T2/ds13BA-sol.pdf,TAU,5,"Define a binary counter with the operation increment(i). The counter is implemented by an infinite array of bits, starting from index 0, with the least significant bit at position 0 (defined as the right side of the array). The operation increment(i) increases the value on the counter by 2^i. The implementation of the operation is as follows: Starting from position i in the array, change all consecutive 1s starting at i and extending left to 0, and change the first 0 to the left of these consecutive 1s to 1 (pseudocode follows). For example: if the array contains the value ...01101011101 and increment(2) is performed, the new value will be ...01101100001. Assume that we started with a counter with value 0 and performed n Increment(j) operations with arbitrary values of j. After that, perform increment(i). What is the amortized time for an increment(j) operation? Let n denote the number of increment(j) operations performed on the structure (running Increment operations with arbitrary values of j).

Increment(A, i) 
j ← i
While (A[j] = 1)
A[j] ← 0
j ← j+1
A[j] ← 1

Choose the most correct answer (among different times, choose the one that is the tightest). Justify your answer.
a. O(1)
b. O(logi)
c. O(logn-logi)
d. O(logn)
e. O(n-i)
f. O(n)",A,"\textbf{Answer:}  
A. O(1)  
A situation can be created where there are n consecutive ones, and then the increment from the start of the sequence will take linear time in n.  
Amortized runtime can be provided as we did in class. We will place a coin on each lit one, and it will fund its conversion to zero. In each such operation, there is one time a conversion from 0 to 1, and then we place a coin.",6,b,tested,,,,0,1,2013_ba_4,na
c,TRUE,2013,b,a,5,T2/ds13BA-sol.pdf,TAU,5,"\textit{A graph} \(G = (V, E)\) \textit{contains vertices} \(v_1, \ldots, v_n\) \textit{and} \(m\) \textit{edges, which are pairs} \((v_i, v_j)\). \textit{Assume that each vertex and edge can be accessed in} \(O(1)\). \textit{Let} \(A\) \textit{be an algorithm that uses the data structure union-find. The algorithm is as follows:}
1. \textit{For each vertex from} \(i=1\) \textit{perform} \(\text{make-set}(v_i)\)
2. \textit{For each edge: check if} \(\text{find}(v_i) = \text{find}(v_j)\). \textit{If not, perform} \(\text{Union}(v_i, v_j)\).
\textit{Give a tight upper bound, as accurate as possible, on the number of union operations performed during the execution of algorithm} \(A\). \textit{The bound should be exact (not asymptotic)}
a. \(1\)
b. \(\log n\)
c. \(n/2\)
d. \(n-1\)
e. \(n\) 
f. \(m\)",D,"\textbf{Answer:} \\
\textbf{d.} \quad n-1",6,n,tested,,,,0,1,2013_ba_5,na
d,TRUE,2013,b,a,6,T2/ds13BA-sol.pdf,TAU,5,na,B,na,6,n,na,,,,0,0,2013_ba_6,na
c,TRUE,2013,b,a,7,T2/ds13BA-sol.pdf,TAU,5,na,C,na,6,f,na,,,,0,0,2013_ba_7,na
d,TRUE,2013,b,a,8,T2/ds13BA-sol.pdf,TAU,5,"\[
\text{Given a red-black tree with pointers to the maximum and minimum, two additional operations are added:}
\]

\[
\text{max-Insert – Insert an element (guaranteed to be larger than all other elements of the tree) as the right child of the maximum (a pointer to the maximum is given). Update the pointer to the new element inserted as the maximum.}
\]

\[
\text{delete-min – Find the successor of the minimum (search for the successor from the minimum position by the successor operation learned in class), delete the minimum from its position (given pointer). Update the pointer to point to the successor.}
\]

\[
\text{Of course, after each deletion or insertion, red-black tree adjustments are made, as learned.}
\]

\[
\text{The following sequence of operations is performed: Given a sorted array of size n and an empty red-black tree, perform max-insert on the array elements from smallest to largest. Then, perform delete-min until the tree is empty.}
\]

\[
\text{Provide the tightest possible bound for the runtime of the sequence of operations. Justify your answer.}
\]

\begin{enumerate}
    \item \(\mathcal{O}(1)\)
    \item \(\mathcal{O}(\log\log n)\)
    \item \(\mathcal{O}(\log n)\)
    \item \(\mathcal{O}(n)\)
    \item \(\mathcal{O}(n \log n)\)
    \item \(\mathcal{O}(n^2)\)
\end{enumerate}",D,"\textbf{Answer:} \\
d. \( O(n) \) \\
\textbf{Brief Justification:} The repairs may rise up to the root, and the height of the tree is bounded by \( \log n \). Each operation will take constant amortized time. The search following the minimum will take constant time.",6,f,tested,,,,0,1,2013_ba_8,na
c,TRUE,2013,b,a,9,T2/ds13BA-sol.pdf,TAU,5,na,D,na,6,m,na,,,,0,0,2013_ba_9,na
d,TRUE,2013,b,a,10,T2/ds13BA-sol.pdf,TAU,5,"\textbf{Reminder of the select(i) algorithm for finding the i-th largest element:}
1. Partition the array into groups of five.
2. Sort each group of five.
3. Find the median of the medians of the groups of five using select (denote it by x).
4. Perform a partition on the array according to x (denote m as the position where x arrives).
5. If m=i, return x. Otherwise, if m<i continue recursively on the left part with i, otherwise continue recursively on the right part with m-i.

A student implemented the algorithm but mistakenly found the median of the maximum elements at step 3. Instead of finding the median of the medians of the groups of five, they took the maximum from each group and found the median among them using a recursive call to select.
What is the runtime and does the algorithm always produce a correct result? Choose the tightest bound. Justify.

A. O(n) and the algorithm is correct \\
B. O(n\log n) and the algorithm is correct \\
C. O(n^2) and the algorithm is correct \\
D. O(n) and the algorithm is incorrect \\
E. O(n\log n) and the algorithm is incorrect \\
F. O(n^2) and the algorithm is incorrect \\

\textbf{Brief explanation:}",C,"\textbf{Answer:}  
\textbf{c.} $O(n^2)$ and the algorithm is correct.  
From each quintet we select the maximum, so we can say with certainty that at least $1/10$ are larger than the pivot, so we continue recursively on at most $9/10$.  
Solution by induction.",6,m,tested,,,,0,1,2013_ba_10,na
c,TRUE,2013,b,a,11,T2/ds13BA-sol.pdf,TAU,5,na,E,na,6,g,na,,,,0,0,2013_ba_11,na
d,TRUE,2013,b,a,12,T2/ds13BA-sol.pdf,TAU,5,"\text{Define an almost universal family of functions as follows:} \\
\text{For any two distinct values from the domain of } n \text{ keys, the probability of randomly selecting a function from the family such that it returns the same value for both is bounded by } m^{-2/3}. \\
\text{The minimum table size } m \text{ such that if we randomly choose a function, the expected number of collisions is bounded above by 122 is } n^3. \\
\text{Let } X \text{ denote the table size } (n^3). \text{ A student constructed a table of size } 8X. \\
\text{In expectation, after how many trials can a function be found for which there are no collisions? Choose the tightest upper bound. Justify your answer.} \\
\text{a. } 1 \\
\text{b. } \frac{8}{7} \\
\text{c. } \frac{4}{3} \\
\text{d. } 2 \\
\text{e. } 4 \\
\text{f. } 8 \\
",B,"\textbf{Answer:} \\
b. $8/7$ \\
\textbf{Justification:} \\
One must put into the equations the expected number of collisions: $n$ over $2$ divided by $m$ to the power of $-2/3$ and see when it comes out less than $1/2$. \\
According to Markov's inequality, the expectation is $1/2$. If we enter $8X$ into the equation instead of $X$, we will find that the number of collisions is smaller by a factor of $4$ (due to the power of $2/3$). From this, it is eight times further from the expectation, and therefore the probability is $1/8$, and the probability of success is $7/8$. The expectation of a geometric variable is $8/7$.",6,g,tested,,,,0,1,2013_ba_12,na
d,TRUE,2013,b,a,13,T2/ds13BA-sol.pdf,TAU,5,"\begin{quote}
Given an array of $n$ integers between $1$ and $n^2$. Which of the following sorting methods will be the fastest asymptotically? 
A. Counting sort 
B. Radix sort 
C. Quicksort 
D. Merge sort 
E. Counting sort and radix sort will achieve the same asymptotic running time, which is the best running time 
F. Quicksort and merge sort will achieve the same asymptotic running time, which is the best running time
\end{quote}",B,"\textbf{Answer:} \\
b. Radix sort",6,l,tested,,,,0,1,2013_ba_13,na
d,TRUE,2013,b,a,14,T2/ds13BA-sol.pdf,TAU,5,na,E,na,6,l,na,,,,0,0,2013_ba_14,na
c,TRUE,2013,b,a,15,T2/ds13BA-sol.pdf,TAU,3,"\textbf{A ""nearly sorted"" array is defined as follows: each element in the array is within a distance of up to logn places from its sorted position in the array.}
\textbf{What can be said about the running time of finding the median element in the array? Mark A true / B false and justify your answer.}
\textbf{It is possible to find the median using a binary search in the array, and therefore the running time is O(logn)}
\textbf{A. True}
\textbf{B. False}
\textbf{Justification:} ",B,"\textbf{Answer:} \\
(b) False \\
Binary search will not help – the array is not sorted.",2,a,tested,,,,0,1,2013_ba_15,na
c,TRUE,2013,b,a,16,T2/ds13BA-sol.pdf,TAU,3,"\textit{Define a ""nearly sorted"" array as follows: each element in the array is within a distance of at most} \(\log n\) \textit{positions from its location in a sorted array. What can be said about the running time for finding the median in the array? Mark A correct / B incorrect and justify your answer. It is necessary to go through all the elements to find the median, therefore the running time is} \(\Omega(n)\) \textit{for finding the median.} 
A. Correct 
B. Incorrect 
Justification:",B,"\textbf{Answer:} \\
b. False \\
This is not correct - the additional information narrows the search range.",2,a,untested,,,,0,1,2013_ba_16,na
c,TRUE,2013,b,a,17,T2/ds13BA-sol.pdf,TAU,3,"Define an ""almost sorted"" array as follows: each element in the array is up to logn positions away from its position in a sorted array.
What can be said about the runtime for finding the median element in the array? Mark A for correct or B for incorrect and justify your answer.
It is possible to reduce the search space to O(logn) possibilities and find the median in linear time, thus the search time is O(logn).
A. Correct
B. Incorrect
Justification: ",A,"\textbf{Answer:} \\
a. Correct \\
The median does not deviate more than \(\log n\)",2,a,tested,,,,0,1,2013_ba_17,na
c,TRUE,2013,b,a,18,T2/ds13BA-sol.pdf,TAU,3,na,A,na,2,k,na,,,,0,0,2013_ba_18,na
c,TRUE,2013,b,a,19,T2/ds13BA-sol.pdf,TAU,3,"\textbf{Define an ""almost sorted"" array as follows: each element is at a distance of up to \(\log n\) places from its location in a sorted array. What can be said about the running time for finding the median in the array? Mark A' true / B' false and justify your answer. It is necessary to go through at least \(\Omega(\log n)\) elements in order to find the median, and thus the running time is \(\Omega(\log n)\).} \\
\textbf{A. True} \\
\textbf{B. False} \\
Justification:",A,"\textbf{Answer:} \\
a. True \\
The elements are not sorted.",2,k,tested,,,,0,1,2013_ba_19,na
c,TRUE,2013,b,a,20,T2/ds13BA-sol.pdf,TAU,3,"\begin{enumerate}
    \item Answer true or false to the following statement. (Mark 'a' for true / 'b' for false)
    \item Given only pre-order and post-order traversals, a general binary tree can be uniquely reconstructed.
    \begin{itemize}
        \item a. True
        \item b. False
    \end{itemize}
    \item Brief justification:
\end{enumerate}",B,"\textbf{Answer:} \\
b. Incorrect \\
\textbf{Brief explanation:} A counterexample - X is the root, in one tree Y is the right child, and in another tree Y is the left child.",2,e,tested,,,,0,1,2013_ba_20,na
c,TRUE,2013,b,a,21,T2/ds13BA-sol.pdf,TAU,3,na,A,na,2,e,na,,,,0,0,2013_ba_21,na
d,TRUE,2013,b,a,22,T2/ds13BA-sol.pdf,TAU,3,"\textbf{Answer true or false to the following statement. (Select A for true / B for false)}
\textbf{Given only a pre-order traversal, a binary search tree can be uniquely reconstructed.}
A. True
B. False
\textbf{Brief explanation:}",A,"\textbf{Answer:} \\
1. True",2,e,tested,,,,0,1,2013_ba_22,na
d,TRUE,2013,b,a,23,T2/ds13BA-sol.pdf,TAU,3,na,B,na,2,e,na,,,,0,0,2013_ba_23,na
c,TRUE,2013,b,a,24,T2/ds13BA-sol.pdf,TAU,3,na,A,na,2,h,na,,,,0,0,2013_ba_24,na
A,FALSE,2015,b,b,1-a,T3/ds15bb-sol(vaad).pdf,TAU,8,na,na,na,na,na,na,,"נתון מערך עם n מספרים שונים ומספר s.
א. נתון שכל המספרים שייכים לתחום [0, n^5]. תאר/י אלגוריתם דטרמיניסטי בסיבוכיות O(n) שמחזיר את כל הזוגות שההפרש ביניהם שווה ל-s. הוכח/י את תשובתך.",na,,,,
A,FALSE,2015,b,b,1-b,T3/ds15bb-sol(vaad).pdf,TAU,8,na,na,na,na,na,na,,ב. בסעיף זה התחום אליו שייכים המספרים אינו חסום. תאר/י אלגוריתם בסיבוכיות O(n) בתוחלת שמחזיר את כל הזוגות שההפרש ביניהם שווה ל-s. הוכח/י את תשובתך.,na,,,,
A,FALSE,2015,b,b,1-c,T3/ds15bb-sol(vaad).pdf,TAU,8,na,na,na,na,na,na,,ג. בסעיף זה התחום אליו שייכים המספרים אינו חסום. תאר/י אלגוריתם דטרמיניסטי בסיבוכיות O(nlogn) שמחזיר את כל הזוגות שההפרש ביניהם שווה ל-s. הוכח/י את תשובתך.,na,,,,
A,FALSE,2015,b,b,2-a,T3/ds15bb-sol(vaad).pdf,TAU,9,na,na,na,na,na,na,,"א. תאר/י מבנה נתונים התומך בפעולות הבאות (ניתן להניח שכל האיברים המוכנסים למבנה הנתונים שונים):

A ← MakeItem(i) – צור את האיבר A שמחזיק את המספר i.
Insert(A) – הכנס את האיבר A.
Delete(A) – מחק את האיבר A.
FindMedian() – החזר את האיבר החציוני.
Select(i) – החזר את האיבר ה-i לפי יחס הסדר בין האיברים.

על Insert, Delete ו-Select לרוץ בסיבוכיות לוגריתמית במספר האיברים במבנה הנתונים.
על MakeItem ו-FindMedian לרוץ בזמן קבוע.",na,,,,
A,FALSE,2015,b,b,2-b,T3/ds15bb-sol(vaad).pdf,TAU,8,na,na,na,na,na,na,,"ב. נתונים 2 מערכים ממויינים, כל מערך בגודל n איברים. בהינתן איבר (כאינדקס במערך) באחד המערכים תאר/י אלגוריתם בסיבוכיות O(log n) למציאת מיקומו לפי יחס הסדר בין כל 2n האיברים. הוכח/י את תשובתך.",na,,,,
A,FALSE,2015,b,b,2-c,T3/ds15bb-sol(vaad).pdf,TAU,10,na,na,na,na,na,na,,"ג. נתונים 2 מערכים ממויינים, כל מערך בגודל n איברים. בהינתן המספר i תאר/י אלגוריתם בסיבוכיות O(log^2 n) למציאת האיבר במיקום i לפי יחס הסדר בין כל 2n האיברים. הוכח/י את תשובתך.",na,,,,
C,FALSE,2015,b,b,3-a,T3/ds15bb-sol(vaad).pdf,TAU,2,"\begin{itemize}
\item For each of the following statements, determine whether it is true or false.
\item Insertion into a binary search tree is commutative. That is, inserting element $x$ into tree $T$ and then element $y$ results in the same tree obtained from inserting $y$ and then $x$.
\end{itemize}",FALSE,na,2,e,tested,,"לגבי כל אחת מהטענות הבאות קבע/י אם היא נכונה או אינה נכונה.
הכנסה לעץ חיפוש בינארי היא קומוטטיבית. כלומר, הכנסת אלמנט x לעץ T ואז אלמנט y, נותנת את אותו העץ המתקבל מהכנסת y ואז x.",na,,,,hand-written answer exists
C,FALSE,2015,b,b,3-b,T3/ds15bb-sol(vaad).pdf,TAU,2,"\textbf{For each of the following statements, determine whether it is true or not.}\\
If the numbers 1, \ldots, n are inserted into a binary search tree in order (i.e., from smallest to largest), every path in the tree will be of length $O(\log n)$.",FALSE,na,2,e,tested,,"לגבי כל אחת מהטענות הבאות קבע/י אם היא נכונה או אינה נכונה.
אם מכניסים את המספרים 1,…,n לעץ חיפוש בינארי לפי הסדר (כלומר מהקטן לגדול), נקבל שכל מסלול בעץ הוא באורך O(log n).",na,,,,hand-written answer exists
C,FALSE,2015,b,b,3-c,T3/ds15bb-sol(vaad).pdf,TAU,2,"Determine whether each of the following claims is true or false.  
It holds that \(\log n = O((\log \log n)^2)\).",FALSE,na,2,p,tested,,"לגבי כל אחת מהטענות הבאות קבע/י אם היא נכונה או אינה נכונה.
מתקיים log n = O((log log n)^2).",na,,,,
C,FALSE,2015,b,b,3-d,T3/ds15bb-sol(vaad).pdf,TAU,2,na,FALSE,na,2,g,untested,,"לגבי כל אחת מהטענות הבאות קבע/י אם היא נכונה או אינה נכונה.
אם נשנה את שיטת ה-hash with chaining שנלמדה בכיתה כך שבכל תא של הטבלה האלמנטים נשמרים ברשימה מקושרת בסדר ממויין נקבל שבתוחלת זמן החיפוש הכנסה ומחיקה של אלמנט מהטבלה ייקח O(log α) במקום O(α), כאשר α הוא היחס בין מספר האיברים לגודל הטבלה.",na,,,,hand-written answer exists
C,FALSE,2015,b,b,4,T3/ds15bb-sol(vaad).pdf,TAU,6,"In the course, there are \( n \) students. The grades awarded in the course are any real numbers, and no two grades are the same. The lecturers proposed 4 optional data structures for submission to the secretariat: 
1) A regular binary search tree. 
2) A red-black tree. 
3) A Fibonacci heap. 
4) A binary heap.

The secretariat is allowed to process the information received from the lecturer with preliminary processing (including transferring to another structure) and then the secretariat must perform \(\sqrt{N}\) order statistics searches one after the other (such as finding the median grade, the 100th largest grade, etc.).

We are interested in a structure that will minimize the overall (asymptotic) complexity (including initial processing) of performing the work by the secretariat (but not including the complexity of building the data structure by the lecturers):

1. A Fibonacci heap and a red-black tree will provide the best performance and allow processing in \(\theta(N)\).
2. The best performance that can be achieved on a regular binary search tree will cost \(\theta(N \log N)\).
3. A binary heap is worse (asymptotically) than all the other structures, and the best performance using it allows the work to be performed in \(\theta(N \sqrt{N})\).
4. A red-black tree will provide the best performance and allow processing \(O(\sqrt{N} \log N)\).
5. A binary search tree and a red-black tree will provide the best performance and allow processing in \(\theta(N)\).
6. A binary search tree and a red-black tree will provide the best performance and allow processing \(O(\sqrt{N} \log N)\).",5,na,6,"e,f,h,i",tested,,"בקורס ישנם n סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונליים להגשה למזכירות: 
1) עץ חיפוש בינארי רגיל. 
2) עץ אדום שחור. 
3) ערימת פיבונאצי. 
4) ערימה בינארית.

למזכירות מותר לעבד את המידע שהתקבל מהמרצה עיבוד ראשוני (כולל העברה למבנה אחר) ואז על המזכירות לבצע √N חיפושי order statistics בזה אחר זה (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו׳). 

הננו מעוניינים במבנה שיקטין את הסיבוכיות (אסימפטוטית) הכוללת (כולל עיבוד ראשוני) של ביצוע העבודה על ידי המזכירות (אבל לא כולל את סיבוכיות בניית מבנה הנתונים ע״י המרצים):

1. ערימת פיבונאצי ועץ אדום שחור ייתנו את הביצועים הטובים ביותר ויאפשרו ביצוע ב-θ(N).
2. הביצוע הטוב ביותר שניתן לבצע על עץ חיפוש בינארי רגיל יעלה θ(N log N).
3. ערימה בינארית גרועה (אסימפטוטית) יותר מכל המבנים האחרים והביצוע הטוב ביותר באמצעותה מאפשר לבצע את העבודה ב-θ(N √N).
4. עץ אדום שחור ייתן את הביצועים הטובים ביותר ויאפשר ביצוע O(√N log N).
5. עץ חיפוש בינארי ועץ אדום שחור ייתנו את הביצועים הטובים ביותר ויאפשרו ביצוע ב-θ(N).
6. עץ חיפוש בינארי ועץ אדום שחור ייתנו את הביצועים הטובים ביותר ויאפשר ביצוע O(√N log N).",na,,,,"hand-written answer exists
classified red-black trees as f"
C,FALSE,2015,b,b,5,T3/ds15bb-sol(vaad).pdf,TAU,4,"In the course, there are \( n \) students. The grades awarded in the course are any real numbers, and no two grades are identical. The lecturers proposed 4 optional data structures for submission to the secretariat: 
1) A standard binary search tree. 
2) A red-black tree. 
3) A Fibonacci heap. 
4) A binary heap.

The secretariat is allowed to perform an initial processing of the information received from the lecturer (including transferring it to another structure) and then the secretariat must perform \( \sqrt{N} \) order statistics searches one after the other (such as finding the median grade, the 100th largest grade, etc.)

The university administration demanded that the secretariat be able to perform \( O(N) \) arbitrary order statistics searches (instead of \( \sqrt{N} \)) one after the other. Each search request must be answered before seeing the next search request. The best time complexity that can be achieved using the best structure is:

1. \( \theta(N) \).
2. \( \theta(N \log N) \).
3. \( \theta(N \sqrt{N}) \).
4. \( O(\sqrt{N} \log N) \).
5. \( \theta(N \log \log N) \).
6. None of the answers is correct.",1,na,6,"e,f,h,i",tested,,"בקורס ישנם n סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונליים להגשה למזכירות: 
1) עץ חיפוש בינארי רגיל. 
2) עץ אדום שחור. 
3) ערימת פיבונאצי. 
4) ערימה בינארית.

למזכירות מותר לעבד את המידע שהתקבל מהמרצה עיבוד ראשוני (כולל העברה למבנה אחר) ואז על המזכירות לבצע √N חיפושי order statistics בזה אחר זה (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו׳). 

הנהלת האוניברסיטה דרשה מהמזכירות להיות מסוגלת לבצע O(N) חיפושי order statistics שרירותיים (במקום √N) בזה אחר זה. יש לענות על כל בקשת חיפוש לפני שרואים את בקשת החיפוש הבאה. הזנן הטוב ביותר שניתן לבצע בעזרת המבנה הטוב ביותר הינו:

1. θ(N).
2. θ(N log N).
3. θ(N √N).
4. O(√N log N).
5. θ(N log log N).
6. אף תשובה לא נכונה.",na,,,,"hand-written answer exists
classified red-black trees as f"
C,FALSE,2015,b,b,6,T3/ds15bb-sol(vaad).pdf,TAU,4,"\textit{You have been asked to handle a sequence consisting of \(N\) \texttt{insert(z,Q)} requests followed by 3 \texttt{delete-min(Q)} operations. We are interested in a structure that will support these operations. We will consider the use of one of the following structures:}
1) \textit{A min-heap using the \texttt{insert(z,Q)} operation we learned in class for inserting elements (MinHeap).}
2) \textit{A lazy binomial heap (LazyBinom).}
\textit{The performance by which the quality of the structure is measured are:}
- \textit{Asymptotic total time for \(N+3\) operations (denoted as total).}
- \textit{Asymptotic worst-case time of the worst operation among \(N+3\) operations (denoted as worst-case).}
\textit{Choose the correct answer and provide the complexity in the explanation box.}
1. \texttt{Total(MinHeap)} \textit{is lower than} \texttt{Total(LazyBinom)}.
2. \texttt{Total(MinHeap)} \textit{is higher than} \texttt{Total(LazyBinom)}.
3. \texttt{Total(MinHeap)} \textit{is equal to} \texttt{Total(LazyBinom)}.",2,na,3,"h,i",tested,,"התבקשתם לטפל ברצף המורכב מ-N בקשות insert(z,Q) שלאחריהן 3 פעולות delete-min(Q). אנחנו מעוניינים במבנה שיתמוך בפעולות האלו. נשקול שימוש באחד מהמבנים הבאים:
1) ערימת מינימום המשתמשת בפעולת insert(z,Q) שלמדנו בכיתה לצרכי הכנסת איברים (MinHeap).
2) ערימה בינומית עצלה (LazyBinom).
הביצועים שלפיהם נשקלת איכות המבנה הינם:
- זמן כולל אסימפטוטי על N+3 פעולות (יכונה total).
- זמן גרוע ביותר אסימפטוטית של הפעולה הגרועה ביותר בין N+3 הפעולות (יכונה worst-case).
בחרו את התשובה הנכונה וספקו את הסיבוכיות במלבן ההסבר.
1. Total(MinHeap) נמוך יותר מ-Total(LazyBinom).
2. Total(MinHeap) גבוה יותר מ-Total(LazyBinom).
3. Total(MinHeap) שווה ל-Total(LazyBinom).",na,,,,hand-written answer exists
C,FALSE,2015,b,b,7,T3/ds15bb-sol(vaad).pdf,TAU,4,na,1,na,3,"h,i",untested,,"התבקשתם לטפל ברצף המורכב מ-N בקשות insert(z,Q) שלאחריהן 3 פעולות delete-min(Q). אנחנו מעוניינים במבנה שיתמוך בפעולות האלו. נשקול שימוש באחד מהמבנים הבאים:
1) ערימת מינימום המשתמשת בפעולת insert(z,Q) שלמדנו בכיתה לצרכי הכנסת איברים (MinHeap).
2) ערימה בינומית עצלה (LazyBinom).
הביצועים שלפיהם נשקלת איכות המבנה הינם:
- זמן כולל אסימפטוטי על N+3 פעולות (יכונה total).
- זמן גרוע ביותר אסימפטוטית של הפעולה הגרועה ביותר בין N+3 הפעולות (יכונה worst-case).
בחרו את התשובה הנכונה וספקו את הסיבוכיות במלבן ההסבר.
1. Worst-case(MinHeap) נמוך יותר מ-Worst-case(LazyBinom).
2. Worst-case(MinHeap) גבוה יותר מ-Worst-case(LazyBinom).
3. Worst-case(MinHeap) שווה ל-Worst-case(LazyBinom).",na,,,,hand-written answer exists
C,FALSE,2015,b,b,8,T3/ds15bb-sol(vaad).pdf,TAU,5,"\begin{itemize}
    \item Reminder of the SELECT(i) algorithm to find the i-th largest element:
    \begin{itemize}
        \item Divide the array into groups of five.
        \item Sort each quintuple.
        \item Find the median of medians of the quintuples using select (denote it by x).
        \item Perform a partition on the array based on x (denote m as the position x reached).
        \item If i = m, return x. Otherwise, if i < m, continue recursively on the left part with i; else continue recursively with the right part with i.
    \end{itemize}
    \item A student implemented the algorithm, but made the following changes in steps 1-3 of the algorithm:
    \begin{itemize}
        \item Instead of quintuples, they worked with sextuples.
        \item Instead of the median of a sextuple, they took the 1/3rd largest element (which is the second largest element; for example, if the sextuple is (12, 14, 16, 18, 20, 22), they took the number 14).
    \end{itemize}
    What is the recurrence formula describing the running time?
    \begin{enumerate}
        \item The algorithm cannot be applied to sextuples.
        \item \( T(n) \leq T(9n/10) + O(n) \)
        \item \( T(n) \leq T(3n/5) + T(3n/5) + O(n) \)
        \item \( T(n) \leq T(3n/5) + T(n/6) + O(n) \)
        \item \( T(n) \leq T(5n/6) + T(n/6) + O(n) \)
        \item \( T(n) \leq T(5n/6) + T(5n/6) + O(n) \)
        \item No answer is correct.
    \end{enumerate}
\end{itemize}",5,na,7,m,tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
- חלק מערך לחמישיות.
- מיין כל חמישייה.
- מצא חציון חציוני החמישיות על-ידי select (סמן אותו ב-x).
- בצע partition על המערך לפי x (סמן m המקום אליו x הגיע).
- אם i=m, החזר x. אחרת, אם i<m המשך רקורסיבית על חלק שמאל עם i, אחרת המשך רקורסיבית עם חלק ימין עם i.

סטודנט מימש את האלגוריתם, אך ביצע את השינויים הבאים בצעדים 1-3 של האלגוריתם:
- במקום חמישיות הוא עבד עם שישיות.
- במקום חציון של שישיה הוא לקח את האיבר ה-1/3 בגודלו (שזה האיבר השני בגודלו, לדוגמה אם השישיה היא (12 14 16 18 20 22) אז הוא לקח את המספר 14). 
מה נוסחת הנסיגה המתארת את זמן הריצה?
1. לא ניתן להפעיל את האלגוריתם על שישיות.
2. T(n) <= T(9n/10) + O(n)
3. T(n) <= T(3n/5) + T(3n/5) + O(n)
4. T(n) <= T(3n/5) + T(n/6) + O(n)
5. T(n) <= T(5n/6) + T(n/6) + O(n)
6. T(n) <= T(5n/6) + T(5n/6) + O(n)
7. אף תשובה לא נכונה",na,,,,hand-written answer exists
C,FALSE,2015,b,b,9,T3/ds15bb-sol(vaad).pdf,TAU,4,"\textbf{Reminder of the SELECT(i) algorithm for finding the i-th largest element:}
\begin{itemize}
    \item Divide the array into groups of five.
    \item Sort each group.
    \item Find the median of the medians of the groups by using the \texttt{select} function (label it as \(x\)).
    \item Perform a partition on the array based on \(x\) (label \(m\) as the position to which \(x\) moved).
    \item If \(i = m\), return \(x\). Otherwise, if \(i < m\), continue recursively on the left side with \(i\); otherwise, continue recursively on the right side with \(i\).
\end{itemize}

A student implemented the algorithm but made the following modifications in steps 1-3 of the algorithm:
\begin{itemize}
    \item Instead of working with groups of five, he used groups of six.
    \item Instead of finding the median of each group, he selected the \(1/3\)-th largest element (which is the second largest element; for example, if the group is \( (12, 14, 16, 18, 20, 22) \), he chose \(14\)).
\end{itemize}

What is the runtime, and does the algorithm guarantee a correct result?
\begin{enumerate}
    \item \(O(n)\), and the algorithm is correct.
    \item \(O(n \log n)\), and the algorithm is correct.
    \item \(O(n^2)\), and the algorithm is correct.
    \item \(O(n)\), and the algorithm is incorrect.
    \item \(O(n \log n)\), and the algorithm is incorrect.
    \item \(O(n^2)\), and the algorithm is incorrect.
    \item Infinite runtime, and the algorithm is incorrect.
\end{enumerate}",2,na,7,m,tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
- חלק מערך לחמישיות.
- מיין כל חמישייה.
- מצא חציון חציוני החמישיות על-ידי select (סמן אותו ב-x).
- בצע partition על המערך לפי x (סמן m המקום אליו x הגיע).
- אם i=m, החזר x. אחרת, אם i<m המשך רקורסיבית על חלק שמאל עם i, אחרת המשך רקורסיבית עם חלק ימין עם i.

סטודנט מימש את האלגוריתם, אך ביצע את השינויים הבאים בצעדים 1-3 של האלגוריתם:
- במקום חמישיות הוא עבד עם שישיות.
- במקום חציון של שישיה הוא לקח את האיבר ה-1/3 בגודלו (שזה האיבר השני בגודלו, לדוגמה אם השישיה היא (12 14 16 18 20 22) אז הוא לקח את המספר 14). 
מה זמן הריצה והאם האלגוריתם בוודאות יוציא תוצאה נכונה?
1. O(n), והאלגוריתם נכון.
2. O(n log n), והאלגוריתם נכון.
3. O(n^2), והאלגוריתם נכון.
4. O(n), והאלגוריתם שגוי.
5. O(n log n), והאלגוריתם שגוי.
6. O(n^2), והאלגוריתם שגוי.
7. זמן הריצה אינסופי והאלגוריתם שגוי.",na,,,,hand-written answer exists
C,FALSE,2015,b,b,10,T3/ds15bb-sol(vaad).pdf,TAU,4,na,2,na,5,"e,f",untested,,"נתון מערך עם N מפתחות שונים זה מזה. המטרה היא ליצור עץ חיפוש בינארי שיחזיק את המפתחות, ושיתמוך אחר כך בפעולות חיפוש בלבד (ללא מחיקה או הוספה). נתון שמספר המפתחות הוא בדיוק N = 2^k - 1, עבור מספר שלם k כלשהו, ומעוניינים לבנות עץ חיפוש בינארי מאוזן לחלוטין (כלומר, שכל המסלולים מהשורש לעלה הם באותו אורך). בניית העץ:
1. ניתן לבצע בסיבוכיות זמן O(N).
2. ניתן לבצע בסיבוכיות זמן O(N log N).
3. ניתן לבצע בסיבוכיות זמן O(N^2).
4. לא בהכרח ניתן לבנות עץ חיפוש בינארי שהוא מאוזן לחלוטין.
5. אף אחת מהתשובות אינה נכונה.",na,,,,hand-written answer exists
C,FALSE,2015,b,b,11,T3/ds15bb-sol(vaad).pdf,TAU,4,"Given a perfectly balanced binary search tree with \( N = 2^k - 1 \) distinct keys. After constructing the tree, a hacker managed to change one of the keys to another arbitrary value. In the worst case, what is the number of keys \( x \) in the tree for which the function \( \text{Find}(x) \) will mistakenly indicate they are not in the tree? (Provide the most accurate answer possible)
\begin{enumerate}
    \item At most \( N - 1 \) errors.
    \item At most \( \left\lfloor \frac{N}{2} \right\rfloor + 1 \) errors.
    \item At most \( k \) errors.
    \item At most \( k - 1 \) errors.
    \item At most one error.
\end{enumerate}",2,na,5,"e,f",tested,,"נתון עץ חיפוש בינארי מאוזן לחלוטין בעל N = 2^k - 1 מפתחות שונים זה מזה. לאחר בניית העץ, האקרית הצליחה לשנות את אחד המפתחות בעץ לערך אחר שרירותי. במקרה הגרוע ביותר, מהו מספר המפתחות x בעץ, עבורם הפונקציה Find(x) תגיד בשוגג כי אינם נמצאים בעץ? (ענה/י את התשובה המדויקת ביותר האפשרית)
1. לכל היותר N - 1 שגיאות.
2. לכל היותר ⌊N/2⌋ + 1 שגיאות.
3. לכל היותר k שגיאות.
4. לכל היותר k - 1 שגיאות.
5. לכל היותר שגיאה אחת.",na,,,,hand-written answer exists
C,FALSE,2015,b,b,12,T3/ds15bb-sol(vaad).pdf,TAU,6,"\[
\text{Given a red-black tree with } N \text{ keys that are different from each other. In this question, it is not assumed that the tree is completely balanced. Now, it is given that a hacker managed to change the key located at the root of the tree to a key with a value that is larger than all the values of the keys in the tree. In the most optimistic case, what is the minimal possible number of keys } x \text{ in the tree for which the function } \text{Find}(x) \text{ will mistakenly report that they are not in the tree? (In other words, for any red-black tree with } N \text{ elements and such a change by the hacker, there will be at least this number of elements for which Find responds incorrectly). Provide the most accurate answer.}
\]

\begin{enumerate}
    \item \(\Omega(1)\) \text{ errors will necessarily be obtained.}
    \item \(\Omega(\log N)\) \text{ errors will necessarily be obtained.}
    \item \(\Omega(\sqrt{N})\) \text{ errors will necessarily be obtained.}
    \item \(\Omega(N)\) \text{ errors will necessarily be obtained.}
    \item \text{It is possible that no errors will be obtained at all.}
\end{enumerate}",4,na,5,f,tested,,"נתון עץ אדום-שחור בעל N מפתחות שונים זה מזה. בשאלה זו לא מניחים כי העץ מאוזן לחלוטין. כעת נתון כי האקרית הצליחה לשנות את המפתח הנמצא בשורש העץ למפתח בעל ערך שגדול יותר מכל ערכי המפתחות בעץ. במקרה האופטימי ביותר, מהו המספר המינימלי האפשרי של מפתחות x בעץ, עבורם הפונקציה Find(x) תגיד בשוגג כי אינם נמצאים בעץ? (כלומר, לכל עץ אדום-שחור בעל N איברים, ושינוי כזה של ההאקרית, יהיו לפחות מספר כזה של איברים עבורם Find עונה שגיאה). ספקו את התשובה ההדוקה ביותר.
1. יתקבלו בהכרח Ω(1) שגיאות.
2. יתקבלו בהכרח Ω(log N) שגיאות.
3. יתקבלו בהכרח Ω(√N) שגיאות.
4. יתקבלו בהכרח Ω(N) שגיאות.
5. ייתכן ולא יתקבלו שגיאות בכלל.",na,,,,"hand-written answer exists
classified red-black trees as f"
A,FALSE,2017,b,b,1-a,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- DoesIntersect – מחזיר כן אם ל-A ול-B יש חיתוך לא ריק, כלומר יש מספר שנמצא בשניהם] ואם החיתוך ריק מחזיר לא.

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

1. תאר מבנה נתונים דטרמיניסטי התומך בפעולות InsertA,InsertB,DeleteA,DeleteB ו-DoesIntersect. על זמן הריצה של כל הפעולות אלו להיות O(logn) במקרה הגרוע.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,1-b,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- DoesIntersect – מחזיר כן אם ל-A ול-B יש חיתוך לא ריק, כלומר יש מספר שנמצא בשניהם] ואם החיתוך ריק מחזיר לא.

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

2. תאר מבנה נתונים עבורו זמן הריצה של כל הפעולות מסעיף א׳ הוא O(1) בתוחלת. אפשר להניח בסעיף זה שהתבצעו לכל יותר N פעולות על מבנה הנתונים, כאשר N פרמטר שידוע למבנה הנתונים. מותר בשאלה לאתחל מערך ריק בגודל N ב-O(1).",na,,,,hand-written answer exists
A,FALSE,2017,b,b,1-c,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- DoesIntersect – מחזיר כן אם ל-A ול-B יש חיתוך לא ריק, כלומר יש מספר שנמצא בשניהם] ואם החיתוך ריק מחזיר לא.

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.
3. נשנה בסעיף זה בלבד את Init בצורה הבאה: Init(Arr) – מאתחל את A להיות קבוצה ריקה, ומאתחל את B להיות קבוצת המספרים שנמצאים במערך Arr. תאר מבנה נתונים התומך ב-InsertA,DeleteA ו-DoesIntersect בלבד (B אינו משתנה במהלך ריצת האלגוריתם). על זמן הריצה של כל הפעולות הללו להיות O(1) במקרה הגרוע. על Init לקחת O(k) זמן בתוחלת, כאשר k זה גודל המערך ש-B אותחל בעזרתו.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,1-d,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- DoesIntersect – מחזיר כן אם ל-A ול-B יש חיתוך לא ריק, כלומר יש מספר שנמצא בשניהם] ואם החיתוך ריק מחזיר לא.

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

4. (ללא קשר לסעיף ג׳ – Init מוגדר כבתחילת השאלה) מספר x הוא פסאודו-חציון של קבוצה A אם בדיוק חצי מהאיברים ב-A קטנים ממנו ובדיוק חצי מהאיברים גדולים ממנו (x לא בהכרח נמצא בתוך A ולכן הוא לא בהכרח חציון אמיתי של A). תאר מבנה נתונים התומך בפעולות InsertA,InsertB,DeleteA,DeleteB, ובנוסף תומך בפעולת B-Has-Pseudo-Median-Of-A, שמחזיר כן אם קיים x ב-B כך ש-x פסאודו-חציון של A. על כל הפעולות האלו לקחת O(logn) זמן במקרה הגרוע. ניתן להניח שהפעולה החדשה מופעלת רק כאשר מספר האיברים ב-A זוגי.",na,,,,
A,FALSE,2017,b,b,2-a,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- ClosestPair – מחזיר מספר x מ-A ומספר y מ-B כך שהמרחק בערך מוחלט |x-y| מינימלי (אם יש יותר מזוג אחד כזה, ניתן להחזיר זוג מינימלי כלשהו).

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

1. תאר מבנה נתונים התומך בפעולות InsertA,InsertB ו-ClosestPair בלבד, כך שזמן הריצה של פעולות InsertA,InsertB הוא O(logn) במקרה הגרוע, ושל ClosestPair הוא O(1) במקרה הגרוע.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,2-b,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- ClosestPair – מחזיר מספר x מ-A ומספר y מ-B כך שהמרחק בערך מוחלט |x-y| מינימלי (אם יש יותר מזוג אחד כזה, ניתן להחזיר זוג מינימלי כלשהו).

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

2. הראה כי לא ניתן לממש מבנה נתונים התומך בכל פעולות InsertB,DeleteA,InsertA ו-ClosestPair בזמן ריצה של O(loglogn) לכל אחת מהפעולות.
",na,,,,
A,FALSE,2017,b,b,2-c,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- ClosestPair – מחזיר מספר x מ-A ומספר y מ-B כך שהמרחק בערך מוחלט |x-y| מינימלי (אם יש יותר מזוג אחד כזה, ניתן להחזיר זוג מינימלי כלשהו).

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

3. נגדיר פעולת FarthestPair שמחזירה איבר x מ-A ואיבר y מ-B כך שהמרחק בערך מוחלט בין x ל-y הוא הגדול ביותר (אם יש יותר מזוג אחד כזה, ניתן להחזיר זוג מקסימלי כלשהו). תאר מבנה נתונים התומך בפעולות InsertA,InsertB ו-FarthestPair (ללא פעולת מחיקה), כאשר זמן הריצה של כל הפעולות אלו הוא O(1) במקרה הגרוע.
",na,,,,
A,FALSE,2017,b,b,2-d,T3/ds17BB sol 85(vaad).pdf,TAU,7,na,na,na,na,na,na,,"בשאלה זאת נתון מבנה נתונים S שמתחזק שתי קבוצות של מספרים A,B ונדון במבני נתונים התומכים בחלק או בכל הבאות:
- Init – מאתחל את A, B להיות קבוצות ריקות.
- InsertA(x) – מוסיף את המספר x ל-A.
- DeleteA(x) – מוחק את המספר x מ-A (ניתן להניח ש-x נמצא ב-A לפני הפעולה, ניתן פוינטר ל-x בקלט).
- InsertB(x) – מוסיף את המספר x ל-B.
- DeleteB(x) – מוחק את המספר x מ-B (ניתן להניח ש-x נמצא ב-B לפני הפעולה, ניתן פוינטר ל-x בקלט).
- ClosestPair – מחזיר מספר x מ-A ומספר y מ-B כך שהמרחק בערך מוחלט |x-y| מינימלי (אם יש יותר מזוג אחד כזה, ניתן להחזיר זוג מינימלי כלשהו).

בכל הסעיפים n מוגדר להיות n=|A|+|B| (סכום גדלי הקבוצות) ברגע זה.

4. נשנה בסעיף זה בלבד את Init בצורה הבאה: Init(Array) – מאתחל את A להיות קבוצה ריקה, ומאתחל את B להיות קבוצת המספרים שנמצאים במערך Array. תאר מבנה נתונים רנדומלי התומך בפעולות InsertA,DeleteA ו-ClosestPair בלבד (B אינו משתנה במהלך ריצת האלגוריתם). על InsertA,DeleteA לקחת O(logn) במקרה הגרוע, ועל ClosestPair לקחת O(1) במקרה הגרוע, כאשר k זה גודל המערך ש-B אותחל בעזרתו.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,3-a,T3/ds17BB sol 85(vaad).pdf,TAU,7,na,na,na,na,na,na,," נתון מערך בגודל n, כאשר n=3^k. תאר אלגוריתם דטרמיניסטי שמחזיר בזמן נמוך ככל האפשר רשימה של כל האיברים שדרגתם (rank) היא מהצורה (2/3)^i n עבור i=1,2,3,…,n, ונתח את סיבוכיותו. תזכורת: איבר הוא בעל דרגה r אם הוא האיבר ה-r בגודלו. כלומר איבר בעל rank n הוא המינימום, ואיבר בעל rank 1 הוא המקסימום. ניתן להניח שבמערך אין שני איברים זהים, כך שהדרגה של איבר מוגדרת היטב.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,3-b,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,," עבור n חזקה של 2 נתונים logn-1 מערכים ממוינים באורכים 1,2,4,8,…,n/2 בהתאמה (סה״כ n-1 איברים). תארו אלגוריתם דטרמיניסטי המחזיר את כל האיברים שדרגתם (rank) מהצורה 3mod7 – כלומר את האיבר ה-3 בגודלו, ה-10 בגודלו, ה-17 בגודלו וכן הלאה, בזמן הנמוך ככל האפשר ונתח את סיבוכיותו.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,3-c,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,,נתונים n/logn מערכים ממוינים עם logn איברים בכל אחד. האם ניתן למזג אותם למערך ממוין הכולל את כל n האיברים ב-o(nlogn) זמן? (כאן o(nlogn) מייצג את הסימון ל-״זניח אסימפטוטית״ ביחס ל-nlogn).,na,,,,
A,FALSE,2017,b,b,3-d,T3/ds17BB sol 85(vaad).pdf,TAU,6,na,na,na,na,na,na,," נתונים logn מערכים ממוינים עם n/logn איברים בכל אחד. הצע אלגוריתם המחזיר בזמן נמוך ככל האפשר מערך ממוין של כל n האיברים, ונתח את סיבוכויותו.",na,,,,hand-written answer exists
A,FALSE,2017,b,b,4-a,T3/ds17BB sol 85(vaad).pdf,TAU,10,na,na,na,na,na,na,,"במחשב נמצאים מספר רב של דפים על הדיסק. למחשב מגיע זרם של בקשות לדפים השונים. כדי לאפשר גישה מהירה לדפים, לרשותנו זיכרון מטמון בגודל n דפים ובו אנו שומרים את הדפים הטריים ביותר, כלומר אלו שנתבקשו לאחרונה (מודל LRU). דוגמא: n=4. לאחר זרם הבקשות 6,5,9,4,5,4,7 יכיל ה-cache את הדפים 7,4,5,9 כאשר 7 הוא הטרי ביותר ו-9 הוא העבש ביותר. אם הבקשה הבאה היא לדף 3 אז 9 יפונה מה-cache.

א. עליכם לממש מבנה נתונים לשמירת ה-cache התומך בפקודות הבאות:
- Init(n) – אתחול המבנה עם n מקומות לדפים וללא בקשות. על הפקודה לרוץ בזמן O(1). מותר לאתחל מערך ריק בגודל n ב-O(1).
- Access(x) – גישה לדף x. אם הדף x כבר נמצא במבנה, המבנה מעודכן כך ש-x הופך לטרי ביותר; אחרת, יש להכניס את x כדף הטרי ביותר ולפנות את הדף העבש ביותר (אם צריך). על הפקודה לרוץ בזמן O(1) בתוחלת.
",na,,,,hand-written answer exists
A,FALSE,2017,b,b,4-b,T3/ds17BB sol 85(vaad).pdf,TAU,10,na,na,na,na,na,na,,"ב. נעדכן כעת את המתודה Access. מעתה לכל דף x נשמור גם זמן TTL (time to leave) שבו הדף כבר לא יהיה בתוקף. בכל פעם שנרצה להוסיף דף חדש ל-cache יש תחילה להוציא ממנו את כל הדפים שפג תוקפם (שזמן ה-TTL שלהם חלף) ואם עדיין אין מקום ב-cache לדף החדש אז יש להוציא מבין הדפים שנשארו את הדף העבש ביותר. רק לאחר מכן ניתן להכניס דף חדש ל-cache. מעתה, כל גישה לדף x תלווה בשני מספרים:
- Init(n) – אתחול המבנה עם n מקומות לדפים וללא בקשות. על הפקודה לרוץ בזמן O(1). מותר לאתחל מערך ריק בגודל n ב-O(1).
- Access(x, time_now, time_to_leave) – גישה לדף x. בעת הגישה צריך תחילה להוציא מה-cache את כל הדפים שפג תוקפם (TTL שלהם קטן מ-time_now). לאחר מכן, אם x עדיין ב-cache, נעדכן את x להיות הדף הטרי ביותר שניגשנו אליו, אך לא נשנה את הזמן TTL של x. אם x אינו ב-cache, אז יש להוציא את הדף העבש ביותר מה-cache ולהכניס את x במקומו ולעדכן זמן TTL עבור x להיות time_to_leave.
",na,,,,hand-written answer exists
A,FALSE,2017,b,b,4-c,T3/ds17BB sol 85(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ג. תארו מבנה נתונים שעבורו time_to_leave הינו מספר שלם בתחום [now, now+10]. מה זמן הריצה של Access כעת?",na,,,,hand-written answer exists
A,TRUE,2014,a,a,1-a,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בB-trees- עם דרגה מינימאלית d (לכל צומת פנימי בין d ל-2d ילדים) כמות המידע הנשמרת בעלים קטנה יותר מכיוון שאין צורך לשמור שם מצביעים לילדים. נניח ש- block על הדיסק גדול מספיק להכיל צומת בגודל מקסימאלי ושכל צומת מאוכסן ב-block נפרד על הדיסק.
על מנת לנצל את המקום הפנוי ב-block disk המכיל עלה נשנה את הגדרת העץ ונקבע שבכל עלה יהיו בין 2d-1 ל-4d-1 אלמנטים במקום בין d-1 ל-2d-1. נתון שגודל אלמנט הוא כגודל מצביע, ולכן עלה מוגדל כזה עדיין נכנס ב-block. כל עוד אין בעץ יותר מ-4d אלמנטים העץ מורכב מעלה מוגדל בודד.
נקרא לעץ כזה עץ B-tree עם עלים מוגדלים.
א. מהו המספר המינימאלי והמקסימלי של אלמנטים בעלים של B-tree עם עלים מוגדלים בגובה h? מהו המספר המינימאלי והמקסימלי של אלמנטים בצמתים הפנימיים של B-tree עם עלים מוגדלים בגובה h? תן חסמים מדוייקים (לא אסימפטוטיים). נמק תשובתך.","מספר מינימלי של עלים: 2d^(h-1) (לשורש מינימום שני עלים)
מספר מקסימלי של עלים: (2d)^h
מספר מינימלי של איברים בעלים: 2d^(h-1)(2d-1)
מספר מקסימלי של איברים בעלים: (2d)^h(4d-1) (ניקוד מלא ניתן להכפלה לפני השינוי ב-2d וב-4d)
מספר מינימלי של איברים בצמתים הפנימיים: 2d^(h-1)-1
מספר מקסימלי של איברים בצמתים הפנימיים: (2d)^h-1",,,,"The entire question is 30.00 points, but I don’t know how it's splitted between a-e"
A,TRUE,2014,a,a,1-b,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,תאר בקצרה אלגוריתם להכנסה top-down (האלגוריתם לא משנה את העץ לאחר הכנסת האיבר לעלה המתאים אלא רק תוך כדי החיפוש) ל-B-tree עם עלים מוגדלים כמתואר לעיל.,"מחפשים את מיקום האיבר החדש בעץ החל מהשורש. בכל פעם שיורדים בדרך לצומת מלאה (צומת המכיל 2d בנים) מפצלים אותו, כך שלא תיווצר שרשרת פיצולים כאשר נגיע לעלה. כאשר מגיעים
לעלה מכניסים את האיבר כרגיל, בשלב זה עשוי להיגרם פיצול אחד לכל היותר.",,,,total points: 30.00 
A,TRUE,2014,a,a,1-c,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,מהי סיבוכיות הזמן וה-IO של האלגוריתם שתיארת במקרה הגרוע? (סיבוכיות IO = מספר גישות לבלוקים שונים). הצג באופן מפורש את תלות הביטוי ב-d ונמק את תשובתך.,"סיבוכיות זמן: O(d log_d(n)), יש log_d(n) רמות ובכל רמה עשוי להתרחש פיצול שלוקח O(d).
סיבוכיות IO: O(log_d(n)), בכל רמה ניגשים למספר קבוע של בלוקים.",,,,total points: 30.00 
A,TRUE,2014,a,a,1-d,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,מבצעים סדרה של m הכנסות לB-tree עם עלים מוגדלים עם פרמטר d ריק בתחילה. תן חסם (אסימפטוטי) הדוק ככל שתוכל על מספר פעולות הsplit שמתבצעות במהלך הסדרה. (להזכירך פעולת split מחלקת צומת בגודל מקסימלי לשני צמתים בגודל מינימאלי) . נמק תשובתך.,"החסם הוא .O(m)
ניתן להוכיח ע""י פונקצית פוטנציאל בדומה ל B-Tree רגיל.
מאחר ומתבצעות רק הכנסות ניתן גם לכתוב שמספר הצמתים הוא מספר הפיצולים שהיו ולחסום אותו מלמעלה ע""י O(m/d) על פי גודל הצמתים.",,,,total points: 30.00 
A,TRUE,2014,a,a,1-e,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"נתונים B-trees עם עלים מוגדלים T1 ו-T2 כמתואר לעיל ואיבר נוסף z. נתון כי כל האיברים ב-T1 קטנים מ-z וכל האיברים ב-T2 גדולים מ-z. תאר (בקצרה) ממוש פעולת שרשור concat(T1, z, T2) שמחזירה עץ אחד שמכיל את כל האיברים ב-T1, T2 ו-z. כמה זמן לוקח לבצע את הפעולה כפונקציה של מספר האיברים n1 ב-T1 ומספר האיברים n2 ב-T2? (הנח כי בשורש כל עץ שומרים את גובהו)","נסמן h1 = T1 ו-h2 = T2. נניח ש-h1 > h2 והמקרה ההפוך סימטרי: מטיילים ב-T1 על הענף הימני ביותר עד שמגיעים לגובה h2 + 1. מוסיפים את z כאיבר הימני ביותר של הצומת הימני ביותר, ואת השורש של T2 כבן הימני שלו, ומבצעים תיקונים כנדרש.
סה""כ סיבוכיות זמן היא O(log(n1) - log(n2)) = O(h1 - h2) גם עבור הטיול בעץ וגם עבור הפיצולים הנדרשים.",,,,total points: 30.00 
A,TRUE,2014,a,a,2-a,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,משתמשים באלגוריתם rand-quicksort שנלמד בכיתה לצורך מיון מערך בגודל .n מהי תוחלת מספר המספרים המקריים שמוגרלים על ידי האלגוריתם (תן חסם אסימפטוטי). נמק.,"מספר המספרים האקראיים המוגרלים הוא תמיד מסדר גודל של n, ולכן התוחלת היא גם n. הסיבה: (נניח כל האיברים שונים זה מזה) בכל שלב שנבחר פיבוט, יורד איבר אחד מסך האיברים שממשיכים עליהם. לכן, עד שמגיעים לגודל קלט קבוע, מספר הפיבוטים שמוגרלים הוא לינארי ב-n.",,,,total points: 20.00 
A,TRUE,2014,a,a,2-b,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,משתמשים באלגוריתם rand-partition שתואר בכיתה בכדי לחלק מערך בגודל n. (כזכור האלגוריתם מחליף את האיבר האחרון במערך עם איבר מקרי ומשתמש בו כאיבר pivot). מה ההסתברות המדויקת שהחלק הקטן בחלוקה מכיל פחות מ-k איברים? (ניתן להניח שכל איברי המערך שונים זה מזה וכן ש-k < n/2). נמק/י תשובתך.,.2k/n,,,,total points: 20.00 
A,TRUE,2014,a,a,2-c,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"נגדיר אלגוריתם חלוקה חדש new-rand-partition שמפעיל את rand-partition שוב ושוב עד שהחלק הקטן בחלוקה מכיל לפחות n/5 איברים. (במידה והחלוקה שנוצרת ע""י קריאה מסוימת ל-rand-partition לא מקיימת את התנאי, מתעלמים מהחלוקה וקוראים ל-rand-partition שוב). מה תוחלת מספר ההשוואות שמבוצעות ע""י האלגוריתם new-rand-partition? מה מספר ההשוואות במקרה הגרוע ביותר? (תן/י תשובות לא אסימפטוטית מדויקות ככל האפשר). נמק/י את תשובתך.","המקרה הגרוע לא חסום, כי אפשר להגריל אינסוף פעמים ותמיד החלוקה לא מקיימת את התנאי. ההסתברות להצלחה (חלוקה המקיימת את התנאי) היא 3/5 (לפי סעיף ב'). זה משתנה גיאומטרי והתוחלת שלו 5/3, כלומר תוך 5/3 הגרלות בתוחלת תמצא חלוקה טובה. מספר ההשוואות בכל הגרלה הוא n, ולכן תוחלת מספר ההשוואות היא 5n/3.",,,,total points: 20.00 
A,TRUE,2014,a,a,2-d,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"נגדיר אלגוריתם מיון חדש new-rand-quicksort שמשתמש באלגוריתם החלוקה החדש new-rand-partition. מה תוחלת מספר ההשוואות שמבוצעות ע""י האלגוריתם new-rand-quicksort? (תשובה אסימפטוטית מספיקה). נמק/י את תשובתך.","הרבה תשובות טענו ""זה כמו quicksort"" וזה לא נכון. ב-QS מספר ההשוואות ברמה הוא תמיד n, ומספר הרמות בתוחלת הוא O(log n). לעומת זאת, כאן מספר ההשוואות ברמה בתוחלת הוא לינארי ב-n, ואילו מספר הרמות הוא תמיד O(log n) כי החלוקה מבטיחה שיש לפחות חלק קטן בגודל לפחות n/5 וזה חוסם את מספר הרמות ב-log n לפי בסיס 5/4. דרך נוספת להוכיח על-ידי נוסחת נסיגה למספר ההשוואות בתוחלת ולפתור אותה על-ידי משפט המסטר (צריך להראות איזה מקרה זה) או עץ רקורסיה.",,,,total points: 20.00 
A,TRUE,2014,a,a,3-a,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"הכניסו קבוצת איברים X1 בגודל n1 לטבלת hashing בגודל m שמשתמשת בשיטת ה-chaining תוך שימוש בפונקצית hashing h. כל הרשימות המקושרות שהתקבלו היו באורך של לכל היותר k1. הכניסו עתה קבוצת איברים שניה X2 בגודל n2 לטבלת hashing אחרת בגודל m שמשתמשת אף היא בשיטת ה-chaining תוך שימוש באותה פונקצית hashing h. כל הרשימות המקושרות שהתקבלו היו באורך של לכל היותר k2. לבסוף הכניסו את כל איברי X1 ו-X2, בסדר כלשהו, לטבלת hashing שלישית בגודל m, שוב תוך שימוש בשיטת ה-chaining ועם אותה פונקציה h. תן/י חסם, לא אסימפטוטי, טוב ככל האפשר על מספר המפתחות שיבחנו בעת פעולת חיפוש (מוצלח או לא מוצלח) בטבלת ה-hashing השלישית. נמק/י.","מספר המפתחות שיבחנו בעת פעולת חיפוש הוא בדיוק אורך הרשימה.
ברשימה אחת יהיו לכל היותר k1+k2 איברים, לכן זהו המספר המקסימלי של מפתחות שייבחנו בעת חיפוש כלשהו.",,,,total points: 20.00 
A,TRUE,2014,a,a,3-b,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"הכניסו קבוצת איברים X1 בגודל n1 לטבלת hashing בגודל m שמשתמשת בשיטת ה-linear probing תוך שימוש בפונקצית hashing h. כל חיפוש בטבלה שהתקבלה דרש קריאה של לכל היותר k1 תאים בטבלה. הכניסו קבוצת איברים שניה X2 בגודל n2 לטבלת hashing שניה בגודל m שמשתמשת בשיטת ה-linear probing תוך שימוש באותה פונקצית ה-hashing h. כל חיפוש בטבלה שהתקבלה דרש קריאה של לכל היותר k2 תאים בטבלה. לבסוף הכניסו את כל איברי X1 ו-X2 לטבלת hashing שלישית בגודל m, שוב תוך שימוש בשיטת ה-linear probing ועם אותה פונקציה h. כל איברי X1 הוכנסו לטבלה לפני כל איברי X2. הסדר שבו הוכנסו איברי X1 ו-X2 לטבלה השלישית לא זהה בהכרח לסדר שבו הם הוכנסו לשתי הטבלאות הראשונות. נתון ש-n1+n2<m. תן/י חסם, לא אסימפטוטי, טוב ביותר על מספר התאים שיקראו בחיפוש של איבר מ-X1, של איבר מ-X2, ושל איבר שאינו ב-X1 ואינו ב-X2. (תן/י שלושה חסמים שונים סך הכל). נמק/י.","הערה: אם כל חיפוש בטבלה, כולל חיפוש לא מוצלח, דורש קריאה של לכל היותר k תאים אזי חיפוש של איבר שנמצא בטבלה דורש קריאה של לכל היותר k-1 תאים. איברי X1 יהיו באותו מקום שהיו בטבלה הראשונה, לכן חיפוש של איבר מ-X1 ידרוש קריאה של לכל היותר k1-1 תאים. איברים מ-X2 יכולים למלא את כל ה""חורים"" בין איברי X1, לכן: חיפוש של איבר מ-X2: n1+n2 חיפוש של איבר שאינו נמצא בטבלה: n1+n2+1",,,,total points: 20.00 
A,TRUE,2014,a,a,3-c,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"הנתונים הם כמו בסעיף ב אלא שהפעם הכניסו את כל איברי X1 ו-X2 לטבלת ה-hashing השלישית בגודל m תוך שימוש בשיטת ה-chaining ועם אותה פונקציה h. כל איברי X1 הוכנסו לטבלה לפני כל איברי X2. הסדר שבו הוכנסו איברי X1 ו-X2 לטבלה השלישית לא זהה בהכרח לסדר שבו הם הוכנסו לשתי הטבלאות הראשונות. תן/י חסם, לא אסימפטוטי, טוב ביותר על מספר המפתחות שיבחנו בעת חיפוש של איבר מ-X1, של איבר מ-X2, ושל איבר שאינו ב-X1 ואינו ב-X2 (תן/י שלושה חסמים שונים סך הכל). נמק/י.","למספר הערכים בכל רשימה חסום ע""י מספר התאים שנדרש לקרוא מן הטבלה (מינוס אחד כי חיפוש לא מוצלח ידרוש קריאה של תא ריק), לכן:
חיפוש איבר מ-X1 ידרוש קריאה של לכל היותר k1-1 מפתחות.
חיפוש איבר מ-X2 ידרוש קריאה של לכל היותר (k1-1)+(k2-1), כלומר k1+k2-2 מפתחות (אם הרשימות שורשרו לאותו תא).
גם חיפוש איבר שאינו ב-X1 ואינו ב-X2 ידרוש קריאה של לכל היותר k1+k2-2 מפתחות מאחר וזה אורך הרשימה המקסימלי.",,,,total points: 20.00 
A,TRUE,2014,a,a,3-d,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"חזרו שוב על הפעולות שתוארו בסעיף ב'. לאחר הכנסת כל איברי X1 ולאחר מכן כל איברי X2 לטבלה השלישית, מחקו מהטבלה את כל איברי X1 בסדר כלשהו, תוך שימוש באלגוריתם המחיקה שמזיז איברים בטבלה כפי שתואר בכיתה. תן/י חסם, לא אסימפטוטי, טוב ביותר על מספר התאים שיקראו בחיפוש של איבר מ-X2 ושל איבר שאינו ב-X2 (תן שני חסמים בסך הכל). נמק/י.","על פי אלגוריתם המחיקה, לאחר המחיקה הטבלה נמצאת באותו מצב שהיתה נמצאת אם האיבר לא היה נכנס מעולם, לכן מצב הטבלה זהה לטבלה שבה הוכנסו רק איברי .X2
לכן חיפוש איבר מ X2 ידרוש קריאה של לכל היותר k2-1 תאים, וחיפוש איבר שאינו ב X2 ידרוש קריאה של לכל היותר k2 תאים.",,,,total points: 20.00 
A,TRUE,2014,a,a,4-a,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"נתון גרף מכוון. הגרף מוגדר על-ידי קבוצה של n צמתים ו-m קשתות. כל קשת היא זוג סדור של צמתים. הקשתות היוצאות מכל צומת מאוכסנות ברשימה מקושרת (singly linked list).

כל צומת v מיוצג על ידי אובייקט שעליו ניתן לעשות את הפעולות הבאות בלבד:
edges(v): מחזירה את רשימת הקשתות שיוצאות מ-v.
נניח כי בגרף n צמתים שכל אחד מזוהה על ידי מספר שלם בין 1 ל-n. הפעולה id(v) מחזירה את המספר המתאים לצומת v.
הגרף כולו מיוצג על ידי מערך בגודל n בו התא id(v) מצביע לאובייקט המייצג את צומת v.

על רשימת קשתות L (היוצאות מצומת מסוים) ניתן לבצע את הפעולות הבאות בלבד:
first(L): מחזירה את הקשת הראשונה ברשימה.
delete-first(L): מסירה את הקשת הראשונה ברשימה.
insert-first(L,e): מכניסה אובייקט המייצג קשת e בתחילת רשימת הקשתות L.
length(L): מחזירה את אורך הרשימה L.
כל קשת e=(v,w) מיוצגת על ידי אובייקט שעליו ניתן לבצע את הפעולות הבאות בלבד:
next(e): מחזיר את הקשת העוקבת ל-e ברשימת הקשתות היוצאות מ-v.
delete-after(e): מסיר את הקשת שאחרי e ברשימת הקשתות שיוצאות מ-v.
source(e): מחזיר את הצומת v ממנו יוצאת e.
target(e): מחזיר את הצומת v אליו נכנסת e.
הפעולות שהוגדרו הן הפעולות היחידות שניתן לעשות על האובייקטים השונים המייצגים את הגרף.

לצורך ניתוח האלגוריתמים נסמן ב-d(v) את מספר הקשתות שיוצאות מ-v.

א. בהינתן שני צמתים v ו-w תאר אלגוריתם יעיל ככל שתוכל שבודק האם יש קשת מ-v ל-w. מה זמן הריצה של האלגוריתם?","עוברים על רשימת הקשתים שיוצאות מ-v ובודקים אם יש קשת (v,w). זמן ריצה O(d(v)).",,,,total points: 30.00 
A,TRUE,2014,a,a,4-b,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בהינתן שני צמתים v ו-w תאר אלגוריתם דטרמניסטי יעיל ככל שתוכל שמחשב כמה שכנים משותפים יש ל-v ו-w, כלומר כמה צמתים x קיימים בגרף עבורן הקשתות (v,x) ו-(w,x) קיימות. ניתן להשתמש בזיכרון נוסף שגודלו פרופורציונאלי ל-d(v)+d(w). מהי סיבוכיות האלגוריתם שתיארת?","נתחזק מילון עם הצמתים שיש קשת מ-v אליהם. נכניס את כל השכנים של v למילון. לאחר מכן, נעבור על השכנים של w, ונבדוק אם השכן נמצא במילון – אם כן, זה שכן משותף. מילון יעיל: עץ חיפוש בינארי מאוזן. עונה על סיבוכיות הגודל. זמן ריצה (d(v) + d(w)) * log(d(v)). אפשר לבחור לעשות זאת על v או על w לפי מי שיש לו פחות צמתים, ואז זמן הריצה (d(v) + d(w)) * log(min(d(v), d(w))).",,,,total points: 30.00 
A,TRUE,2014,a,a,4-c,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"תאר אלגוריתם רנדומי יעיל ככל שתוכל למשימה בסעיף ב, מה סיבוכיות האלגוריתם שתיארת ?",נשתמש במילון .hash ההכנסה וחיפוש ייקחו בתוחלת .d(v)+d(w),,,,total points: 30.00 
A,TRUE,2014,a,a,4-d,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"תאר מימוש יעיל ככל שתוכל של פעולה delete(e) שמסירה את הקשת e מהגרף. גודל הזיכרון בו משתמשים ליצוג הגרף בכל רגע צריך להיות פרופורציונאלי לגודל הגרף באותו רגע. לצורך מימוש delete(e) ניתן להשתמש גם בפעולות הבאות המאפשרות לזכור ביט נוסף עם כל קשת ומספר נוסף עם כל צומת.
set-bit(e,b): זוכר את הביט b עם הקשת e. שדה זה מאותחל ל-0.
get-bit(e): מחזיר את הביט של הקשת e.
set-num(v,n): זוכר את המספר n עם הצומת v. שדה זה מאותחל ל-0.
get-num(v): מחזיר את המספר של הצומת v.
מימוש בזמן amortized O(1) יזכה במלוא הנקודות.
האם הוספת הפעולה delete(e) מצריכה שינוי באלגוריתמים שתיארת בסעיפים הקודמים?","פתרון על-ידי Lazy Deletions in singly linked lists שראיתם בכיתה (מצגת .(amortized הביט הנוסף מאפשר לזכור האם קשת ""מחוקה."" המספר בצומת מאפשר לזכור כמה קשתות מחוקות יש ברשימה.",,,,total points: 30.00 
A,TRUE,2014,a,a,4-e,T3/ds14aa-sol-official(vaad).pdf,TAU,na,na,na,na,na,na,na,,"תאר אלגוריתם יעיל ככל שתוכל שממיין את הקשתות ברשימת הקשתות היוצאות מכל צומת בסדר עולה לפי מספרו של הקדקוד אליו הן נכנסות. מהי סיבוכיות האלגוריתם שתיארת?
ניתן להשתמש במבני נתונים נוספים, סך כל הזיכרון שלהם צריך להיות ליניארי בגודל הגרף, אבל כדי לשנות את הגרף עצמו השתמשו רק בפעולות שהוגדרו בתחילת השאלה.","נמיין את כל הקשתות ביחד בעזרת radix sort. נסתכל על הקשתות כזוג ספרות בסיס n. נמיין על-ידי RS בבסיס n, זמן ריצה m+n. אחרי המיון ניתן להעביר את הקשתות של כל צומת לרשימה שלו ממויינות.",,,,total points: 30.00 
A,TRUE,2016,a,a,1-a,T3/ds16AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) התומך בפעולות הבאות:
insert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). ניתן להניח שהזוג מופיע במבנה הנתונים. על הפעולה להתבצע בזמן O(1) בתוחלת.
SearchAll(a) – החזר רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי בהם. על הפעולה להתבצע בזמן O(1) בתוחלת.","נממש את מבנה הנתונים ע""י hash על המפתח השמאלי a כאשר כל תא בטבלת ה-hash מחזיק רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי שלהם. insert יכניס את האיבר לתחילת הרשימה ו-SearchAll יחזיר את כל הרשימה.",,,,total points: 20.00 
A,TRUE,2016,a,a,1-b,T3/ds16AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"הוסף/י למבנה הנתונים מהסעיף הקודם את הפעולות הבאות:
Delete(a,b) – מחק את זוג המפתחות (a,b) (אם קיים). על הפעולה להתבצע בזמן O(1) בתוחלת.
Search(a,b) – החזר את זוג המפתחות (a,b) אם קיים, אחרת החזר null. על הפעולה להתבצע בזמן O(1) בתוחלת.
שנה את פעולת Insert(a,b) כך שזוג המפתחות (a,b) יתווסף למבנה הנתונים רק אם הוא לא קיים בו. על הפעולות Insert(a,b), SearchAll(a) להתבצע בזמן O(1) בתוחלת.","בנוסף למבנה הנתונים מהסעיף הקודם נחזיק hash על המפתח השמאלי a כשכל תא בטבלת ה-hash מחזיק טבלת hash נוספת על המפתחות הימניים b של הזוגות שמופו לתא.
בנוסף נחזיק פוינטרים בין 2 מבני הנתונים.
Insert יוודא שהאיבר לא קיים בטבלת ה-hash הנוספת, יכניס אותה לטבלת ה-hash ולרשימה בטבלת ה-hash הראשונה.
Delete ימומש בצורה דומה ל-insert.
Search יבדוק האם האיבר קיים בטבלת ה-hash הנוספת. SearchAll ימומש כמו בסעיף הקודם.",,,,total points: 20.00 
A,TRUE,2016,a,a,2-a,T3/ds16AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונים n זוגות של מפתחות (a1,b1), (a2,b2),…, (an,bn), כך שכל מפתח ai וכל מפתח bj (עבור 1≤i,j≤n) הם מספרים שלמים מהתחום [1,10n]. תאר/י מבנה נתונים שניתן לבנות בזמן Worst case O(n) (בהינתן n זוגות המפתחות) ותומך בפעולה הבאה בזמן Worst case O(1):
SearchAll(a) – החזר רשימה של כל זוגות המפתחות ש-a הוא המפתח השמאלי בהם.","נאתחל טבלה עם 10n תאים, כך שהתא ה – i חזיק רשימה של כל זוגות המפתחות ש – i הוא המפתח השמאלי שלהם.",,,,total points: 20.00 
A,TRUE,2016,a,a,2-b,T3/ds16AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"בהמשך לסעיף הקודם, הפעם נתון שכל המפתחות שלמים ומהתחום [1,n^3]. תאר/י מבנה נתונים שניתן לבנות אותו בזמן Worst case O(n) (בהינתן n זוגות המפתחות) ותומך בפעולה SearchAll בזמן Worst case O(log(n)).","נמיין ע""י sort radix את כל הזוגות לפי המפתח השמאלי.
נאתחל מערך בגודל n כך שתא i במערך יחזיק רשימה של כל הזוגות שהמפתח השמאלי שלהם הוא האיבר ה – i בגודלו מבין המפתחות השמאליים.",,,,total points: 20.00 
C,TRUE,2016,a,a,3,T3/ds16AA-sol.pdf,TAU,5,"Given a hash table implemented using the chaining method. The hash is composed of an array with 1,000 cells and currently contains about a million elements. Three operations are performed on it in sequence:
First operation: Adding an element that doesn't exist. Second operation: Deleting a random element that exists in the hash.
Third operation: Adding the element that was deleted in the second operation.
Let the expected running time of operation \(i\) be \(t_i\). What is the ratio between the running times of the 3 operations (assuming a new element is always added to the end of the chain)?
A. \(t_1=t_2=t_3\)
B. \(t_2 \approx 2t_3\), \(t_1=t_2\)
C. \(t_2 \approx t_3\), \(t_1 \approx 2t_2\)
D. \(t_2 \approx 2t_1\), \(t_1=t_3\)
E. None of the answers are correct

Explanation (required):",d,na,6,g,tested,,"נתון hash table הממומש בשיטת ה-chaining. ה-hash מורכב ממערך בגודל 1,000 תאים ויש בו כרגע כמיליון איברים. מבצעים עליו ברצף 3 פעולות:
פעולה ראשונה: הוספת איבר שלא קיים. פעולה שנייה: מחיקת איבר מקרי שקיים ב-hash.
פעולה שלישית: הוספת האיבר שמחקנו בפעולה השנייה.
נסמן את תוחלת זמן הריצה של פעולה i ב-ti. מהו היחס בין זמני הריצה של 3 הפעולות (כאשר איבר חדש מתווסף תמיד לסוף ה-chain)?
א. t1=t2=t3
ב. t2≈2t3 ,t1=t2
ג. t2≈t3 ,t1≈2t2
ד. t2≈2t1 ,t1=t3
ה. אף תשובה לא נכונה

הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,4,T3/ds16AA-sol.pdf,TAU,6,na,b,na,5,i,untested,,"התבקשתם לממש את מבנה הנתונים הבא במודל ההשוואות (n הוא מספר האיברים במבנה הנתונים):
DeleteMin – מחיקת איבר המינימום בזמן אמורטייזד O(logn).
FindMin – החזרת איבר המינימום בזמן אמורטייזד O(1).
Insert(A) – הכנסת איבר A בזמן אמורטייזד O(1).
IncreaseKey(A,x) – הגדלת המפתח של איבר A ב-x בזמן אמורטייזד O(1).

א. ניתן לממש את מבנה הנתונים ע""י שימוש בערימות פיבונאצ'י מסוג מינימום ומקסימום עם פוינטרים ביניהם.
ב. לא ניתן לממש את מבנה הנתונים מאחר וניתן למיין בעזרתו בזמן ליניארי.
ג. ניתן לממש את מבנה הנתונים ע""י שימוש בערימת פיבונאצ'י מסוג מינימום ולממש את IncreaseKey ע""י חיתוך צומת A והוספתו כשורש חדש לערימה (במידה וכלל הערימה הופר).
ד. לא ניתן לממש את מבנה הנתונים אפילו בגירסה מצומצת יותר – ללא פעולת IncreaseKey.
ה. אף תשובה לא נכונה.

הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,5,T3/ds16AA-sol.pdf,TAU,5,"\textbf{Reminder for the SELECT(i) algorithm to find the i-th largest element:}
1. Divide the array into groups of five.
2. Sort each group.
3. Find the median of the medians of the groups by select (denote it by x).
4. Perform a partition on the array according to x (denote m the position where x arrived).
5. If i=m, return x. Otherwise, if i<m continue recursively on the left part with i, otherwise continue recursively on the right part with i-m.

\textbf{A student implemented the algorithm but made the following changes in steps 1-3 of the algorithm:}
1. Instead of groups of five, he worked with groups of seven.
2. In step 3, by mistake, he found the 5/7-th element, meaning instead of finding the median of the medians of the groups of seven, he took the 5/7-th element among the medians, which he found by select.

\textbf{What is the recurrence relation describing the running time?}
A. It is not possible to run the algorithm on groups of seven.
B. \( T(n) \le T\left(\frac{17n}{21}\right) + O(n) \)
C. \( T(n) \le T\left(\frac{25n}{49}\right) + T\left(\frac{4n}{7}\right) + O(n) \)
D. \( T(n) \le T\left(\frac{41n}{49}\right) + T\left(\frac{n}{7}\right) + O(n) \)
E. \( T(n) \le T\left(\frac{25n}{49}\right) + T\left(\frac{n}{7}\right) + O(n) \)
F. \( T(n) \le T\left(\frac{41n}{49}\right) + T\left(\frac{4n}{7}\right) + O(n) \)
G. None of the answers is correct

\textbf{Explanation (required):}",d,na,7,m,tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
1. חלק מערך לחמישיות.
2. מיין כל חמישיה.
3. מצא חציון חציוני החמישיות על-ידי select (סמן אותו ב-x).
4. בצע partition על המערך לפי x (סמן m המקום אליו x הגיע).
5. אם i=m, החזר x. אחרת, אם i<m המשך רקורסיבית על חלק שמאל עם i, אחרת המשך רקורסיבית על חלק ימין עם i-m.

סטודנט מימש את האלגוריתם, אך ביצע את השינויים הבאים בצעדים 1-3 של האלגוריתם:
1. במקום חמישיות הוא עבד עם שביעיות.
2. בשלב 3 בטעות מצא את האיבר ה-5/7, כלומר במקום למצוא את חציון חציוני השביעיות, הוא לקח את האיבר ה-5/7 מבין חציוני השביעיות, שאותו מצא על-ידי select.

מה נוסחת הנסיגה המתארת את זמן הריצה?
א. לא ניתן להפעיל את האלגוריתם על שביעיות.
ב. T(n) ≤ T(17n/21) + O(n)
ג. T(n) ≤ T(25n/49) + T(4n/7) + O(n)
ד. T(n) ≤ T(41n/49) + T(n/7) + O(n)
ה. T(n) ≤ T(25n/49) + T(n/7) + O(n)
ו. T(n) ≤ T(41n/49) + T(4n/7) + O(n)
ז. אף תשובה לא נכונה

הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,6,T3/ds16AA-sol.pdf,TAU,5,"\begin{itemize}
    \item When performing delete on $v$, an internal node in a binary heap, the following actions are taken:
    \begin{enumerate}
        \item Swap $v$ with the rightmost leaf.
        \item Delete the rightmost leaf.
    \end{enumerate}
    What is the next step in the algorithm:
    \begin{enumerate}[label=\alph*.]
        \item This is not the implementation of delete in a binary heap.
        \item In a binary heap, only the minimum element can be deleted.
        \item Always perform Heapify-Up on $v$.
        \item Always perform Heapify-Down on $v$.
        \item Sometimes perform Heapify-Up on $v$ and sometimes Heapify-Down.
        \item None of the answers is correct.
    \end{enumerate}
    Explanation (required):
\end{itemize}",e,na,6,h,tested,,"כאשר מבצעים delete ל-v, צומת פנימי בערימה בינארית מתבצעות הפעולות הבאות:
1. מחליפים את v עם העלה הימני ביותר.
2. מוחקים את העלה הימני ביותר.
מהו השלב הבא באלגוריתם:
א. זהו לא המימוש של delete בערימה בינארית.
ב. בערימה בינארית ניתן למחוק רק את איבר המינימום.
ג. תמיד מבצעים Heapify-Up ל-v.
ד. תמיד מבצעים Heapify-Down ל-v.
ה. לפעמים מבצעים Heapify-Up ל-v ולפעמים Heapify-Down.
ו. אף תשובה לא נכונה.

הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,7,T3/ds16AA-sol.pdf,TAU,6,"\textbf{You were asked to implement the following data structure, assuming that all keys are distinct from each other and $n$ is the number of elements in the data structure:}

\begin{itemize}
    \item \textbf{Insert(a)} - Insert a key $a$ in amortized time $O(\log n)$.
    \item \textbf{Delete(a)} - Delete a key $a$ in amortized time $O(\log n)$.
    \item \textbf{Find(a)} - Find a key $a$ in amortized time $O(\log n)$.
    \item \textbf{Count(a,b)} - Return the number of keys with values between $a$ and $b$.
\end{itemize}

\textbf{Let $x_{a,b}$ be the number of keys between $a$ and $b$. Find the most efficient implementation (in terms of amortized runtime) for Count without affecting the runtimes of the other operations.}

\begin{enumerate}
    \item[(a)] The data structure can be implemented using a red-black tree. Count can be implemented in time $O(x_{a,b} \log n)$ by finding $a$ and applying successor until finding $b$.
    \item[(b)] The data structure can be implemented using a red-black tree. Count can be implemented in time $O(x_{a,b})$ by finding $a$ and applying successor until finding $b$.
    \item[(c)] The data structure can be implemented using a red-black tree with size fields for each node. Count can be implemented in time $O(\log n + x_{a,b})$ by finding $a$ and $b$ and performing a binary search between them in the tree.
    \item[(d)] The data structure can be implemented using a red-black tree with size fields for each node. Count can be implemented in time $O(\log n)$ by finding $a$ and $b$ and looking at the appropriate nodes along the path from the root to $a$ and from the root to $b$.
    \item[(e)] The data structure can be implemented using a red-black tree. Count can be implemented in time $O(n)$ by sorting the tree and finding $a$ and $b$ in the sorted array.
    \item[(f)] The data structure can be implemented using a red-black tree. Count can be implemented in time $O(n \log n)$ by sorting the tree and finding $a$ and $b$ in the sorted array.
    \item[(g)] None of the answers are correct.
\end{enumerate}

\textbf{Explanation including full implementation:}",d,na,7,"b,f",tested,,"התבקשתם לממש את מבנה הנתונים הבא, כשניתן להניח שכל המפתחות שונים זה מזה ו-n הוא מספר האיברים במבנה הנתונים:
Insert(a) – הכנסת מפתח a בזמן אמורטייזד O(logn).
Delete(a) – מחיקת מפתח a בזמן אמורטייזד O(logn).
Find(a) - מציאת מפתח a בזמן אמורטייזד O(logn).
Count(a,b) – החזרת מספר המפתחות בערך בין a ל-b.

יהי xa,b מספר המפתחות בין a ל-b. מצא את המימוש היעיל ביותר (מבחינת זמן ריצה אמורטייזד) ל-Count מבלי לפגוע בזמני הפעולות האחרות.

א. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(xa,b logn) ע""י מציאת a והפעלת successor עד למציאת b.
ב. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(xa,b) ע""י מציאת a והפעלת successor עד למציאת b.
ג. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור עם שדות size לכל צומת. Count ימומש בזמן O(logn+xa,b) ע""י מציאת a ו-b וחיפוש בינארי ביניהם בעץ.
ד. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור עם שדות size לכל צומת. Count ימומש בזמן O(logn) ע""י מציאת a ו-b והסתכלות על הצמתים המתאימים במסלול מהשורש ל-a ומהשורש ל-b.
ה. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(n) ע""י מיון העץ ומציאת a ו-b במערך הממויין.
ו. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(nlogn) ע""י מיון העץ ומציאת a ו-b במערך הממויין.
ז. אף תשובה לא נכונה.

הסבר כולל מימוש מלא:",na,,,,"classified red-black trees as f
אין הסבר"
C,TRUE,2016,a,a,8,T3/ds16AA-sol.pdf,TAU,5,na,c,na,7,a,untested,,"השאלה הקודמת:
התבקשתם לממש את מבנה הנתונים הבא, כשניתן להניח שכל המפתחות שונים זה מזה ו-n הוא מספר האיברים במבנה הנתונים:
Insert(a) – הכנסת מפתח a בזמן אמורטייזד O(logn).
Delete(a) – מחיקת מפתח a בזמן אמורטייזד O(logn).
Find(a) - מציאת מפתח a בזמן אמורטייזד O(logn).
Count(a,b) – החזרת מספר המפתחות בערך בין a ל-b.

יהי xa,b מספר המפתחות בין a ל-b. מצא את המימוש היעיל ביותר (מבחינת זמן ריצה אמורטייזד) ל-Count מבלי לפגוע בזמני הפעולות האחרות.

א. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(xa,b logn) ע""י מציאת a והפעלת successor עד למציאת b.
ב. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(xa,b) ע""י מציאת a והפעלת successor עד למציאת b.
ג. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור עם שדות size לכל צומת. Count ימומש בזמן O(logn+xa,b) ע""י מציאת a ו-b וחיפוש בינארי ביניהם בעץ.
ד. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור עם שדות size לכל צומת. Count ימומש בזמן O(logn) ע""י מציאת a ו-b והסתכלות על הצמתים המתאימים במסלול מהשורש ל-a ומהשורש ל-b.
ה. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(n) ע""י מיון העץ ומציאת a ו-b במערך הממויין.
ו. ניתן לממש את מבנה הנתונים ע""י עץ אדום שחור. Count ימומש בזמן O(nlogn) ע""י מיון העץ ומציאת a ו-b במערך הממויין.
ז. אף תשובה לא נכונה.

בהמשך לשאלה הקודמת התבקשתם להוסיף פעולת Print(a,b) שמדפיסה את כל המפתחות בין a ל-b במימוש היעיל ביותר האפשרי. אין לפגוע בזמני הריצה של הפעולות הקודמות.

א. Print ימומש בזמן O(xa,b logn).
ב. Print ימומש בזמן O(xa,b).
ג. Print ימומש בזמן O(logn+xa,b).
ד. Print ימומש בזמן O(logn).
ה. Print ימומש בזמן O(n).
ו. Print ימומש בזמן O(nlogn).
ז. אף תשובה לא נכונה.

הסבר כולל מימוש מלא:",na,,,,"תלוי בשאלה הקודמת
אין הסבר"
C,TRUE,2016,a,a,9,T3/ds16AA-sol.pdf,TAU,5,"\documentclass{article}
\begin{document}
The exam booklets are identified by the booklet number, which is a natural number between 1 and N. After grading the exams, the lecturers sorted the booklets so that booklet 1 is at the top of the stack and booklet N is at the bottom. On the way to the office, the booklets fell and got mixed in random order. Fortunately, the top √N booklets (indices 1 to √N) remained sorted. Unfortunately, all the bottom booklets (indices √N + 1 to N) are mixed in random order. This is how they arrived at the office.

To overcome the mishap and allow quick access to the booklets, the secretariat inserted them into a binary search tree by performing N insert operations according to the order the booklets arrived (the top = 1 first, and so on). Choose the most correct answer.
The worst-case search time in the worst order in the tree is (give the most tightly bound correct):
A. O(N).
B. O(log N).
C. O(N).
D. O(√log N).
E. No answer is correct.

Draw the tree and provide an explanation (mandatory):
\end{document}",c,na,5,e,tested,,"מחברות הבחינה מזוהות על ידי מספר המחברת שהוא מספר טבעי בין 1 ל-N. לאחר בדיקת הבחינות מוינו המחברות על ידי המרצים כך שמחברת 1 בראש הערימה ומחברת N בתחתיתה. בדרך למזכירות נפלו המחברות והתערבבו בסדר אקראי. למרבה המזל נשארו כל √N המחברות העליונות (אינדקסים 1 עד √N) ממוינות. לרוע המזל כל המחברות התחתונות (אינדקס √N + 1 עד N) הינן מעורבבות בסדר אקראי. כך הן הגיעו למזכירות.

כדי להתגבר על התקלה ולאפשר גישה מהירה למחברות הכניסה אותן המזכירות לעץ חיפוש בינארי על ידי ביצוע של N פעולות insert לפי סדר המחברות כפי שהגיעו אליה (העליונה = 1 ראשונה וכן הלאה.) בחרו את התשובה הנכונה ביותר.
זמן חיפוש case worst על הסדר הגרוע ביותר בעץ הינו (תנו את ההדוק ביותר הנכון):
א. O(N).
ב. O(log N).
ג. O(N).
ד. O(log N).
ה. אף תשובה לא נכונה.

ציירו את העץ וספקו הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,10,T3/ds16AA-sol.pdf,TAU,5,na,a,na,5,e,untested,,"השאלה הקודמת:
מחברות הבחינה מזוהות על ידי מספר המחברת שהוא מספר טבעי בין 1 ל-N. לאחר בדיקת הבחינות מוינו המחברות על ידי המרצים כך שמחברת 1 בראש הערימה ומחברת N בתחתיתה. בדרך למזכירות נפלו המחברות והתערבבו בסדר אקראי. למרבה המזל נשארו כל √N המחברות העליונות (אינדקסים 1 עד √N) ממוינות. לרוע המזל כל המחברות התחתונות (אינדקס √N + 1 עד N) הינן מעורבבות בסדר אקראי. כך הן הגיעו למזכירות.

כדי להתגבר על התקלה ולאפשר גישה מהירה למחברות הכניסה אותן המזכירות לעץ חיפוש בינארי על ידי ביצוע של N פעולות insert לפי סדר המחברות כפי שהגיעו אליה (העליונה = 1 ראשונה וכן הלאה.) בחרו את התשובה הנכונה ביותר.
זמן חיפוש case worst על הסדר הגרוע ביותר בעץ הינו (תנו את ההדוק ביותר הנכון):
א. O(N).
ב. O(log N).
ג. O(N).
ד. O(log N).
ה. אף תשובה לא נכונה.

זמן חיפוש ממוצע של איבר שרירותי על סדר מקרי בעץ בשאלה הקודמת הינו (תנו את ההדוק ביותר הנכון):

א. O(N).
ב. O(log N).
ג. O(N).
ד. O(log N).
ה. אף תשובה לא נכונה.

הסבר (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,a,11,T3/ds16AA-sol.pdf,TAU,3,"A Smart-Red-Black-Tree is a regular red-black tree that maintains a special pointer to the last node inserted into the tree (which is updated in O(1) work for each insert operation).

In addition to the regular insert operation, the tree is equipped with a successor-insert operation, which is a regular insert except that the search for the insertion point starts from the LAST node (which is reached via direct access through the special pointer). The tree is constructed by performing N regular insert operations of elements 1, 2, ..., N in increasing order. Choose the most correct answer (among different times, choose the tightest correct one).

A. The tree construction time is O(n \log n).
B. The tree construction time is O(n).
C. The tree construction time is O(n^2).
D. If the order of elements were arbitrary, the cost would be O(n \log n), but in the current order, the cost is O(n).

Short justification (required):",a,na,4,f,tested,,"נתון Smart-Red-Black-Tree הינו עץ אדום שחור רגיל ששומר מצביע מיוחד לצומת האחרון שהוכנס לעץ (והמעודכן ב-O(1) עבודה בכל פעולת insert).

בנוסף לפעולת ה-insert הרגילה מצויד העץ בפעולת successor-insert, שהוא insert רגיל רק שחיפוש מקום ההכנסה מתבצע החל מהצומת LAST (אליו מגיעים בגישה ישירה דרך המצביע המיוחד). בונים את העץ על ידי בצוע N פעולות insert רגילות של האיברים 1, 2, ..., N בסדר מהקטן לגדול. בחרי את התשובה הנכונה ביותר (בין זמנים שונים יש לבחור את הנכון ההדוק ביותר).

א. זמן בניית העץ הינו O(n log n).
ב. זמן בניית העץ הינו O(n).
ג. זמן בניית העץ הינו O(n^2).
ד. אם סדר האיברים היה שרירותי אזי העלות הייתה O(n log n) אבל בסדר הנוכחי העלות הינה O(n).

נימוק קצר (חובה):",na,,,,"classified red-black trees as f
אין הסבר"
C,TRUE,2016,a,a,12,T3/ds16AA-sol.pdf,TAU,7,na,b,na,4,"a,f",untested,,"כעת בונים את העץ (מהשאלה הקודמת) על ידי בצוע N פעולות successor-insert של האיברים 1, 2, ..., N בסדר מהקטן לגדול. בחרי את התשובה הנכונה ביותר (בין זמנים שונים יש לבחור את הנכון ההדוק ביותר).

א. זמן בניית העץ הינו O(n log n).
ב. זמן בניית העץ הינו O(n).
ג. זמן בניית העץ הינו O(n^2).
ד. עלות פעולת successor-insert אחת היא O(n) אבל הזמן הכולל הינו O(n log n).

נימוק קצר (חובה):","חיפושים לא עולים, תיקונים אמורטייזד n.",,,,"classified red-black trees as f
אין הסבר
תלוי בשאלה הקודמת"
C,TRUE,2016,a,a,13,T3/ds16AA-sol.pdf,TAU,8,na,c,na,5,k,untested,,"נתונים n מספרים שלמים שרירותיים שונים זה מזה בתוך מערך (בגודל n). לגבי √n המספרים הראשונים ידוע שמספר הזוגות שנמצאים בסדר יחסי הפוך הינו I = n/5. לגבי √n המספרים האחרונים ידוע שמספר הזוגות שנמצאים בסדר יחסי הפוך הינו I = n/5. ידוע שכל n-2√n המספרים ""במרכז"" נמצאים במקומותיהם.

רוצים למיין את המערך וניתן להשתמש בזיכרון עזר. 
בחר את התשובה הנכונה ביותר (בין זמנים שונים יש לבחור את הנכון ההדוק ביותר).

א. חסם תחתון על זמן המיון של המערך הינו Ω(n log n).
ב. ניתן למיין את המערך בזמן O(n log n).
ג. ניתן למיין את המערך בזמן O(√n log n).
ד. חסם תחתון על זמן המיון של המערך הינו Ω(n).
ה. ניתן למיין את המערך בזמן O(n + (n log(I/n)+n)).

נימוק קצר (חובה):",מיון בצד,,,,
A,TRUE,2016,a,b,1-a,T3/ds16AB-sol.pdf,TAU,na,na,na,na,na,na,na,,"תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) כך שכל מפתח שמאלי בזוג הוא מספר שלם שייך לתחום [1,10n]. ניתן להניח שכל זוגות המפתחות שונים זה מזה. על מבנה הנתונים לתמוך בפעולות הבאות (כאשר n הוא מספר זוגות המפתחות שנמצאים כרגע במבנה הנתונים):
Insert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). על הפעולה להתבצע בזמן אמורטייזד של O(1).
IncreaseKey((a,b),x) – הפקודה מקבלת מצביע לזוג מפתחות (a,b) שנמצא במבנה הנתונים ומספר חיובי x ומגדילה את המפתח הימני ב-x. על הפעולה להתבצע בזמן אמורטייזד של O(1).
Delete((a,b)) - הפקודה מקבלת מצביע לזוג מפתחות (a,b) שנמצא במבנה הנתונים ומוחקת אותו. על הפעולה להתבצע בזמן אמורטייזד של O(logn).","נממש ע""י מערך כשכל תא מצביע לערימת מקסימום. בכל הפעולות ניגש לתא ה-a במערך ונפעיל את הפקודה המתאימה בערימה עם מפתח b.",,,,total points: 20.00 
A,TRUE,2016,a,b,1-b,T3/ds16AB-sol.pdf,TAU,na,na,na,na,na,na,na,,"תאר/י מבנה נתונים שאיבריו הם זוגות של מפתחות (a,b) התומך בפעולות הבאות (כאשר n הוא מספר זוגות המפתחות שנמצאים כרגע במבנה הנתונים וניתן להניח שכל זוגות המפתחות שונים זה מזה):
Insert(a,b) – הוסף למבנה הנתונים את זוג המפתחות (a,b). על הפעולה להתבצע בזמן O(logn).
Delete(a,b) – מחק את זוג המפתחות (a,b). על הפעולה להתבצע בזמן O(logn).
Search(a,b) – החזר את זוג המפתחות (a,b) אם קיים, אחרת החזר null. על הפעולה להתבצע בזמן O(logn).
successor(a,b) – החזר את (a,b*) כך ש-b* מוגדר באופן הבא: יהיו b1,b2,b3,…,bm כל המפתחות כך שהזוג (a,bi) נמצא במבנה הנתונים (עבור 1≤i≤m) ממויינים מהקטן לגדול. אזי b* הוא המפתח שנמצא מימינו של b ברשימה הממויינת. במידה ואין מפתח מימינו של b ברשימה הממויינת החזר null. על הפעולה להתבצע בזמן O(logn).","נממש ע""י עץ אדום שחור שכל צומת בו מצביע לעץ אדום שחור. בכל הפעולות נחפש על העץ הראשי לפי a ועל העץ המשני (עץ שמוצבע מצומת בעץ הראשי) לפי b.",,,,total points: 20.00 
A,TRUE,2016,a,b,2-a,T3/ds16AB-sol.pdf,TAU,na,na,na,na,na,na,na,,"הוכיח/י שמספר הפיצולים בפעולת insert בעצי 2-4 היא אמורטייזד O(1), כאשר ניתן לבצע פעולות insert בלבד.",נשתמש בפונקציית פוטנציאל שסופרת את מספר הצמתים עם 3 מפתחות. המקרה הכללי הוא שהכנסה גורמת ל-k פיצולים ולאחר מכן לצומת שכמות המפתחות בו גדלה מ-2 ל-3. במקרה זה ה-actual time = k+1 והפרש הפוטנציאל הוא 1-k ולכן amortized time = 2.,,,,total points: 20.00 
A,TRUE,2016,a,b,2-b,T3/ds16AB-sol.pdf,TAU,na,na,na,na,na,na,na,,"תאר/י מבנה נתונים התומך בפעולות הבאות (כאשר n הוא מספר המפתחות שנמצאים כרגע במבנה הנתונים וניתן להניח שכל המפתחות שונים זה מזה):
Insert(a) – הוסף למבנה הנתונים את המפתח a. על הפעולה להתבצע בזמן O(logn).
Delete(a) – מחק את המפתח a. על הפעולה להתבצע בזמן O(logn).
Search(a) – החזר את המפתח a אם קיים, אחרת החזר null. על הפעולה להתבצע בזמן O(logn).
Sum(a) – החזר את סכום כל המפתחות שקטנים מ-a. ניתן להניח ש-a קיים במבנה הנתונים. על הפעולה להתבצע בזמן O(logn).","נממש ע""י עץ אדום שחור שבו כל צומת שומר את סכום המפתחות של תת העץ שהוא שורשו. פעולת Sum תתבצע ע""י ירידה מהשורש ל-a וסכימת שדות הסכום של כל הבנים השמאליים של הצמתים לאורך המסלול ביחד עם שדה הסכום של a.",,,,total points: 20.00 
A,TRUE,2016,a,b,3,T3/ds16AB-sol.pdf,TAU,10,na,na,na,na,na,na,,"נתון מערך A של N מספרים חיוביים שלמים שונים אחד מהשני. רוצים לממש את הפונקציה Anagram(z) שמקבלת כקלט מספר חיובי שלם Z ומחזירה רשימה מקושרת של המספרים במערך A שיכולים להתקבל מתוך Z ע""י שינוי סדר הספרות של Z.
למשל, עבור המערך A:

81 18 11 101 201 718 102 1993 781 178

הקריאה Anagram(781) תחזיר רשימה עם האיברים: 178, 781, 718. הקריאה Anagram(110) תחזיר רשימה עם האיבר: 101.
הניחו כי ""אורך"" המספר (מס' הספרות בייצוג העשרוני של המספר) של כל איבר במערך A וכן של הקלט Z הוא לכל היותר L.
הציעו אלגוריתם שפותר את הבעיה ונתחו את זמן הריצה שלו. מותר להשתמש ב-preprocessing בסיבוכיות O(NL) בתוחלת, ולאחריו על קריאה ל-Anagram לקחת זמן ריצה של O(L) בתוחלת. פתרונות בזמן גרועים יותר יקבלו ניקוד נמוך יותר.

פתרון שלב ה pre-processing - מה הסיבוכיות?
הסבר הפתרון וניתוח הסיבוכיות:
קריאה ל anagram - מה הסיבוכיות?
הסבר הפתרון וניתוח הסיבוכיות:","ל-pre-processing:
תיקח k[x] ממוינות בסדר עולה. מציאת x, שהוא המספר המתקבל מספרות k[x] נתאים מפתח, לכל איבר x במערך A בעזרת quick-sort לאיבר, O(L) ו-O(NL) סה""כ.
כעת, נכניס את איברי A לטבלת האש לפי המפתח k[x] של כל איבר, כאשר המפתח שלו כבר קיים בטבלה, נשרשר את x ברשימה מקושרת המתאימה למפתח עם מפתח זה (בכל תא יש רשימה של רשימות, אחת של המפתחות ומטפלת בהתנגשויות, וכל מפתח מחזיק רשימה נוספת משלו עם כל איברי A עם מפתח זה).

לקריאה Anagram(Z):
נמיין את ספרות Z ונחפש את k[Z] בטבלת ההאש, ונסמן את מה שהתקבל כ-k[Z]. החיפוש ייקח O(L) ונחזיר את הרשימה שמחזיק מפתח זה.
במקרה זה ניתן להשתמש בעץ חיפוש במקום טבלה, אבל זמן שאילתה ייקח O(L+logN).",,,,
C,TRUE,2016,a,b,4,T3/ds16AB-sol.pdf,TAU,6,"\textbf{Given a Union-Find data structure according to the definitions learned in class. Additionally, for each root \(x\), a field \texttt{size} is maintained that indicates the number of elements in the set represented by \(x\). The implementation of the operations on the structure is identical to what was learned in class, but it does not include path compression in \texttt{FIND}. Also, the implementation of the \texttt{LINK} operation is different. Here is the pseudocode for the new operation:}

\begin{verbatim}
LINK (x, y)
If (x.size < y.size)
    Parent[x] = y
    y.size = y.size + x.size
Else
    Parent[y] = x
    x.size = x.size + y.size
\end{verbatim}

\textbf{In other words, the operation hangs the root of the smaller set on the root of the larger set and updates the \texttt{size} field accordingly. What is the worst-case runtime of the \texttt{FIND} operation (on the new implementation of \texttt{LINK} and the additional data in the question)? Choose the tightest bound.}

\begin{enumerate}
    \item O(1)
    \item O(\alpha(n))
    \item O(\log^* n)
    \item O(\log n)
    \item O(n)
    \item None of the answers is correct.
\end{enumerate}",d,na,6,"a,n",tested,,"נתון מבנה נתונים Union-Find לפי ההגדרות שנלמדו בכיתה. בנוסף, לכל שורש x מחזיקים שדה size שאומר את מספר האיברים בקבוצה המיוצגת ע""י x. 
מימוש הפעולות על המבנה זהה לזה שנלמד בכיתה, אך לא כולל כיווץ מסלולים ב-FIND. כמו כן, מימוש פעולת LINK שונה. הנה הפסאודו קוד לפעולה החדשה:

LINK (x, y)
If (x.size < y.size)
    Parent[x] = y
    y.size = y.size + x.size
Else
    Parent[y] = x
    x.size = x.size + y.size

במילים אחרות, הפעולה תולה שורש של הקבוצה הקטנה יותר על שורש הקבוצה הגדולה יותר, ומעדכנת את השדה size בהתאם.
מה זמן ריצה במקרה הגרוע של פעולת FIND (על המימוש החדש של LINK והנתונים הנוספים בשאלה)? בחר/י את החסם ההדוק ביותר.

א. O(1)
ב. O(α(n))
ג. O(log* n)
ד. O(log n)
ה. O(n)
ו. אף תשובה אינה נכונה",na,,,,
C,TRUE,2016,a,b,5-a,T3/ds16AB-sol.pdf,TAU,na,"We want to color the nodes of a full binary search tree (i.e., every non-leaf node has exactly two children) in red and black, so that the coloring satisfies the rules of a red-black tree.
For each of the following statements, state whether it is true or false. Justify your answer.
A. If all the leaves are at the same distance from the root, then such a coloring necessarily exists. True / False.",1,"\textit{Reasoning: In this case, it is a whole entity. Coloring all the nodes in black is a legal coloring.}",2,"e,f",tested,,"אנחנו רוצים לצבוע את הצמתים של עץ חיפוש בינארי מלא (כלומר, לכל צומת שאינו עלה יש בדיוק שני בנים) באדום ובשחור, כך שהצביעה תקיים את הכללים של עץ אדום-שחור.
כתב/י עבור כל אחת מהטענות הבאות האם היא נכונה או לא נכונה. נמק/י את תשובתך.
א. אם כל העלים נמצאים באותו מרחק מהשורש, אז בהכרח קיימת צביעה כזאת. נכון / לא נכון.","נימוק: במקרה זה מדובר בעצם שלם. צביעת כל הצמתים בשחור, היא צביעה חוקית.",,,,"total points: 8.00 
classified red-black trees as f
"
C,FALSE,2016,a,b,5-b,T3/ds16AB-sol.pdf,TAU,na,"We want to color the nodes of a full binary search tree (i.e., every non-leaf node has exactly two children) in red and black, such that the coloring satisfies the rules of a red-black tree. For each of the following statements, state whether it is true or false. Justify your answer.  
b. If the maximum distance from the root to a leaf is at most twice the minimum distance from the root to a leaf, then such a coloring necessarily exists. True / False.",,na,2,"e,f",tested,,"אנחנו רוצים לצבוע את הצמתים של עץ חיפוש בינארי מלא (כלומר, לכל צומת שאינו עלה יש בדיוק שני בנים) באדום ובשחור, כך שהצביעה תקיים את הכללים של עץ אדום-שחור.
כתב/י עבור כל אחת מהטענות הבאות האם היא נכונה או לא נכונה. נמק/י את תשובתך.
ב. אם המרחק הגדול ביותר משורש לעלה הוא לכל היותר פי שניים מהמרחק הקטן ביותר משורש לעלה, אזי בהכרח קיימת צביעה כזאת. נכון / לא נכון.",na,,,,"total points: 8.00
classified red-black trees as f
אין הסבר
"
C,TRUE,2016,a,b,5-c,T3/ds16AB-sol.pdf,TAU,na,"\text{We want to color the vertices of a full binary search tree (i.e., every non-leaf vertex has exactly two children) in red and black so that the coloring satisfies the rules of a red-black tree. Write for each of the following claims whether it is true or not true. Justify your answer.} \\
\text{c. If the depth of the right subtree of the root is at most twice the depth of the left subtree of the root. True / Not true}",FALSE,"\textit{Explanation: There can be a very large left subtree, and then we won't be able to ensure that the black height is the same across all paths.}",2,"e,f",tested,,"אנחנו רוצים לצבוע את הצמתים של עץ חיפוש בינארי מלא (כלומר, לכל צומת שאינו עלה יש בדיוק שני בנים) באדום ובשחור, כך שהצביעה תקיים את הכללים של עץ אדום-שחור.
כתב/י עבור כל אחת מהטענות הבאות האם היא נכונה או לא נכונה. נמק/י את תשובתך.
ג. אם עומק תת-העץ הימני של השורש הוא לכל היותר פי שניים מעומק תת-העץ השמאלי של השורש. נכון / לא נכון","נימוק: יכול להיות תת עץ שמאלי גדול מאוד, ואז לא נוכל לדאוג לכך שהגובה השחור יהיה זהה בכל המסלולים.",,,,"total points: 8.00 
classified red-black trees as f"
C,TRUE,2016,a,b,6,T3/ds16AB-sol.pdf,TAU,6,na,e,na,5,e,untested,,"בבחינה N מחברות. מחברות הבחינה מזוהות על ידי מספר המחברת שהוא מספר טבעי בין 1 ל-N.
לאחר בדיקת הבחינות מוינו המחברות על ידי המרצים. בשקית א' שמו את המחברות הממוספרות 1 עד √N ממוינות מלמעלה למטה כך שבעלת המספר הגבוה (√N) בראש השקית. את שאר המחברות שמו המרצים בשקית ב' בסדר אקראי (הן במילא תמיד נופלות ומתבלגנות.)
כדי לאפשר גישה מהירה למחברות הכניסה אותן המזכירות לעץ חיפוש בינארי על ידי ביצוע של N פעולות insert. ראשית הוכנסו מחברות שקית א לפי הסדר (ראשונה נכנסת √N.) אחר כך הוכנסו מחברות שקית ב.' בחרו את התשובה הנכונה ביותר.

זמן חיפוש case worst בעץ, הנספר במספר הצמתים הנסרקים, הינו (תנו את התוצאה הקרובה ביותר הנכונה):

א. √N
ב. log2N
ג. N
ד.  √N - log2N
ה. N-√N

ציירו את העץ וספקו הסבר:",na,,,,אין הסבר
C,TRUE,2016,a,b,7,T3/ds16AB-sol.pdf,TAU,6,"\textbf{Previous question:}

\textbf{Question 7 (6 points):}
The average search time over all elements when the order of notebooks from Set B is random, in the tree from the previous question is (give the lowest correct one):

\textbf{a.} $O(\sqrt{N})$.

\textbf{b.} $O(\log N)$.

\textbf{c.} $O(N)$.

\textbf{d.} $O(\sqrt{N} + \log N)$.

\textbf{e.} $O(\sqrt{N}\log N)$.",b,na,5,e,tested,,"השאלה הקודמת:

שאלה 7 (6 נקודות):
זמן חיפוש ממוצע על כל האיברים כשסדר מחברות משקית ב' הינו אקראי, בעץ בשאלה הקודמת הינו (תנו את הנמוך ביותר הנכון):

א. O(√N).
ב. O(log N).
ג. O(N).
ד. O(√N + log N).
ה. O(√Nlog N).",na,,,,"אין הסבר
תלוי בשאלה הקודמת"
C,TRUE,2016,a,b,8,T3/ds16AB-sol.pdf,TAU,6,na,c,na,4,"a,d,h",untested,,"בכיתה למדנו על תור עדיפויות המאפשר פעולות insert ו-deletemin. למדנו שאפשר לממש אותו בצורה יעילה בתוך מערך בשימוש בערימה בינארית (בצענו פעולות אלו ב-O(log n) כש-n הוא גודל התור). בשאלה זו אנחנו מתעניינים במבנה חדש, תור פרוטקציה, המאפשר בנוסף לפעולות הקודמות גם delete-order(k) המשמיט את האיבר ה-k בגודלו (k=1 הוא המינימום). מעוניינים לבצע את המשימה במבנה שמשוכן במערך (כמו הערימה הבינארית) או מערכים.

אם k אינו ידוע מראש אך ידוע ש- k > n-10 (פרוטקציה אולטימטיבית,...), אזי ניתן לממש את המבנה, לבצע את insert ו-deletemin ב-O(log n) וכן

א. לבצע את delete-order(k) ב-O(n+logn).
ב. לבצע את delete-order(k) ב-O(√nloglog n).
ג. לבצע את delete-order(k) ב-O(log n).
ד. לבצע את delete-order(k) ב-O(n).

נימוק קצר והסבר המימוש או האלגוריתם (חובה):",na,,,,אין הסבר
C,TRUE,2016,a,b,9,T3/ds16AB-sol.pdf,TAU,6,"\text{In class, we learned about a priority queue that allows insert and deletemin operations. We learned that it can be efficiently implemented within an array using a binary heap (we performed these operations in } O(\log n) \text{ where } n \text{ is the size of the queue). \text{ In this question, we are interested in a new structure, a protection queue, which in addition to the previous operations also allows delete-order(k) that removes the k-th largest element (k=1 is the minimum). We aim to perform this task in a structure residing in an array (like the binary heap) or arrays.}

\text{If } k \text{ is not known in advance but it is known that } k < \log n, \text{ then it is possible to implement the structure and perform insert and deletemin in } O(\log n) \text{ as well as:}

\text{a. Perform delete-order(k) in } O((\log n)^2). \\
\text{b. Perform delete-order(k) in } O(\log n \log \log n). \\
\text{c. Perform delete-order(k) in } O(\log n). \\
\text{d. Perform delete-order(k) in } O(n). 

\text{Brief justification and explanation of the implementation or algorithm (mandatory):}",c,na,4,"a,d,h",tested,,"בכיתה למדנו על תור עדיפויות המאפשר פעולות insert ו-deletemin. למדנו שאפשר לממש אותו בצורה יעילה בתוך מערך בשימוש בערימה בינארית (בצענו פעולות אלו ב-O(log n) כש-n הוא גודל התור). בשאלה זו אנחנו מתעניינים במבנה חדש, תור פרוטקציה, המאפשר בנוסף לפעולות הקודמות גם delete-order(k) המשמיט את האיבר ה-k בגודלו (k=1 הוא המינימום). מעוניינים לבצע את המשימה במבנה שמשוכן במערך (כמו הערימה הבינארית) או מערכים.

אם k אינו ידוע מראש אך ידוע ש- k < logn, אזי ניתן לממש את המבנה, לבצע את insert ו-deletemin ב-O(log n) וכן

א. לבצע את delete-order(k) ב-O((logn)^2).
ב. לבצע את delete-order(k) ב-O(lognloglogn).
ג. לבצע את delete-order(k) ב-O(log n).
ד. לבצע את delete-order(k) ב-O(n).

נימוק קצר והסבר המימוש או האלגוריתם (חובה):
 ",na,,,,"אין הסבר
תלוי בשאלה הקודמת"
A,TRUE,2016,a,b,10-a,T3/ds16AB-sol.pdf,TAU,3,na,na,na,na,na,na,,"סטודנט התבקש להריץ את אלגוריתם האפמן. כדי להקל עליו נתנו לו את רשימת האותיות ממויינת לפי המשקל (ההסתברות) שלהן (בתוך מערך או רשימה מקושרת לפי נוחיותכם.)

לאור ההקלה הסטודנט שוקל באיזה מבנה נתונים יוכל לממש את תור העדיפויות Q של האלגוריתם ביעילות מירבית ומה תהיה סיבוכיות זמן הריצה הכוללת (case worst) שתנבע מהמימוש. תזכורת לאלגוריתם שניתן בכיתה נתונה משמאל כשהביטוי C ← Q אומר שאתם מכניסים את המשקולות לתוך המבנה Q בצורה הכי יעילה שניתן.

Huffman(C)
1.	n ← |C|
2.	Q ← C
3.	for i ← 1 to n-1; do new(z); left(z) ← x ← delete-min(Q); right(z) ← y ← delete-min(Q); f(z) ← f(x) + f(y); insert(z,Q) 
return delete-min(Q)


ענו נכון / לא נכון על השאלות הבאות ונמקו:

א. מהי הסיבוכיות case worst של בנית המבנה (שורה 2 בתמונה) אם Q ממומש באמצעות finger tree?

בכל התשובות עליכם לבחור בין האפשרויות:
1) O(log n)
2) O(n)
3) O(n log n)
4) O(n^2)
5) תשובה אחרת",בנייה היא לינארית כי אפשר להכניס תמיד את המינימום מימין . עלות מציאה .1 עלות תיקונים כוללת O(n),,,,
A,TRUE,2016,a,b,10-b,T3/ds16AB-sol.pdf,TAU,3,na,na,na,na,na,na,,"סטודנט התבקש להריץ את אלגוריתם האפמן. כדי להקל עליו נתנו לו את רשימת האותיות ממויינת לפי המשקל (ההסתברות) שלהן (בתוך מערך או רשימה מקושרת לפי נוחיותכם.)

לאור ההקלה הסטודנט שוקל באיזה מבנה נתונים יוכל לממש את תור העדיפויות Q של האלגוריתם ביעילות מירבית ומה תהיה סיבוכיות זמן הריצה הכוללת (case worst) שתנבע מהמימוש. תזכורת לאלגוריתם שניתן בכיתה נתונה משמאל כשהביטוי C ← Q אומר שאתם מכניסים את המשקולות לתוך המבנה Q בצורה הכי יעילה שניתן.

Huffman(C)
1.	n ← |C|
2.	Q ← C
3.	for i ← 1 to n-1; do new(z); left(z) ← x ← delete-min(Q); right(z) ← y ← delete-min(Q); f(z) ← f(x) + f(y); insert(z,Q) 
return delete-min(Q)


ענו נכון / לא נכון על השאלות הבאות ונמקו:

ב. מהי סיבוכיות case worst של עדכון המבנה (בצוע הלולאה בשורה 3 מ-1 ועד n-1) אם Q ממומש באמצעות finger tree?

בכל התשובות עליכם לבחור בין האפשרויות:
1) O(log n)
2) O(n)
3) O(n log n)
4) O(n^2)
5) תשובה אחרת","הכנסות הן שרירותיות ולכן מציאת האיברים להכנסה עולה nlogn. 
n/2 ההכנסות הראשונות ישלמו logn.",,,,
A,TRUE,2016,a,b,10-c,T3/ds16AB-sol.pdf,TAU,3,na,na,na,na,na,na,,"סטודנט התבקש להריץ את אלגוריתם האפמן. כדי להקל עליו נתנו לו את רשימת האותיות ממויינת לפי המשקל (ההסתברות) שלהן (בתוך מערך או רשימה מקושרת לפי נוחיותכם.)

לאור ההקלה הסטודנט שוקל באיזה מבנה נתונים יוכל לממש את תור העדיפויות Q של האלגוריתם ביעילות מירבית ומה תהיה סיבוכיות זמן הריצה הכוללת (case worst) שתנבע מהמימוש. תזכורת לאלגוריתם שניתן בכיתה נתונה משמאל כשהביטוי C ← Q אומר שאתם מכניסים את המשקולות לתוך המבנה Q בצורה הכי יעילה שניתן.

Huffman(C)
1.	n ← |C|
2.	Q ← C
3.	for i ← 1 to n-1; do new(z); left(z) ← x ← delete-min(Q); right(z) ← y ← delete-min(Q); f(z) ← f(x) + f(y); insert(z,Q) 
return delete-min(Q)


ענו נכון / לא נכון על השאלות הבאות ונמקו:

ג. מהי הסיבוכיות case worst של בנית המבנה (שורה 2 בתמונה) אם Q ממומש באמצעות ערימה בינומית (binomial heap)?

בכל התשובות עליכם לבחור בין האפשרויות:
1) O(log n)
2) O(n)
3) O(n log n)
4) O(n^2)
5) תשובה אחרת",na,,,,אין הסבר
A,TRUE,2016,a,b,10-d,T3/ds16AB-sol.pdf,TAU,3,na,na,na,na,na,na,,"סטודנט התבקש להריץ את אלגוריתם האפמן. כדי להקל עליו נתנו לו את רשימת האותיות ממויינת לפי המשקל (ההסתברות) שלהן (בתוך מערך או רשימה מקושרת לפי נוחיותכם.)

לאור ההקלה הסטודנט שוקל באיזה מבנה נתונים יוכל לממש את תור העדיפויות Q של האלגוריתם ביעילות מירבית ומה תהיה סיבוכיות זמן הריצה הכוללת (case worst) שתנבע מהמימוש. תזכורת לאלגוריתם שניתן בכיתה נתונה משמאל כשהביטוי C ← Q אומר שאתם מכניסים את המשקולות לתוך המבנה Q בצורה הכי יעילה שניתן.

Huffman(C)
1.	n ← |C|
2.	Q ← C
3.	for i ← 1 to n-1; do new(z); left(z) ← x ← delete-min(Q); right(z) ← y ← delete-min(Q); f(z) ← f(x) + f(y); insert(z,Q) 
return delete-min(Q)


ענו נכון / לא נכון על השאלות הבאות ונמקו:

ד. מהי סיבוכיות case worst של עדכון המבנה (בצוע הלולאה בשורה 3 מ-1 ועד n-1) אם Q ממומש באמצעות ערימה בינומית (binomial heap)?

בכל התשובות עליכם לבחור בין האפשרויות:
1) O(log n)
2) O(n)
3) O(n log n)
4) O(n^2)
5) תשובה אחרת",na,,,,אין הסבר
A,TRUE,2016,b,a,1-a,T3/ds16BA-sol.pdf,TAU,5,na,na,na,na,na,na,,"שני הסעיפים בשאלה זו מתייחסים לטבלאות hash עם probing linear.

א. הוכיחו או הפריכו:
הטבלה T1 המתקבלת לאחר ביצוע Insert(x) ואז Insert(y) מטבלה T
זהה לטבלה T2 המתקבלת לאחר ביצוע Insert(y) ואז Insert(x) מטבלה T.","נפריך את הטענה.
אם T טבלה ריקה ועבור פונק׳ ה-hash שלנו מתקיים, למשל, h(x) = h(y) = 0, אז נקבל ש-T1 היא x-y-etc בעוד ש-T2 היא y-x-etc.
כפי שניתן לראות, קיבלנו טבלאות שונות כאשר סדר ההכנסה שונה.",,,,
A,TRUE,2016,b,a,1-b,T3/ds16BA-sol.pdf,TAU,5,na,na,na,na,na,na,,"שני הסעיפים בשאלה זו מתייחסים לטבלאות hash עם probing linear.

ב. הוכיחו או הפריכו:
הטבלה S1 המתקבלת לאחר ביצוע Delete(x) ואז Delete(y) מטבלה S
זהה לטבלה S2 המתקבלת לאחר ביצוע Delete(y) ואז Delete(x) מטבלה S.","נוכיח את הטענה.
כאשר מוחקים איבר בטבלה המשתמשת ב-probing linear מבצעים חיפוש האם יש איבר אחר שהיה אמור ""לתפוס"" את המקום של האיבר שנמחק אילולא היינו מכניסים מראש את האיבר שנמחק. ראינו בכיתה שמחיקת איבר מביאה את הטבלה למצב כאילו מעולם לא הכנסנו את האיבר הזה לטבלה.
לכן, מחיקה בסדר delete(x) -> delete(y) כמו גם מחיקה בסדר delete(y) -> delete(x) מביאים את הטבלה למצב כאילו מעולם לא הכנסנו את x או y, כלומר S2 = S1.",,,,
A,TRUE,2016,b,a,2,T3/ds16BA-sol.pdf,TAU,15,na,na,na,na,na,na,,"ממשו מבנה נתונים מסוג מילון התומך בפעולות הבאות:
• Insert(k,e) – הכנסת איבר חדש e עם מפתח k (ניתן להניח שלא קיים כבר במבנה איבר אחר עם מפתח זה.)
• Search(k) ← e – מציאת איבר במבנה עם מפתח k, אם קיים כזה (אחרת מוחזר null.)
• DeleteBetween(a,b) – מחיקת כל האיברים הקיימים במבנה שהמפתח שלהם k נמצא בטווח a ≤ k < b.
על כל פעולה לרוץ בזמן O(log n).","נשתמש בעץ אדום-שחור שתומך בפעולות Insert, Search, Split, Join בזמן O(log n) לכל אחת.

מימוש DeleteBetween:
1. נבצע פיצול ואז T<a, T≥a ← Split(T, a) כאשר T<a הוא עץ א""ש שבו כל האיברים קטנים מ-a, ו-T≥a עץ א""ש שבו כל האיברים שווים ל-a או גדולים ממנו.
2. כעת נבצע פיצול נוסף T[a,b], T≥b ← Split(T≥a, b) כאשר T[a,b] הוא עץ א""ש שבו האיברים שקטנים מ-b וגדולים שווים ל-a-1, ו-T≥b עץ א""ש שבו האיברים שגדולים שווים ל-b.
3. לסיום, נבצע איחוד T ← Join(T<a, T≥b) ונחזיר את העץ שבו כל האיברים פרט לאלו שבין a ל-b.

יש כאן מספר קבוע של פעולות עץ א""ש בגודל O(log n).",,,,
A,TRUE,2016,b,a,3-a,T3/ds16BA-sol.pdf,TAU,15,na,na,na,na,na,na,,"א. נתונים 𝑚 מוצרים שונים (ממוספרים מ-1 עד 𝑚). המכרז פתוח 𝑚 ימים ובמהלכם 𝑛 אנשים מגישים הצעות לקניה (כל הצעה עבור מוצר אחד). בסוף כל יום יימכר המוצר שהוגשה עליו ההצעה הגבוהה ביותר מבין כל המוצרים שטרם נמכרו.

התבקשתם לממש מבנה נתונים עבור המכרז התומך בפקודות הבאות:
• Init(m) – אתחול המבנה עם 𝑚 מוצרים וללא הצעות.
• Bid(j,p) – הוספת הצעה במחיר 𝑝 למוצר 𝑗. על הפקודה לרוץ בזמן 𝑂(1) .amortized
• Sell() ← j,p – מכירת המוצר שקיבל את ההצעה הגבוהה ביותר (ניתן להניח שקיימת לפחות הצעה אחת על הפרק). הפקודה מחזירה את המוצר 𝑗 שנמכר ואת המחיר 𝑝 ששולם עליו; שאר ההצעות למוצר זה בטלות. על הפקודה לרוץ בזמן 𝑂(log 𝑚) .amortized","נשים לב שאין צורך לשמור את כל n ההצעות אלא רק את ההצעה הגבוהה ביותר לכל מוצר. נשמור בערימת מקסימום H מסוג פיבונאצ'י את ההצעה הגבוהה ביותר למוצר j (מפתח=המחיר p, ערך=מספר המוצר j). בנוסף, נחזיק מערך של m מצביעים לתוך H (במקום j מצביע להצעה עבור מוצר j).

Init: נבנה ערימה ריקה H, נכניס לתוכה הצעה במחיר אפס עבור כל אחד מהמוצרים ונשמור את המצביעים במערך.

Bid: אם p גדול מההצעה הנוכחית למוצר j (אותה נמצא בזמן קבוע באמצעות המצביע), אז נבצע Increase-Key ב-H למוצר זה ואחרת נתעלם (מניחים כאן שהמוצר טרם נמכר). בערימת פיבונאצ'י זה עולה 𝑂(1) .amortized

Sell: נבצע Delete-Max ל-H ונחזיר את המוצר j ומחירו p. יש ב-H לכל היותר m הצעות ולכן זה עולה 𝑂(log 𝑚) .amortized",,,,
A,TRUE,2016,b,a,3-b,T3/ds16BA-sol.pdf,TAU,15,na,na,na,na,na,na,,"ב. נתונים 𝑚 סוגי מוצרים שונים (ממוספרים מ- 1 עד 𝑚), כאשר מכל סוג יש כמות בלתי-מוגבלת של מוצרים. המכרז פתוח 𝑚 ימים ובמהלכם 𝑛 אנשים מגישים הצעות לקניה (כל הצעה עבור יחידת מוצר אחת). בסוף כל יום יימכר זוג מוצרים מסוגים שונים שהוגשו עליהם ההצעות הגבוהות ביותר.

התבקשתם לממש מבנה נתונים עבור המכרז התומך בפקודות הבאות:
• Init(m) – אתחול המבנה עם 𝑚 סוגי מוצרים וללא הצעות.
• Bid(j,p) – הוספת הצעה במחיר 𝑝 למוצר מסוג 𝑗. על הפקודה לרוץ בזמן 𝑂(1) .amortized
• Sell() ← j1,p1,j2,p2 – מכירה של יחידת מוצר אחת מכ""א משני הסוגים שקיבלו את ההצעה הגבוהה ביותר (ניתן להניח שקיימות לפחות שתי הצעות על הפרק). הפקודה מחזירה את סוגי המוצרים 𝑗1, 𝑗2 שנמכרו ואת המחירים 𝑝1, 𝑝2 ששולמו עליהם בהתאמה. על הפקודה לרוץ בזמן 𝑂(log 𝑛) .amortized","כאן חייבים לשמור את כל ההצעות כי אותו סוג מוצר יכול להימכר מספר פעמים בימים שונים. בנוסף לערימה H ולמערך המצביעים כמו בסעיף א', יהיה לנו מערך של m ערימות מקסימום (בינומית עצלה או פיבונאצ'י). Hj תכיל את כל ההצעות העומדות לסוג מוצר j. הערימה H תכיל את ראשי כל הערימות Hj, כלומר את ההצעה הטובה ביותר לכל סוג.

:Init לכל j נבנה ערימה ריקה Hj ונכניס לתוכה הצעת אפס. נבנה את H מראשי הערימות ונשמור מצביעים במערך.
:Bid נבצע Insert של p לערימה Hj. אם המקסימום שלה השתנה (ובפרט הוא גדל) אז נבצע Increase-Key כמו בסעיף א' כדי לעדכן את ההצעה הטובה ביותר לסוג מוצר j בתוך H. סה""כ 𝑂(1) amortized עבור שתי הפעולות.
:Sell נבצע פעמיים Delete-Max על H כדי לזהות את שני סוגי המוצרים j1, j2, ואת ההצעות הטובות ביותר p1, p2, בהתאמה. נבצע Delete-Max גם בשתי הערימות Hj1 ו-Hj2 כדי להסיר את ההצעות הללו ונכניס ל-H את שני ראשי הערימות החדשים, שהם ההצעות הבאות בתור לסוגי מוצרים אלו. נעדכן את מערך המצביעים.

סה""כ זמן ריצה: 𝑂(log 𝑛) = 𝑂(log 𝑚) + 𝑂(log 𝑛) amortized, כי מהנתון 2𝑚 ≥ 𝑛 וכן ב-H לכל היותר m איברים ובכל Hj לכל היותר n.",,,,
A,TRUE,2016,b,a,4,T3/ds16BA-sol.pdf,TAU,15,na,na,na,na,na,na,,"נאמר ששתי מחרוזות הן -𝑘 חופפות אם רישא באורך 𝑘 של אחת הוא סיפא של השנייה. תארו אלגוריתם שמקבל שתי מחרוזות 𝑠 ו- 𝑡 באורכים 𝑛 ו- 𝑚 בהתאמה ומחשב את החפיפה המקסימלית ביניהן בסיבוכיות הטובה ביותר.
דוגמא: עבור המחרוזות UKULELE ו- ELEPHANT התשובה היא .3","סיבוכיות: 𝑛) + O(
נראה כיצד לחשב חפיפה מקסימלית בין סיפא של s לרישא של ;t יש לבצע אותה פעולה בהיפוך תפקידים ולהחזיר את המקסימום ביניהן.
נבנה עץ סיפות T עבור s בזמן .O(𝑛) כעת נחפש את t ב-T ע""י כך שנתחיל מהשורש ונצעד לאורך קשתות כל עוד יש התאמה בין תווי t לתת-המחרוזת שרשומה על הקשת (זה בעצם חיפוש של t בתוך ה-Trie הלא דחוס.)
בכל ביקור בצומת x שיש לו בן עלה y ועל הקשת xy רשום רק הסימן $ נעדכן את k להיות מספר התווים מ-t שקראנו עד כה (כי מצאנו חפיפה בין רישא של t לסיפא של .)s
אם הגענו לסוף t באמצע קשת והתו היחיד שנשאר על הקשת ולא סרקנו הוא $ אז נעדכן את k להיות .m
הסריקה לוקחת m צעדים ולכן סה""כ זמן הריצה 𝑛) + .O(
הערה: ניתן לקבל זמן ריצה 𝑛)) O(min(𝑚, אם נעבוד עם רישא של t וסיפא של s באורך 𝑛) .min(𝑚,",,,,
A,TRUE,2016,b,a,5-a,T3/ds16BA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונים 𝑛 ברגים ו- 𝑛 אומים. לכל בורג קוטר ייחודי (כלומר ניתן להניח שערכי הקוטר של הברגים שונים זה מזה.) כמו כן לכל בורג קיים אום באותו הקוטר. ניתן להשוות בורג לאום (השוואה כזו מחזירה גדול, קטן או שווה,) אולם לא ניתן להשוות בורג לבורג או אום לאום.
א. תארו אלגוריתם רנדומי המוצא לכל בורג את האום המתאים ורץ בזמן 𝑛) log 𝑂(𝑛 בתוחלת.","האלגוריתם שנתאר הוא וריאציה על Quick Sort.
נבחר אום אקראי x, נבצע partition לברגים לפי x. כעת מצאנו את הברגים הגדולים מהאום, הקטנים ממנו ואת הבורג השווה לו y. נבצע partition לאומים לפי y. כעת נמשיך בצורה רקורסיבית על קבוצת הברגים הגדולים מ-x והאומים הגדולים מ-y, ועל קבוצת הברגים הקטנים מ-x והאומים הקטנים מ-y. 
הרקורסיה מסתיימת כשנגיע ל-n=1.

זמן הריצה לקריאות הרקורסיביות יהיה T(k-1) + T(n-k). כיוון ש-x נבחר באקראי, תוחלת זמן הריצה היא E[T(n)] = (1/n) Σ(k=1 to n) [E(T(k-1)) + E(T(n-k))], וכפי שראינו עבור Quick Sort הפתרון למשוואה הוא E[T(n)] = O(n log n).",,,,total points: 15.00
A,TRUE,2016,b,a,5-b,T3/ds16BA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונים 𝑛 ברגים ו- 𝑛 אומים. לכל בורג קוטר ייחודי (כלומר ניתן להניח שערכי הקוטר של הברגים שונים זה מזה.) כמו כן לכל בורג קיים אום באותו הקוטר. ניתן להשוות בורג לאום (השוואה כזו מחזירה גדול, קטן או שווה,) אולם לא ניתן להשוות בורג לבורג או אום לאום.
ב. תארו אלגוריתם לינארי המוצא לכל בורג את האום המתאים או הוכיחו שלא קיים כזה.","נוכיח שכל אלגוריתם לבעיה רץ בזמן Ω(n log n).
יש n! אפשרויות להתאים בין הברגים לאומים. תוצאת כל השוואה היא אחת מ-3 אפשרויות ולכן עץ ההשוואות של האלגוריתם הוא עץ טרינרי. על מנת שיהיו לעץ n! עלים שונים, גובהו (המקסימלי וגם הממוצע) חייב להיות לפחות Ω(n log n) = log3(n!).

הערה: לא ניתן להוכיח זאת ע""י הסתמכות על החסם התחתון של מיון שראינו בכיתה מאחר ובשאלה לא ביקשו למיין את הברגים ואומים לפי קוטר.
גם דוגמא עם מערך אומים ממויין ומערך ברגים לא ממויין אינה מוכיחה חסם תחתון של Ω(n log n) שכן ההתאמה יכולה להתבצע כך שהתוצאה לא תהיה ממויינת ובנוסף זו אינה דוגמא כללית למיון – העובדה שיש מערך ממויין מוסיפה הרבה אינפורמציה על הקלט.",,,,total points: 15.00
A,TRUE,2016,b,a,6,T3/ds16BA-sol.pdf,TAU,15,na,na,na,na,na,na,,"במחשב נמצאים מספר רב של דפים על הדיסק. למחשב מגיע זרם של בקשות לדפים השונים. כדי לאפשר גישה מהירה לדפים, לרשותנו זכרון מטמון בגודל 𝑛 דפים ובו אנו שומרים את הדפים הטריים ביותר, כלומר אלו שנתבקשו לאחרונה (מודל LRU).
דוגמא: נניח 𝑛 = 4. לאחר זרם הבקשות 6,5,9,4,5,4,7 יכיל ה-cache את הדפים 7,4,5,9 כאשר 7 הוא הטרי ביותר ו-9 הוא העבש ביותר. אם הבקשה הבאה היא לדף 3 אז 9 יפונה מה-cache.
עליכם לממש מבנה נתונים לשמירת ה-cache התומך בפקודות הבאות:
• Init(n) – אתחול המבנה עם 𝑛 מקומות לדפים וללא בקשות.
• Access(x) – גישה לדף 𝑥. אם הדף 𝑥 כבר נמצא במבנה, המבנה מעודכן כך ש-𝑥 הופך לטרי ביותר; אחרת, יש להכניס את 𝑥 כדף הטרי ביותר ולפנות את הדף העבש ביותר (אם צריך). על הפקודה לרוץ בזמן 𝑂(1) בתוחלת.","נשמור את מספרי הדפים שב-cache בתור (רשימה מקושרת ממוינת לפי טריות – הטרי ביותר בסוף התור) עם שדה אורך וכן נשמור טבלת hash שממפה כל דף x שנמצא ב-cache ל-node list שלו בתור.
:Init נאתחל טבלת hash ריקה באורך 2n ותור ריק.
:Access אם x מופיע ב-hash, נמחק אותו ממיקומו הנוכחי בתור (ע""י המצביע) ונכניס אותו לזנב התור. אם x לא מופיע ב-hash ניצור עבורו node list שנכניס לסוף התור ונשמור את x בטבלת ה-hash יחד עם המצביע ל-node.
אם אורך התור עלה ל-n+1 אז נמחק את הדף y שכעת בראש התור גם מהתור וגם מה-hash.
השתמשנו במספר קבוע של פעולות בטבלת ה-hash (כ""א 𝑂(1) בתוחלת) ובתור (כ""א 𝑂(1) כי ניגשנו לראש, לזנב או באמצעות מצביע.)",,,,
B,TRUE,2017,a,a,1-a,T3/ds17AA-sol.pdf,TAU,na,"\begin{enumerate}
    \item Given an array containing n elements. The number of distinct elements is k (𝑛 ≤ 𝑘).
    \item Sort the following asymptotic orders without explanation (𝑛 ≤ 𝑘):
    \begin{itemize}
        \item n \log n,
        \item n,
        \item n \log k,
        \item n + k \log k,
        \item n^2
    \end{itemize}
\end{enumerate}",na,"n^2, n\log{n}, n\log{k}, n+k\log{k}, n",na,a,tested,,"נתון מערך המכיל n איברים. מספר האיברים השונים הוא k (𝑛 ≤ 𝑘).
א. מיינו ללא הסבר את סדרי הגודל הבאים אסימפטוטית (𝑛 ≤ 𝑘):
nlogn, n, nlogk, n+klogk, n^2","n^2, nlogn, nlogk, n+klogk,n",,,,total points: 25.00
B,TRUE,2017,a,a,1-b,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,"f,p",untested,,"נתון מערך המכיל n איברים. מספר האיברים השונים הוא k (𝑛 ≤ 𝑘).
ב. הציעו אלגוריתם דטרמיניסטי למיון המערך.","נבנה עץ מאוזן כאשר בכל צומת נשמור מונה. נכניס את כל האיברים לעץ, וכאשר נתקל באיבר קיים, נגדיל ב-1 את המונה הרלוונטי. נעבור על העץ in-order ונפלוט כל איבר כמספר הפעמים שמופיע במונה שלו. הסיבוכיות היא O(nlogk).",,,,"total points: 25.00
מיון באופן כללי - p
לוודא שהסוג נכון "
B,TRUE,2017,a,a,1-c,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,"g,p",untested,,"נתון מערך המכיל n איברים. מספר האיברים השונים הוא k (k ≤ n).
ג. הציעו אלגוריתם המשתמש ברנדומיזציה למיון המערך.","נבנה טבלת hash כאשר בכל תא נשמור מונה. נכניס את כל האיברים לטבלה, וכאשר נתקל באיבר קיים, נגדיל ב-1 את המונה הרלוונטי. נמיין את המפתחות, נעבור על הטבלה ונפלוט כל איבר כמספר הפעמים שמופיע במונה שלו. הסיבוכיות היא O(n + klogk) בתוחלת.





",,,,"total points: 25.00
מיון באופן כללי - p
לוודא שהסוג נכון "
B,TRUE,2017,a,a,1-d,T3/ds17AA-sol.pdf,TAU,na,"\text{Given an array containing } n \text{ elements. The number of distinct elements is } k \, (k \leq n). \\
\text{d. Assume the elements are integers between } 1 \text{ and } n^4. \text{ Propose a deterministic algorithm to sort the array.}",na,We will use the count sort algorithm as taught in class. \(O(n)\).,na,"l,p",tested,,"נתון מערך המכיל n איברים. מספר האיברים השונים הוא k (k ≤ n).
ד. נניח כי האיברים הם מספרים שלמים בין 1 ל-n^4. הציעו אלגוריתם דטרמיניסטי למיון המערך.
",נשתמש באלגוריתם count sort כפי שנלמד בכיתה. O(n).,,,,"total points: 25.00
מיון באופן כללי - p
לוודא שהסוג נכון "
B,TRUE,2017,a,a,1-e,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,"g,l,p",untested,,"נתון מערך המכיל n איברים. מספר האיברים השונים הוא k (k ≤ n).
ה. נניח כי כשלב ראשון נתונים k האיברים השונים, וניתן לבצע עליהם עיבוד מוקדם לא מוגבל בזמן. הציעו אלגוריתם לעיבוד המוקדם וכן אלגוריתם למיון דטרמיניסטי יעיל של המערך באורך n.
","חלק ראשון: נמיין את k האיברים השונים ונבנה Perfect Hash מהערך של האיבר למיקום שלו במערך הממויין. הסיבוכיות תהיה O(klogk) בתוחלת.
חלק שני: נמיין את המערך עם הטבלה שבנינו בעזרת count sort. O(n).",,,,"total points: 25.00
מיון באופן כללי - p
לוודא שהסוג נכון "
A,TRUE,2017,a,a,2-a,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונה קבוצה סדורה S. נגדיר דרגה של איבר בקבוצה מסוימת כמקום הופעתו במערך ממוין של האיברים (כל האיברים בעלי ערכים שונים). לאורך השאלה ח מסמן את מספר האיברים הנוכחי במבנה הנתונים המבוקש.

א. תארו מבנה נתונים התומך בפעולות הבאות:
• Init() – אתחול המבנה בזמן O(1).
• Insert(x) – הכנסת האיבר x ל-S בזמן O(logn).
• Delete(x) – מחיקת האיבר x מ-S בזמן O(logn).
• Min() – החזרת האיבר בעל הדרגה המינימלית בגודלו בזמן O(1).
• Max() – החזרת האיבר בעל הדרגה מקסימלית בגודלו בזמן O(1).
• AVG() – החזרת האיבר בעל הדרגה המינימלית שערכו גדול או שווה לממוצע האיברים במבנה בזמן O(1).

","נשתמש בעץ בינארי מאוזן בעל שדות עזר שמתעדכן בכל פעולת insert/delete: מצביעים לאיברים המינימלי והמקסימלי (נמצא אותם ע""י הליכה רק שמאלה או ימינה מהשורש עד לעלה), מצביע לאיבר המינימלי הגדול או שווה מהממוצע, מספר האיברים בעץ וסכום האיברים בעץ. 
על מנת לתחזק את המצביע לאיבר הממוצע, בעת הכנסה נעדכן השדות של מספר האיברים וסכומים, נחשב הממוצע ונמצא באמצעות חיפוש את האיבר הכי קרוב אליו מלמעלה. בדומה עבור פעולת delete. 
בעת קריאה ל-Min/Max/AVG נחזיר את האיבר לפי המצביע המתאים.",,,,total points: 25.00
A,TRUE,2017,a,a,2-b,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונה קבוצה סדורה S. נגדיר דרגה של איבר בקבוצה מסוימת כמקום הופעתו במערך ממוין של האיברים (כל האיברים בעלי ערכים שונים). לאורך השאלה ח מסמן את מספר האיברים הנוכחי במבנה הנתונים המבוקש.

בסעיף א׳, תיארנו מבנה נתונים התומך בפעולות הבאות:
• Init() – אתחול המבנה בזמן O(1).
• Insert(x) – הכנסת האיבר x ל-S בזמן O(logn).
• Delete(x) – מחיקת האיבר x מ-S בזמן O(logn).
• Min() – החזרת האיבר בעל הדרגה המינימלית בגודלו בזמן O(1).
• Max() – החזרת האיבר בעל הדרגה מקסימלית בגודלו בזמן O(1).
• AVG() – החזרת האיבר בעל הדרגה המינימלית שערכו גדול או שווה לממוצע האיברים במבנה בזמן O(1).

ב. תארו מבנה נתונים התומך בנוסף בפעולה הבאה:
• Stat(k) – החזרת האיבר ה-k בדרגתו ב-S בזמן O(logk)","נשמור בכל צומת את גודל תת-העץ הרלוונטי. בעת קריאה ל-Stat נעלה בעץ מאיבר המינימום עד שנגיע לצומת שגודל תת העץ שלה הינו לפחות k. נבצע חיפוש רקורסיבי בתת-עץ הנ״ל כלפי מטה. בכל שלב נחשב את דרגת הצומת ע""י גודל תת העץ השמאלי ועוד 1. ע""י השוואה ל-k נדע אם סיימנו או שנמשיך לתת-העץ הימני/שמאלי. העץ מאוזן, לכן גובהו של תת העץ המינימלי מגדול לפחות k הינו O(logk) וזהו זמן הריצה.",,,,total points: 25.00
A,TRUE,2017,a,a,2-c,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונה קבוצה סדורה S. נגדיר דרגה של איבר בקבוצה מסוימת כמקום הופעתו במערך ממוין של האיברים (כל האיברים בעלי ערכים שונים). לאורך השאלה ח מסמן את מספר האיברים הנוכחי במבנה הנתונים המבוקש.

בסעיף א׳, תיארנו מבנה נתונים התומך בפעולות הבאות:
• Init() – אתחול המבנה בזמן O(1).
• Insert(x) – הכנסת האיבר x ל-S בזמן O(logn).
• Delete(x) – מחיקת האיבר x מ-S בזמן O(logn).
• Min() – החזרת האיבר בעל הדרגה המינימלית בגודלו בזמן O(1).
• Max() – החזרת האיבר בעל הדרגה מקסימלית בגודלו בזמן O(1).
• AVG() – החזרת האיבר בעל הדרגה המינימלית שערכו גדול או שווה לממוצע האיברים במבנה בזמן O(1).

כעת נניח כי נתון מראש פרמטר קבוע a>=1.
ג. תארו מבנה נתונים התומך בנוסף בפעולה הבאה:
• Stat() – החזרת האיבר ה-⌈NA⌉ בדרגתו מ-S בזמן O(1)
","נתחזק מצביע לאיבר בעל הדרגה הנ""ל בכל הכנסה/מחיקה ע""י הפעולה מסעיף ב'.",,,,total points: 25.00
A,TRUE,2017,a,a,2-d,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתונה קבוצה סדורה S. נגדיר דרגה של איבר בקבוצה מסוימת כמקום הופעתו במערך ממוין של האיברים (כל האיברים בעלי ערכים שונים). לאורך השאלה ח מסמן את מספר האיברים הנוכחי במבנה הנתונים המבוקש.

בסעיף א׳, תיארנו מבנה נתונים התומך בפעולות הבאות:
• Init() – אתחול המבנה בזמן O(1).
• Insert(x) – הכנסת האיבר x ל-S בזמן O(logn).
• Delete(x) – מחיקת האיבר x מ-S בזמן O(logn).
• Min() – החזרת האיבר בעל הדרגה המינימלית בגודלו בזמן O(1).
• Max() – החזרת האיבר בעל הדרגה מקסימלית בגודלו בזמן O(1).
• AVG() – החזרת האיבר בעל הדרגה המינימלית שערכו גדול או שווה לממוצע האיברים במבנה בזמן O(1).

ד. תארו מבנה נתונים התומך בנוסף בפעולה הבאה:
• StatPlus(i) – החזרת האיבר ה-⌈NA⌉ + i בדרגתו בזמן O(log i) (i הינו אי-שלילי עבור ⌈NA⌉ + i < n + 1 ואינו ידוע מראש).
","נתחזק שני עצים מאוזנים – הראשון לאיברים הקטנים ממש מהאיבר ה-⌈NA⌉ בדרגתו והשני ליתר. בעת הכנסה או מחיקה נשים לב אם צריך להעביר איברים בין העצים (לא יותר ממספר קבוע של איברים בכל פעולה). נתחזק מצביע למינימום של העץ השני.
בעת קריאה ל-StatPlus נבצע חיפוש דומה לסעיף ב' שיתחיל במינימום של העץ השני. הסיבוכיות לפי סעיף ב' הינה O(log i).",,,,total points: 25.00
A,TRUE,2017,a,a,3-a,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתון מערך של 𝑛 מספרים. בכל השאלות נרצה למצוא איבר החוזר מספר מסוים של פעמים במערך. במידה וקיים יותר מאיבר אחד כזה, אזי יש להחזיר אחד מהם.
הציעו אלגוריתם למציאת האיבר החוזר בכל אחד מהמקרים הבאים:

א. ידוע שקיים איבר שחוזר לפחות 𝐿 פעמים. בסעיף זה ניתן להשתמש ברנדומיות.
",נתחזק טבלת Hash בה ה-key הוא המספר והערך הינו מונה. נעבור על מערך הקלט ונספור חזרות של כל איבר. נעבור שוב ונחזיר איבר שערך המונה שלו לפחות 𝐿. סיבוכיות O(𝑛) בתוחלת.,,,,total points: 25.00
A,TRUE,2017,a,a,3-b,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתון מערך של 𝑛 מספרים. בכל השאלות נרצה למצוא איבר החוזר מספר מסוים של פעמים במערך. במידה וקיים יותר מאיבר אחד כזה, אזי יש להחזיר אחד מהם.
הציעו אלגוריתם למציאת האיבר החוזר בכל אחד מהמקרים הבאים:

ב. ידוע שקיים איבר שחוזר לפחות 𝑛/4 פעמים. הצע פתרון דטרמיניסטי.
","נפעיל את אלגוריתם select על 𝑖𝑛/5 עבור 𝑖=1,2,3,4, נקבל 4 איברים. נספור כמה פעמים חוזר כל אחד מהם, ונחזיר איבר החוזר לפחות 𝑛/4 פעמים. סיבוכיות O(𝑛).",,,,total points: 25.00
A,TRUE,2017,a,a,3-c,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתון מערך של 𝑛 מספרים. בכל השאלות נרצה למצוא איבר החוזר מספר מסוים של פעמים במערך. במידה וקיים יותר מאיבר אחד כזה, אזי יש להחזיר אחד מהם.
הציעו אלגוריתם למציאת האיבר החוזר בכל אחד מהמקרים הבאים:

ג. ידוע שקיים איבר שחוזר לפחות 𝑛/logn פעמים. הצע פתרון דטרמיניסטי. ",ראה ד׳. סיבוכיות O(nloglogn).,,,,total points: 25.00
A,TRUE,2017,a,a,3-d,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נתון מערך של 𝑛 מספרים. בכל השאלות נרצה למצוא איבר החוזר מספר מסוים של פעמים במערך. במידה וקיים יותר מאיבר אחד כזה, אזי יש להחזיר אחד מהם.
הציעו אלגוריתם למציאת האיבר החוזר בכל אחד מהמקרים הבאים:

ד. ידוע שקיים איבר שחוזר לפחות 𝑛/k פעמים. הצע פתרון דטרמיניסטי (הסיבוכיות תלויה ב-k). ","נמצא חציון המערך ונספור כמה פעמים הוא חוזר בזמן O(n). אם הוא חוזר לפחות 𝑛/𝑘 פעמים, נחזיר אותו. אחרת, נמשיך באופן רקורסיבי לשני תתי המערכים – מימין לחציון ומשמאלו. בשלב i גודל המערך הינו ⌊𝑛/2^i⌋ לכן בודאות נעצור כאשר 2^i = k. סה""כ זמן הריצה הינו O(nlogk): זמן הריצה של כל שלב הוא O(n) וישנם logk שלבים לכל היותר.",,,,total points: 25.00
A,TRUE,2017,a,a,4-a,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נגדיר איברים המכילים שני שדות – type, value (סוג וערך). נניח כי מספר הערכים השונים האפשריים עבור השדה type הינו k. מעוניינים לבנות מבנה נתונים המכיל עד n איברים והתומך בפעולות הבאות: 
• Insert(x) – מכניסה את האיבר X למבנה הנתונים בזמן O(1). 
• AddToType(t,a) – מגדילה ב-a ערכו של שדה value של כל האיברים מסוג t בזמן O(1). 
• AddToElement(a,x) – מקבלת פוינטר לאיבר X ומגדילה ב-a ערך של שדה value שלו בזמן O(1) אמורטיזד. 
• Max(t) – החזרת האיבר המקסימלי מבין האיברים מסוג t בזמן O(1). 
• MaxAll() – החזרת האיבר המקסימלי במבנה (ללא הגבלה על סוג) בזמן O(1). 

א. הציעו מבנה נתונים כזה עבור k=4. ","ניצור מערך בגודל 4 שיחזיק את כל אחד מהסוגים. 
בכל תא נתחזק: 
1. מצביע לרשימה שמכילה את האיברים מאותו סוג. 
2. את האיבר המקסימלי ברשימה. 
3. שדה offset מאותחל ל-0. 
בנוסף נתחזק שדה שיחזיק את המקסימום הגלובלי. בעת קריאה ל-Insert נפנה לתא המתאים במערך. נעדכן את המקסימום של הסוג הגלובלי אם צריך. נחסיר מהערך של האיבר המוכנס את הערך שיש בשדה ה-offset. לאחר מכן נכניס לרשימת האיברים. בעת קריאה ל-AddToElement פשוט נעדכן את ערך האיבר ואת המקסימומים במידת הצורך. בעת קריאה ל-max/maxAll נחזיר את ערך השדה מקס׳ הרלוונטי. בעת קריאה ל-AddToType נעדכן את השדה offset ואת המקסימום הרלוונטיים ואת המקסימום הגלובלי במידת הצורך.",,,,total points: 25.00
A,TRUE,2017,a,a,4-b,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נגדיר איברים המכילים שני שדות – type, value (סוג וערך). נניח כי מספר הערכים השונים האפשריים עבור השדה type הינו k. מעוניינים לבנות מבנה נתונים המכיל עד n איברים והתומך בפעולות הבאות: 
• Insert(x) – מכניסה את האיבר X למבנה הנתונים בזמן O(1). 
• AddToType(t,a) – מגדילה ב-a ערכו של שדה value של כל האיברים מסוג t בזמן O(1). 
• AddToElement(a,x) – מקבלת פוינטר לאיבר X ומגדילה ב-a ערך של שדה value שלו בזמן O(1) אמורטיזד. 
• Max(t) – החזרת האיבר המקסימלי מבין האיברים מסוג t בזמן O(1). 
• MaxAll() – החזרת האיבר המקסימלי במבנה (ללא הגבלה על סוג) בזמן O(1). 

ב. הציעו מבנה נתונים כזה עבור עד k סוגים שונים ממוספרים 1,...,k. ",ראה א׳.,,,,total points: 25.00
A,TRUE,2017,a,a,4-c,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נגדיר איברים המכילים שני שדות – type, value (סוג וערך). נניח כי מספר הערכים השונים האפשריים עבור השדה type הינו k. מעוניינים לבנות מבנה נתונים המכיל עד n איברים והתומך בפעולות הבאות: 
• Insert(x) – מכניסה את האיבר X למבנה הנתונים בזמן O(1). 
• AddToType(t,a) – מגדילה ב-a ערכו של שדה value של כל האיברים מסוג t בזמן O(1). 
• AddToElement(a,x) – מקבלת פוינטר לאיבר X ומגדילה ב-a ערך של שדה value שלו בזמן O(1) אמורטיזד. 
• Max(t) – החזרת האיבר המקסימלי מבין האיברים מסוג t בזמן O(1). 
• MaxAll() – החזרת האיבר המקסימלי במבנה (ללא הגבלה על סוג) בזמן O(1). 

ג. הוסיפו הפעולה del(X) (המקבל פוינטר לאיבר X ומוחקת אותו מהמבנה) בזמן O(logn) אמורטייזד. 
כעת על insert, addToType לרוץ בזמן O(1) אמורטייזד. ","נתחזק לכל type ערימת פיבונאצ'י עם שדה offset, וכן ערימת פיבונאצ'י שתכיל את המקסימום של כל type. בכל פעולה רלוונטית נדאג לתחזק מצביעים מאיברי המקסימום של ערימות ה-type-ים לאיברים המתאימים בערימה הגלובלית. כעת בפעולות insert/addToType/addToElement נפעל בערימת ה-type המתאימה, ובמידת הצורך נעדכן האיבר המתאים בערימה הגלובלית ע""י increase-key. ייתכן ונאלץ גם לעדכן את המצביע. בדומה עבור פעולת ה-delete: נמחק האיבר מהערימה המתאימה, ובמידת הצורך נמחק אותו (בעזרת המצביע ששמרנו) מהערימה הגלובלית ונכניס אליה את המקסימום החדש של ה-type. Max/maxAll יחזירו המקסימום של ערימה של type מסוים או של הערימה הגלובלית. זמן הריצה בערימות פיבונאצי של הפעולות שציינו מתאימות לדרישות.",,,,total points: 25.00
A,TRUE,2017,a,a,4-d,T3/ds17AA-sol.pdf,TAU,na,na,na,na,na,na,na,,"נגדיר איברים המכילים שני שדות – type, value (סוג וערך). נניח כי מספר הערכים השונים האפשריים עבור השדה type הינו k. מעוניינים לבנות מבנה נתונים המכיל עד n איברים והתומך בפעולות הבאות: 
• Insert(x) – מכניסה את האיבר X למבנה הנתונים בזמן O(1). 
• AddToType(t,a) – מגדילה ב-a ערכו של שדה value של כל האיברים מסוג t בזמן O(1). 
• AddToElement(a,x) – מקבלת פוינטר לאיבר X ומגדילה ב-a ערך של שדה value שלו בזמן O(1) אמורטיזד. 
• Max(t) – החזרת האיבר המקסימלי מבין האיברים מסוג t בזמן O(1). 
• MaxAll() – החזרת האיבר המקסימלי במבנה (ללא הגבלה על סוג) בזמן O(1). 

ד. ללא פעולת ה-delete מסעיף ג,' הציעו מימוש לפעולה הבאה: 
merge(t1,t2) – מאחדת את כל האיברים מהסוגים t1 ≠ t2 כך שלאחר הפעולה האיברים יהיו כולם מסוג t1. סה""כ סכום זמני הריצה של כל פעולות ה-merge לא יעלה על O(nlogn).","בדומה לסעיף הקודמים. בנוסף, בעת פעולת merge נעדכן המקסימום להיות המקסימום מבין שני המקסימומים, נשרשר את הרשימה הקצרה לרשימה הארוכה, נעבור על הרשימה הקצרה ונוסיף לה offset שלה ונחסיר ממנה את ה-offset של הרשימה הארוכה. את הרשימה הסופית נשרשר ל-t1. מ-t2 קובעים פוינטר לרשימה ריקה. מחיקת המקס' לוקחת O(logn) אמורטייזד. כל מיזוג כזה לוקח זמן מסדר גודל של אורכה של הרשימה הקטנה, וגודל הרשימה המשותפת שנוצרת היא לפחות פעמיים האורך הנ״ל. אם נתבונן באיבר מסוים, כמות הפעמים שנערוך אותו לאורך סדרת מיזוגים לא תעלה על O(logn) פעמים. לכן, כמות הפעמים שנערוך את כל האיברים לא תעלה על O(nlogn).",,,,total points: 25.00
A,TRUE,2018,B,B,1-a,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבנה נתונים לאכסון קבוצת איברים D. לכל איבר x בקבוצה יש מפתח שהוא מספר שלם במילת מחשב. נניח שהמפתחות של כל האיברים ב-D שונים זה מזה. הפעולות שניתן לבצע על מבנה הנתונים הן:
- Insert(D, x) - הכנס את האיבר x ל-D. (ניתן להניח ש-x אינו ב-D).
- FindByKey(D, k) - מחזיר את האיבר ב-D עם מפתח k, אם קיים כזה, אחרת null.
- FindByIndex(D, i) - מחזיר את האיבר ה-iי שהוכנס ל-D.

למשל אם הוכנסו n איברים ל-D, אז FindByIndex(D, n) יחזיר את האיבר האחרון שהוכנס, FindByIndex(D, 3) יחזיר את האיבר השלישי שהוכנס.

נסמן ב-n את מספר האיברים ב-D.

א. תאר/י מבנה נתונים דטרמיניסטי שבו FindByIndex(D, i) ו-Insert(D, x) לוקחות O(1) זמן, ו-FindByKey(D, k)- לוקחת O(n) זמן. גודל הזיכרון שבו משתמש מבנה הנתונים צריך להיות O(n). החסמים הנדרשים הם worst-case. (ניקוד חלקי ניתן לפתרונות שמציגים ניתוח חסמי amortized).","א.
נשתמש במערך עם אלגוריתמיקת resizing שנלמדה בהרצאה על amortization – במקום לחכות שיתמלאו ואז להעביר הכל בבת אחת למערך גדול יותר, לדאוג להעביר את המידע בחלקים: כל פעם שעושים אינסרט אחרי שהמערך הנוכחי התמלא ביותר מחצי, לפנות שני מקומות במערך החדשף ולהעביר אליו שני איברים.
Insert: כפי שאמרנו – מקצים בתהחלה מערך ריק בגודל קבוע (למשל 4), כל הכנסה לאחר שהתמלא בחציו לפנות שני מקומות במערך חדש ולהכניס אליהם שני איברים, כך שהמערך הנוכחי מתמלא, המערך החדש מלא בדיוק בחציו, ומוכן בכדי שנעבור לעבוד איתו. מספר קבוע של פעולות ולכן O(1) worst case (ההכנסות הן כמובן Insert-last). 
FindByKey: עוברים על כל איברי המערך עד שמוצאים, או עד שנגמר המערך. O(n) W.C..
FindByIndex: זה מערך. O(1) W.C..",,,,
A,TRUE,2018,B,B,1-b,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ב. תאר/י מבנה נתונים דטרמיניסטי שבו Insert(D, x) ו-FindByKey(D, k)- לוקחות O(logn) זמן, ו-FindByIndex(D, i) לוקחת O(1) זמן. גודל הזיכרון שבו משתמש מבנה הנתונים צריך להיות O(n). החסמים הנדרשים הם worst-case. (ניקוד חלקי יינתן לפתרונות שמציגים חסמי amortized).","ב. 
נבנה מערך כמו מקודם, אל כעת גם נבנה עץ WAVL שיחזיק את האיברים (ממוין לפי הkeys). 
הכנסה: בO(1) למערך ובO(logn) לעץ. סה""כ lon(n) W.C..
חיפוש לפי מפתח: בעץ לוקח O(logn) W.C..
חיפוש לפי אינדקס: O(1) במערך.",,,,
A,TRUE,2018,B,B,1-c,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נשנה עתה את הפעולה Insert(D, x) כך שתקבל פרמטר נוסף i באופן הבא:
- Insert(D, i, x) מכניסה את x למבנה הנתונים עם index i (נניח ש-i הוא לפחות 1, ושהוא קטן או שווה לכל מספר האיברים ב-D ועוד 1). כלומר האינדקס של איבר במבנה הנתונים לא נקבע על פי מספרה הסידורי של פעולת ה-Insert שהכנסיה אותו אלא ישירות על פי הפרמטר הנוסף. יש לשם לב שהכנסת איבר עם אינדקס i מגדילה ב-1 את האינדקסים של האיברים עם אינדקס גדול או שווה לi. 

ג. תאר מבנה נתונים דטרמיניסטי שבו Insert(D, i, x) לוקחת O(log(i + 1)) זמן amortized, FindByIndex(D,i) לוקחת O(log(i+1)) זמן worst-case ו-ammortized, ו-FiindByKey(D,k) לוקחת O(n) זמן worst-case ו-ammortized. גודל הזכרון שבו משתמש מבנה הנתונים צריך להיות O(n). ","ג.
נשתמש בFingerSearchTree שנלמד בכיתה – עץ WAVL עם פוינטר למינימום ושומר subtreesize (ממוין לפי האינדקסים). בכיתה ובשיעורי הביתה ראינו חסם O(log(i+1)) אמורטייזד לאינסרט (By Index), וחסם O(log(i+1)) במקרה הגרוע לחיפוש (By-Index). חיפוש לפי מפתח ייבצע ע""י קריאת In-Order של העץ. O(n) W.C..",,,,
A,TRUE,2018,B,B,1-d,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ד. תאר מבנה נתונים דטרמיניסטי שבו שלושת הפעולות Insert(D,i,x), FindByIndex(D, i), FindByKey(D, k) לוקחת O(logn) זמן worst-case. גודל הזיכרון שבו משתמש מבנה הנתונים צריך להיות O(n). ","ד.
נבנה שני עצי WAVL, אחד ממוין לפי אינדקס והשני לפי מפתח. הכנסה לכל עץ היא O(logn) ולכן בשניהם היא גם כן. חיפוש יתבצע בעץ המתאים, O(logn) W.C.",,,,
A,TRUE,2018,B,B,1-e,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ה. תאר מבנה נתונים שבו Insert(D,i,x) לוקחת O(log(i+1)) זמן amortized, FindByIndex(D,i) לוקחת O(log(i+1)) זמן worst-case ו-amortized, וFindByKey(D,k) לוקחת O(1) זמן בתוחלת. גודל הזכרון בו משתמש מבנה הנתונים צריך להיות O(n). ","ה.
נשמור שני מבני נתונים – עץ FingerSearch ממוין לפי אינדקס, טבלת hash למפתחות עם chaining שמכניס לראש הרשימה (זה O(1) W.C. שלא פוגע בסיבוכיות ההכנסה), שמתחילה בגודל קבוע, אך כאשר קבוע העמוס גדול מחצי, עושים rehashing לטבלה גדולה פי 2 (לכן הסיבוכיות של ההכנסה היא אמורטייזד: insert לעץ לוקח O(log(i+1)) אמורטייזד, ולטבלה O(1) אמורטייזד. ביחד O(log(i+1)) אמורטייזד). 
FindByIndex בעץ לוקח O(log(i+1)) W.C. לפי אלגוריתמיקת עץ FingerSearch.
FindByKey יקח O(1) בתוחלת כי טבלת הhash גדולה מספיק (עמוס קטן שווה מ0.5 גודד שבתוחלת יש פחות מהתנגשות אחת בכל תא בטבלה. ",,,,
A,FALSE,2018,B,B,2-a,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נדון במבנה נתונים שתומך באוסף של רשימות. כל רשימה מורכבת מאיברים. כל איבר יכול להימצא בלכל היותר רשימה אחת. הפעולות על מבנה הנתונים הן:

- \( X \leftarrow \text{Item()} \): צור איבר חדש \( X \) שלא שייך לאף רשימה.
- \( \text{InsertAfter}(X, Y) \): הכנס את \( Y \) מיד לאחר \( X \) ברשימה שבה \( X \) נמצא. לפני הפעולה נדרש ש-\( Y \) לא נמצא עדיין באף רשימה. אם \( X \) לא נמצא עדיין באף רשימה או נוצרה רשימה חדשה המכילה את שני האיברים \( X \) ו-\( Y \).
- \( \text{AfterQ}(X, Y) \): החזר \( \text{True} \) אם \( X \) נמצא אחרי \( Y \) ברשימה, \( \text{False} \) אחרת. (שימו לב, לא נדרש כאן ש-\( Y \) יהיה מיד אחרי \( X \), אם \( X \), \( Y \) לא נמצאים באותה רשימה, התשובה צריכה להיות \( \text{False} \).

בכל הסעיפים הפעולה \( \text{Item()} \) צריכה להיות ממומשת בזמן קבוע. כמו כן, \( n \) הוא תמיד אורך הרשימה שאליה שייך האיבר \( X \).

א. תאר/י מבנה נתונים שמממש את \( \text{InsertAfter}(X, Y) \) בזמן \( O(1) \) ואת \( \text{AfterQ}(X, Y) \) בזמן \( O(n) \). (שני הזמנים הם \( \text{worst-case} \)).",na,,,,
A,FALSE,2018,B,B,2-b,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ב. תאר/י מבנה נתונים שמממש את \( \text{InsertAfter}(X, Y) \) ו-\( \text{AfterQ}(X, Y) \) בזמן \( O(\log n) \). (שני הזמנים הם \( \text{worst-case} \)).",na,,,,
A,FALSE,2018,B,B,2-c,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נתאר עתה מימוש של מבנה הנתונים ע""י מערך. בכל פעם שנוצרת רשימה חדשה, ע""י פעולת \( InsertAfter(X, Y) \) כאשר \( X, Y \) לא נמצאים עדיין באף רשימה, נקצה לרשימה מערך בגודל קבוע. נכניס את X ו-Y למקומות הראשון והשני במערך. בעצמים שמציגים את X ו-Y נשמור מצביעים למערך ולאינדקסים של התאים שבהם הם נמצאים.

פעולה \( InsertAfter(X, Y) \) כאשר \( X \) נמצא כבר ברשימה ו-\( Y \) עדיין לא, ממומשת באופן הבא. אם המערך שבו \( X \) נמצא מלא, נקצה מערך חדש בגודל כפול, נעתיק את האיברים לחציו הראשון ונשנה אותם כך שיצביעו למערך החדש. לאחר מכן (בין אם הקצנו מערך חדש ובין אם לא) נמצא את התא הריק הראשון לאחר התא בו נמצא X. נזיז את כל האיברים בתאים שאחרי X ולפני אותו תא ריק מקום אחד ימינה (למקומות עם אינדקס יותר גדול) ונכניס את Y למקום שהתפנה. כל איבר שהוזז יזכור כמובן את האינדקס של המקום החדש במערך בו הוא נמצא. 

ג. מה הסיבוכיות של פעולה \( \text{InsertAfter}(X, Y) \) במימוש שהוצע?  
מה הסיבוכיות ה-\( \text{amortized} \) של פעולת \( \text{InsertAfter}(X, Y) \)? הוכח/י את תשובתך.",na,,,,
A,FALSE,2018,B,B,2-d,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ד. תן/י מימוש יעיל ככל האפשר של פעולת AfterQ(X,Y) .(מבנה הנתונים ממומש ע""י מערך כפי שתואר למעלה.) מה הסיבוכיות worst-case של פעולת AfterQ(X,Y) במימוש שהצעת?",na,,,,
A,FALSE,2018,B,B,2-e,T3/ds18bb_sol100(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נסה לייעל עתה את המימוש באמצעות חלוקת כל מערך באורך m ל-√m בלוקים (חלקי 
מערך) בגודל √m. (מספר האיברים n במערך באורך m יהיה תמיד בין m/4 ל-m/2.) 
כאשר בלוק באורך √m מתמלא לגמרי, נבנה מחדש את המערך באופן הבא. תוך שמירה על 
סדר האיברים, נשים m√n/ איברים (הנח/י כי n מחולק ב-√m). איברים במקומות הראשונים של כל בלוק. (כלומר, האיברים יחולקו שווה בשווה בין הבלוקים. בכל בלוק נשים את האיברים 
בתחילת הבלוק.) בנוסף, כאשר מספר האיברים במערך יגיע ל-m/2 נכפיל את גודל 
המערך ונבנה אותו מחדש, עם החלוקה שתוארה לבלוקים. בכל פעם שמזיזים איבר נשנה גם 
את המצביע לתא בו הוא נמצא.
ה. מה הסיבוכיות amortized של פעולת InsertAfter(X,Y)? הוכח/י את תשובתך.",na,,,,
A,FALSE,2018,B,B,3-a,T3/ds18bb_sol100(vaad).pdf,TAU,6.25,na,na,na,na,na,na,,"אלגוריתם מקבל בזה אחר זה סדרה של \( m \) מספרים שלמים, כל אחד בין \( 1 \) ל-\( n \). לאלגוריתם מותר להשתמש בזיכרון בגודל \( O(n) \) כאשר \( n \) קטן בהרבה מ-\( m \). ברגע שהאלגוריתם מסיים את הטיפול באיבר מסדרת הקלט, הוא מבקש ומיד מקבל את האיבר הבא. ניתן להניח ש-n ידוע מראש, אך \( m \) לא ידוע מראש. לפני קבלת האיברים מותר לאלגוריתם לבצע עיבוד מוקדם. זמן הריצה של האלגוריתם הוא זמן העיבוד המוקדם ועוד זמן הטיפול בכל האיברים. לאלגוריתם מותר להיות הסתברותי, אם לא ניתן להשיג את אותו זמן ריצה באופן דטרמיניסטי.

א. תאר/י אלגוריתם יעיל ככל האפשר שיחשב כמה פעמים הופיע כל מספר בין \( 1 \) ל-\( n \) בין \( m \) מספרי הקלט. נתח/י את סיבוכיות האלגוריתם. (ניתן להניח שn ידוע מראש). ",na,,,,
A,FALSE,2018,B,B,3-b,T3/ds18bb_sol100(vaad).pdf,TAU,6.25,na,na,na,na,na,na,,"ב. נניח עתה כי בסדרת הקלט יכולים להופיע רק n ערכים שלמים שונים, אך אלו אינם דווקא המספרים בין 1 ל-n. ערכים אלו אינם ידועים מראש לאלגוריתם. (הנח/י שכל ערך נכנס במילת מחשב ושכל פעולה חשבונית על מילה לוקחת זמן קבוע.) תאר/י אלגוריתם יעיל ככל האפשר שיחשב כמה פעמים הופיע כל אחד מ-n הערכים בין m מספרי הקלט. נתח/י את סיבוכיות האלגוריתם. ",na,,,,
A,FALSE,2018,B,B,3-c,T3/ds18bb_sol100(vaad).pdf,TAU,6.25,na,na,na,na,na,na,,ג. נניח עתה כי n הערכים שיכולים להופיע בסדרת הקלט ידועים מראש לאלגוריתם. על האלגוריתם לטפל בכל איבר קלט בזמן קבוע במקרה הגרוע ביותר. תאר/י אלגוריתם יעיל לכל האפשר המחשב כמה פעמים הופיע כל אחד מ-n הערכים בקלט. נתח/י את סיבוכיות האלגוריתם. ,na,,,,
A,FALSE,2018,B,B,3-d,T3/ds18bb_sol100(vaad).pdf,TAU,6.25,na,na,na,na,na,na,,"ד. נניח עתה שוב כי בסדרת הקלט יכולים להופיע רק ח ערכים שונים, שערכם אינו ידוע מראש, ושהפעם הפעולה היחידה שניתן לבצע עליהם היא השוואה שבודקת אם ערך אחד גדול או שווה לערך אחר. תאר/י אלגוריתם יעיל ככל האפשר המחשב כמה פעמים הופיע כל אחד מ-n הערכים בקלט. נתח/י את סיבוכיות האלגוריתם. (אין הפעם דרישה לטיפול בכל איבר בזמן קבוע.)",na,,,,
A,FALSE,2018,B,B,4,T3/ds18bb_sol100(vaad).pdf,TAU,25,na,na,na,na,na,na,,,na,,,,
A,FALSE,2015,A,A,1-a,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נעסוק ברשימות הניתנות לסיבוב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 

A   <-Make-Item(info) – צור איבר A שאותו ניתן להכניס לרשימה.
Make-List()->L צור רשימה ריקה.
Insert(L, A, i) – הכנס את האיבר A למקום ה־i ברשימה L אם (הנח/י ש-i תקין.)
Retrieve(L, i) – החזר את האיבר הנמצא במקום ה־i ברשימה L אם (הנח/י ש-i תקין.)
Next-Item(A) – החזר את האיבר שעוקב ל-A אם (הנח/י ש-A נמצא ברשימה יחידה.)
Insert-After(A, B) – הכנס את B מיד אחרי A ברשימה (היחידה) שבה A נמצא.
Rotate(L, i) – סובב את הרשימה L באופן מעגלי. האיבר שהיה קודם במקום ה־i הופך להיות האיבר שבראש הרשימה.

הנחם מתבקשים לתאר שלושה מימושים שונים של רשימות ניתנות לסיבוב. כל אחד מהמימושים נידרש לתמוך בצורה יעילה מאוד באחת או יותר מהפעולות. את שאר הפעולות יש לממש בצורה היעילה ביותר האפשרית. מבנה הנתונים צריך להיות דטרמיניסטי. זמני הפעולה יכולים להיות amortized. כמות הזיכרון צריכה להיות פרופורציונלית למספר האיברים ברשימה.

| Operation          | Implementation 1 | Implementation 2 | Implementation 3 |
|--------------------|------------------|------------------|------------------|
| Insert(L,A,i)      |                  |                  | O(logn)          |
| Retrieve(L,i)      |                  | O(1)             | O(logn)          |
| Next-Item(A)       | O(1)             |                  |                  |
| Insert-After(A,B)  | O(1)             |                  |                  |
| Rotate(L,i)        |                  |                  |                  |
א. תאר/י בתמציתיות את מימוש א'. מלא/י בטבלה את זמני שאר הפעולות. ",na,,,,
A,FALSE,2015,A,A,1-b,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,ב. תאר/י בתמציתיות את מימוש ב'. מלא/י בבלה את זמני שאר הפעולות. ,na,,,,
A,FALSE,2015,A,A,1-c,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,ג. תאר/י בתמציתיות את מימוש ג'. מלא/י בטבלה את זמני שאר הפעולות. ,na,,,,
A,FALSE,2015,A,A,1-d,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,"נשנה עתה במעט את הגדרת מבנה הנתונים. יצירת איבר תעשה עתה ע""י קריאה לפונקציה Make-Item(info,key)->A. לכל איבר נוסיף שדה key שהוא מספר שלם. נוסיף גם את הפעולות הבאות: 
Find(L,k) – החזר איבר עם מפתח k מהרשימה, אם קיים כזה. 
Next-Key(k) – החזר את האיבר ברשימה עם המפתח הקטן ביותר שגדול מ-k, אם קיים כזה. (הנח/י שכל המפתחות של האיברים ברשימה שונים זה מזה.)
ד. הסבר/י כיצד ניתן לשדרג את מבני הנתונים הקודמים כך שיתמכו בפעולת הFind מהר ככל האפשר. ניתן להשתמש ברנדומיזציה. (בסעיף זה אין צורך לתמוך בפעולות Next-By-Key.) מה הזמן המתקבל לפעולת Find בכל אחד מהמקרים? ",na,,,,
A,FALSE,2015,A,A,1-e,T3/ds15AA.pdf,TAU,5,na,na,na,na,na,na,,ה. הסבר/י כיצד ניתן לשדרג את מבני הנתונים הקודמים כך שיתמכו בפעולת Find וNext-By-Key מהר ככל האפשר. ניתן להשתמש ברנדומיזציה. מה הזמנים המתקבלים לפעולת Find ופעולת Next-By-Key בכל אחד מהמקרים? ,na,,,,
B,FALSE,2015,A,A,2-a,T3/ds15AA.pdf,TAU,6,"\begin{enumerate}
    \item Provide the best possible upper and lower bounds on the number of nodes in a subtree in an AVL tree and a WAVL tree with rank \( k \). Justify your answers in the space below.
\end{enumerate}
\begin{tabular}{|c|c|c|}
\hline
Structure & Lower bound & Upper bound \\
\hline
AVL & & \\
\hline
WAVL & & \\
\hline
\end{tabular}

Explain each of the cells you filled in the table.",na,na,na,"f,p",tested,,"א. תן/י חסמים עליונים ותחתונים טובים ככל האפשר על מספר האיברים בעולל בעץ AVL ועץ WAVL עם rank k. נמק/י את תשובותיך במסגרת למטה. 
| Structure | Lower bound | Upper bound |
|-----------|-------------|-------------|
| AVL       |             |             |
| WAVL      |             |             |
הסבר/י כל אחד מהתאים שמילאת בטבלה. ",na,,,,
B,FALSE,2015,A,A,2-b,T3/ds15AA.pdf,TAU,6,na,na,na,na,f,untested,,"ב. תאר/י אלגוריתם יעיל ככל האפשר לבניית עץ ה-AVL שמתקבל ע""י הכנסת האיברים 1,2,…,n בסדר עולה לעץ AVL ריק בתחילה. מה סיבוכיות האלגוריתם? (רמז: ניתן לענות על השאלה ללא צורך להיכנס לפרטי המימוש של מקרי האיזון השונים.)",na,,,,
B,FALSE,2015,A,A,2-c,T3/ds15AA.pdf,TAU,6,na,na,na,na,"f,p",untested,,"ג. הוכח או הפרך: מכל עץ WAVL ניתן לקבל AVL ע""י שינוי ranks, מבלי לשנות את מבנה העץ. (הוכח/י או הבא/י דוגמה נגדית.)",na,,,,
B,FALSE,2015,A,A,2-d,T3/ds15AA.pdf,TAU,6,"\[ 
\text{d. Prove or disprove: Performing exactly the same series of insertions, deletions, and searches starting with an empty data structure, once using an AVL tree and once using a WAVL tree. The number of times ranks of nodes are changed in the AVL tree is at most a constant multiplied by the number of times ranks of nodes are changed in the WAVL tree. (Prove or provide a counterexample.)}
\]",na,na,na,"f,p",tested,,"ד. הוכח או הפרך: מבצעים בדיוק את אותה סדרת הכנסות, מחיקות וחיפושים שמתחילים במבנה נתונים ריק, פעם תוך שימוש בעץ AVL ופעם תוך שימוש בעץ WAVL. מספר הפעמים שבהם משנים rank של צמתים בעץ AVL הוא לכל היותר קבוע כפול מספר הפעמים שבהם משנים rank של צמתים בעץ WAVL. (הוכח/י או הבא/י דוגמה נגדית.)",na,,,,
B,FALSE,2015,A,A,3-a,T3/ds15AA.pdf,TAU,6,"\begin{enumerate}
    \item Given the family of functions $H = \{h_1, h_2, h_3, h_4\}$ from the domain $\{0,1,2,3,4\}$ to the range $\{0,1,2\}$. Is $H$ a universal family? Prove your answer.
    \[
    \begin{array}{c|c|c|c|c|c}
         & 0 & 1 & 2 & 3 & 4 \\
        \hline 
        h_1 & 0 & 1 & 2 & 0 & 1 \\
        h_2 & 0 & 2 & 1 & 1 & 0 \\
        h_3 & 0 & 0 & 1 & 1 & 2 \\
        h_4 & 0 & 1 & 0 & 2 & 1 \\
    \end{array}
    \]
\end{enumerate}",na,na,na,,tested,,"א. נתונה משפחת הפונקציות H = {h1, h2, h3, h4} מהתחום {0,1,2,3,4} לטווח {0,1,2}. האם H היא משפחה אוניברסאלית? הוכח/י את תשובתך. 
|     | 0 | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|---|
| h₁  | 0 | 1 | 2 | 0 | 1 |
| h₂  | 0 | 2 | 1 | 1 | 0 |
| h₃  | 0 | 0 | 1 | 1 | 2 |
| h₄  | 0 | 1 | 0 | 2 | 1 |",na,,,,
B,FALSE,2015,A,A,3-b,T3/ds15AA.pdf,TAU,6,"\textbf{b. Given the family of functions } G = \{g_1, g_2, g_3, g_4\} \textbf{ from the domain } \{0,1,2,3,4\} \textbf{ to the range } \{0,1,2,3\}. \textbf{ Is } G \textbf{ a universal family? Prove your answer.}

\begin{tabular}{| c | c | c | c | c | c |}
\hline
     & 0 & 1 & 2 & 3 & 4 \\
\hline
g_1  & 0 & 1 & 2 & 3 & 0 \\
g_2  & 0 & 2 & 0 & 1 & 3 \\
g_3  & 0 & 3 & 1 & 0 & 2 \\
g_4  & 0 & 0 & 3 & 2 & 1 \\
\hline
\end{tabular}",na,na,na,,tested,,"ב. נתונה משפחת הפונקציות G = {g1, g2, g3, g4} מהתחום {0,1,2,3,4} לטווח {0,1,2,3}. האם G היא משפחה אוניברסאלית? הוכח/י את תשובתך. 
|     | 0 | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|---|
| g₁  | 0 | 1 | 2 | 3 | 0 |
| g₂  | 0 | 2 | 0 | 1 | 3 |
| g₃  | 0 | 3 | 1 | 0 | 2 |
| g₄  | 0 | 0 | 3 | 2 | 1 |",na,,,,
A,FALSE,2015,A,A,3-c,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,"ג. נתונה פוקציית hash h מקבוצה U לטווח [m]={0,1,…,m-1}. הנח/י שניתן לחשב את h על כל איבר נתון של U בO(1) זמן. נתונה קבוצה D \subset U בגודל n. תאר/י אלגוריתם דטרמיניסטי יעיל ככל האפשר למציאת מספר ההתנגשויות של h על איברי D. מה סיבוכיות האלגוריתם שתיארת? ",na,,,,
A,FALSE,2015,A,A,3-d,T3/ds15AA.pdf,TAU,6,na,na,na,na,na,na,,"ד. תהא U={0,1,…,u}. הניחו שכל איבר של U ניתן לייצוג במילת מחשב אחת. נתונה תת קבוצה D \subset U בגודל n. תארו אלגוריתם הסתברותי יעיל ככל האפשר שבונה פונקציה h:U \to {0,1,…,100n} שהיא חד-חד ערכית על D. (כלומר לכל x,y \in D מתקיים h(x) \neq h(y).) כמות הזיכרון הדרושה לייצוג הפונקציה h צריכה להיות O(n). חישוב h(x), בהינתן x \in D צריכה לקחת O(1) זמן במקרה הגרוע ביותר. ",na,,,,
B,FALSE,2015,A,A,4-a,T3/ds15AA.pdf,TAU,5,"In this question, we will describe a lazy way to perform deletions in binomial heaps and use it to implement alternative operations `delete`, `decrease-key`, `delete-min`. For each node of the binomial heap, we will add a bit called `deleted`. When inserting a new element into the heap, the bit of the node containing the new element will be `false`. We will implement the `delete-non-root(Q,x)` operation, where \( x \) is a non-root node of the heap, simply by changing the bit in the node from `deleted` to `true`.
We will implement `decrease-key(Q,x,k)` as follows: if \( x \) is a root, we simply change its key and update the pointer to the minimum element if necessary. Otherwise, we perform `delete-non-root(Q,x)` and create a new node containing the new element that will sit in \( x \) with its new key \( k \), and insert it into the heap using the `insert(Q,y)` operation.
We will implement `delete-min(Q)` as follows: after removing the node containing the minimum element, we will also remove empty roots (i.e., roots marked as \( deleted \)). This removal may create additional empty roots that we will remove recursively. We will perform `successive linking` on the collection of trees obtained after removing the empty roots. Finally, we will find the root containing the minimum element among those remaining.
The `meld` and `insert` implementations remain unchanged.
We perform a series of m operations on the structure.
a. What is the maximum rank of a binomial tree in the heap during the execution of the series? Explain.",na,na,na,i,tested,,"בשאלה זאת נתאר דרך עצלה לביצוע מחיקות מערימות בינומיות ונשתמש בה למימוש חליפי של פעולות `delete`, `decrease-key`, `delete-min`. לכל צומת של ערימה בינומית נוסיף ביט שייקרא `deleted`. כאשר מכניסים איבר חדש לערימה, הביט של הצומת שמכיל את האיבר החדש יהיה `false`. נממש פעולת `delete-non-root(Q,x)`, כאשר \( x \) הוא צומת בערימה שאינו שורש, פשוט ע""י שינוי הביט בצומת מ-`deleted` ל-`true`.
נממש `decrease-key(Q,x,k)` באופן הבא: אם \( x \) הוא שורש, פשוט נשנה את המפתח שלו, ונעדכן את המצביע לאיבר המינימלי, במידת הצורך. אחרת, נבצע `delete-non-root(Q,x)` וניצור צומת חדש שמכיל את האיבר החדש שישב ב-\( x \) עם המפתח החדש שלו \( k \), ונכניסו לערימה ע""י פעולת `insert(Q,y)`.
נממש את `delete-min(Q)` באופן הבא: לאחר הסרת הצומת המכיל את האיבר המינימלי, נסיר גם שורשים ריקים (כלומר שורשים שמסומנים כ-\( deleted \)). הסרה זו יכולה ליצור שורשים ריקים נוספים אותם נסיר באופן רקורסיבי. לאוסף העצים שמתקבל לאחר הסרת השורשים הריקים נבצע `successive linking`. לבסוף נמצא את השורש המכיל את האיבר המינימלי מבין אלו שנותרו.
ממוש meld וinsert נשאר ללא שינוי.
מבצעים סדרה של m פעולות על המבנה.
א. מהי דרגתו המקסימלית של עץ בינומי בערימה במהלך ביצוע הסדרה? נמק/י. ",na,,,,
B,FALSE,2015,A,A,4-b,T3/ds15AA.pdf,TAU,8,"In this question, we will describe a lazy method for performing deletions in binomial heaps and use it for an alternative implementation of the `delete`, `decrease-key`, `delete-min` operations. For each node of a binomial heap, we will add a bit that will be called `deleted`. When inserting a new element into the heap, the bit of the node containing the new element will be `false`. We will implement the `delete-non-root(Q,x)` operation, where \( x \) is a non-root node in the heap, simply by changing the bit at the node from `deleted` to `true`. 

We will implement `decrease-key(Q,x,k)` as follows: if \( x \) is a root, we simply change its key and update the pointer to the minimum element, if necessary. Otherwise, we perform `delete-non-root(Q,x)` and create a new node containing the new element that will sit at \( x \) with its new key \( k \), and insert it into the heap using the `insert(Q,y)` operation.

We will implement `delete-min(Q)` as follows: after removing the node containing the minimum element, we will also remove empty roots (that is, roots marked as \( deleted \)). This removal can create additional empty roots, which we will remove recursively. For the collection of trees obtained after removing the empty roots, we will perform `successive linking`. Finally, we will find the root containing the minimum element among those that remain. 

The meld and insert operations remain unchanged. We perform a series of \( m \) operations on the structure.

b. What is the worst-case time complexity of each of the following operations: insert, delete-min, delete-non-root, and decrease-key? Explain.",na,na,na,"i,a",tested,,"בשאלה זאת נתאר דרך עצלה לביצוע מחיקות מערימות בינומיות ונשתמש בה למימוש חליפי של פעולות `delete`, `decrease-key`, `delete-min`. לכל צומת של ערימה בינומית נוסיף ביט שייקרא `deleted`. כאשר מכניסים איבר חדש לערימה, הביט של הצומת שמכיל את האיבר החדש יהיה `false`. נממש פעולת `delete-non-root(Q,x)`, כאשר \( x \) הוא צומת בערימה שאינו שורש, פשוט ע""י שינוי הביט בצומת מ-`deleted` ל-`true`.
נממש `decrease-key(Q,x,k)` באופן הבא: אם \( x \) הוא שורש, פשוט נשנה את המפתח שלו, ונעדכן את המצביע לאיבר המינימלי, במידת הצורך. אחרת, נבצע `delete-non-root(Q,x)` וניצור צומת חדש שמכיל את האיבר החדש שישב ב-\( x \) עם המפתח החדש שלו \( k \), ונכניסו לערימה ע""י פעולת `insert(Q,y)`.
נממש את `delete-min(Q)` באופן הבא: לאחר הסרת הצומת המכיל את האיבר המינימלי, נסיר גם שורשים ריקים (כלומר שורשים שמסומנים כ-\( deleted \)). הסרה זו יכולה ליצור שורשים ריקים נוספים אותם נסיר באופן רקורסיבי. לאוסף העצים שמתקבל לאחר הסרת השורשים הריקים נבצע `successive linking`. לבסוף נמצא את השורש המכיל את האיבר המינימלי מבין אלו שנותרו.
ממוש meld וinsert נשאר ללא שינוי.
מבצעים סדרה של m פעולות על המבנה.
ב. מהי סיבוכיות הזמן במקרה הגרוע של כל אחת מהפעולות הבאות: insert, delete-min, delete-non-root ו-decrease-key? נמק/י.",na,,,,
B,FALSE,2015,A,A,4-c,T3/ds15AA.pdf,TAU,6,"\textbullet\ In this question, we describe a lazy method for performing deletions from binomial heaps and use it to implement alternative operations for `delete`, `decrease-key`, and `delete-min`. For each node of a binomial heap, we add a bit called `deleted`. When inserting a new element into the heap, the bit of the node containing the new element will be `false`. We implement the operation `delete-non-root(Q,x)`, where \( x \) is a non-root node in the heap, simply by changing the bit in the node from `deleted` to `true`.

\textbullet\ We implement `decrease-key(Q,x,k)` as follows: if \( x \) is a root, we simply change its key and update the pointer to the minimal element, if necessary. Otherwise, we perform `delete-non-root(Q,x)` and create a new node containing the element that used to be in \( x \) with its new key \( k \), and insert it into the heap with the `insert(Q,y)` operation.

\textbullet\ We implement `delete-min(Q)` as follows: after removing the node containing the minimal element, we also remove empty roots (i.e., roots marked as \( deleted \)). This removal can create additional empty roots, which we remove recursively. We perform `successive linking` on the collection of trees obtained after removing the empty roots. Finally, we find the root containing the minimal element among those that remain.

\textbullet\ The implementations of `meld` and `insert` remain unchanged.

\textbullet\ Perform a series of \( m \) operations on the structure.

\textbf{c.} What is the amortized time complexity of each of the following operations: insert, delete-min, delete-non-root, and decrease-key? Justify your answer.",na,na,na,"i,b",tested,,"בשאלה זאת נתאר דרך עצלה לביצוע מחיקות מערימות בינומיות ונשתמש בה למימוש חליפי של פעולות `delete`, `decrease-key`, `delete-min`. לכל צומת של ערימה בינומית נוסיף ביט שייקרא `deleted`. כאשר מכניסים איבר חדש לערימה, הביט של הצומת שמכיל את האיבר החדש יהיה `false`. נממש פעולת `delete-non-root(Q,x)`, כאשר \( x \) הוא צומת בערימה שאינו שורש, פשוט ע""י שינוי הביט בצומת מ-`deleted` ל-`true`.
נממש `decrease-key(Q,x,k)` באופן הבא: אם \( x \) הוא שורש, פשוט נשנה את המפתח שלו, ונעדכן את המצביע לאיבר המינימלי, במידת הצורך. אחרת, נבצע `delete-non-root(Q,x)` וניצור צומת חדש שמכיל את האיבר החדש שישב ב-\( x \) עם המפתח החדש שלו \( k \), ונכניסו לערימה ע""י פעולת `insert(Q,y)`.
נממש את `delete-min(Q)` באופן הבא: לאחר הסרת הצומת המכיל את האיבר המינימלי, נסיר גם שורשים ריקים (כלומר שורשים שמסומנים כ-\( deleted \)). הסרה זו יכולה ליצור שורשים ריקים נוספים אותם נסיר באופן רקורסיבי. לאוסף העצים שמתקבל לאחר הסרת השורשים הריקים נבצע `successive linking`. לבסוף נמצא את השורש המכיל את האיבר המינימלי מבין אלו שנותרו.
ממוש meld וinsert נשאר ללא שינוי.
מבצעים סדרה של m פעולות על המבנה.
ג. מהי סיבוכיות הזמן amortized של כל אחת מהפעולות הבאות: insert, delete-min, delete-non-root וdecrease-key?  נמק/י. ",na,,,,
B,FALSE,2015,A,A,4-d,T3/ds15AA.pdf,TAU,3,"\begin{quote}
In this problem, we describe a lazy approach for performing deletions from binomial heaps and use it to implement alternative versions of the `delete`, `decrease-key`, and `delete-min` operations. For each node of a binomial heap, we add a bit called `deleted`. When a new element is inserted into the heap, the bit of the node containing the new element will be `false`. We implement the `delete-non-root(Q,x)` operation, where \( x \) is a non-root node in the heap, simply by changing the bit at the node from `deleted` to `true`.

We implement `decrease-key(Q,x,k)` as follows: if \( x \) is a root, we simply change its key and update the pointer to the minimal element, if necessary. Otherwise, we perform `delete-non-root(Q,x)` and create a new node containing the new element that will sit at \( x \) with its new key \( k \), and insert it into the heap using the `insert(Q,y)` operation.

We implement `delete-min(Q)` as follows: after removing the node containing the minimum element, we also remove empty roots (i.e., roots marked as \( deleted \)). This removal can create additional empty roots, which we remove recursively. We then perform `successive linking` on the collection of trees obtained after removing the empty roots. Finally, we find the root containing the minimum element among the remaining ones.

The implementations of meld and insert remain unchanged. We perform a sequence of \( m \) operations on the structure.

(d) Modify the data structure so that its space complexity is \( O(n) \) at any given moment, where \( n \) is the number of elements in the data structure at that moment. How will this change affect the complexity of the other operations? Explain.
\end{quote}",na,na,na,"i,a",tested,,"בשאלה זאת נתאר דרך עצלה לביצוע מחיקות מערימות בינומיות ונשתמש בה למימוש חליפי של פעולות `delete`, `decrease-key`, `delete-min`. לכל צומת של ערימה בינומית נוסיף ביט שייקרא `deleted`. כאשר מכניסים איבר חדש לערימה, הביט של הצומת שמכיל את האיבר החדש יהיה `false`. נממש פעולת `delete-non-root(Q,x)`, כאשר \( x \) הוא צומת בערימה שאינו שורש, פשוט ע""י שינוי הביט בצומת מ-`deleted` ל-`true`.
נממש `decrease-key(Q,x,k)` באופן הבא: אם \( x \) הוא שורש, פשוט נשנה את המפתח שלו, ונעדכן את המצביע לאיבר המינימלי, במידת הצורך. אחרת, נבצע `delete-non-root(Q,x)` וניצור צומת חדש שמכיל את האיבר החדש שישב ב-\( x \) עם המפתח החדש שלו \( k \), ונכניסו לערימה ע""י פעולת `insert(Q,y)`.
נממש את `delete-min(Q)` באופן הבא: לאחר הסרת הצומת המכיל את האיבר המינימלי, נסיר גם שורשים ריקים (כלומר שורשים שמסומנים כ-\( deleted \)). הסרה זו יכולה ליצור שורשים ריקים נוספים אותם נסיר באופן רקורסיבי. לאוסף העצים שמתקבל לאחר הסרת השורשים הריקים נבצע `successive linking`. לבסוף נמצא את השורש המכיל את האיבר המינימלי מבין אלו שנותרו.
ממוש meld וinsert נשאר ללא שינוי.
מבצעים סדרה של m פעולות על המבנה.
ד. שנה את מבנה הנתונים כך שסיבוכיות המקום תהיה בכל רגע נתון O(n) כאשר n הוא מספר האיברים במבנה הנתונים באותו רגע? כיצד שינוי זה ישפיע על סיבוכיות שאר הפעולות? נמק/י. ",na,,,,
B,FALSE,2017,B,A,1-a,T3/ds17 BA sol 100(vaad).pdf,TAU,6,"\begin{enumerate}
\item Given a binary search tree $T$ containing $n$ elements, describe an efficient algorithm TreeToSortedArray whose output is a sorted array of size $n$ containing the elements of $T$. Analyze the time complexity of the algorithm.
\end{enumerate}",na,na,na,"a,e",tested,,"א. בהינתן עץ חיפוש בינארי T המכיל n איברים, תאר אלגוריתם TreeToSortedArray 
יעיל ככל האפשר שהפלט שלו הינו מערך ממוין בסדר עולה בגודל n המכיל את 
האיברים של T. נתח את סיבוכיות זמן הריצה של האלגוריתם.",na,,,,
B,FALSE,2017,B,A,1-b,T3/ds17 BA sol 100(vaad).pdf,TAU,6,b. A binary tree is called completely balanced if the difference between the depth of any two leaves is at most 1. Describe an algorithm SortedArrayToTree whose output is a completely balanced binary search tree containing the elements of the sorted array.,na,na,na,"a,e",tested,,ב. עץ בינארי נקרא מאוזן לחלוטין אם ההפרש בין העומק של כל שני עלים הוא לכל היותר 1. תאר אלגוריתם SortedArrayToTree שהפלט שלו הוא עץ חיפוש בינארי מאוזן לחלוטין המכיל את האיברים של המערך הממוין. ,na,,,,
A,FALSE,2017,B,A,1-c,T3/ds17 BA sol 100(vaad).pdf,TAU,7,na,na,na,na,na,na,,"ג. בהינתן k מערכים ממוינים בגודל ח, תאר אלגוריתם mergeKSortedArrays שהפלט שלו הוא מערך ממוין נוסף בגודל kn המכיל את האיברים של k המערכים הממוינים. על האלגוריתם לרוץ בזמן O(nk log k).
הערה: פתרון יעיל עבור k=2 בלבד יזכה בחצי מהנקודות.",na,,,,
A,FALSE,2017,B,A,1-d,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"ד. נתונים k מערכים A1, ..., Ak עם ח ערכים כל אחד (כל הערכים שונים). הצע מימוש למבנה הנתונים D בעזרת k, התומך בפעולות הבאות:
•	Init(D, A1,..., Ak): אתחל את מבנה הנתונים D בעזרת k המערכים. יש לממש פעולה זו בזמן ריצה של O(nk) בתוחלת וסיבוכיות מקום O(nk).
•	whereIsValue(i, D): בהינתן ערך i (נתון הערך בלבד לא מצביע לאיבר), יש להוציא כפלט את האינדקס של מערך שמכיל את הערך i אם הערך קיים באחד המערכים, אחרת הפלט הינו null. יש לממש זאת בזמן ריצה O(1) במקרה הגרוע. 
הערה: נשים לב שלא ניתן להוסיף מערכים חדשים למבנה נתונים מאותחל. ",na,,,,
B,FALSE,2017,B,A,2-a,T3/ds17 BA sol 100(vaad).pdf,TAU,6,"\[
\text{In this question, we define a binary search tree named XAVL, which will be similar to a WAVL tree discussed in class or with some changes. Let } T \text{ be a binary search tree. We say that } T \text{ is a binary search tree of type XAVL if there is an assignment of ranks to the nodes of the tree such that:}
\]
\begin{itemize}
    \item \text{The rank of each leaf is } 0, \text{ and the rank of external leaves (EXT, children of a leaf) is } -1.
    \item \text{The rank differences between every internal node (non-leaf) and its two children are one of the following: } 2,1 \text{ or } 1,2 \text{ or } 2,2. \text{ (Note the difference: in an AVL tree, the allowed rank differences are } 2,1 \text{ or } 1,2 \text{ or } 1,1 \text{ and in a WAVL tree, the allowed rank differences are } 2,1 \text{ or } 1,2 \text{ or } 1,1 \text{ or } 2,2). 
\end{itemize}
\[
\text{a. Let } T \text{ be an XAVL tree such that the rank of the root is } r. \text{ What is the length of the shortest path from the root to a leaf? What is the length of the longest path from the root to a leaf?}
\]",na,na,na,"f,p,e",tested,,"בשאלה זו נגדיר עץ חיפוש בינארי בשם XAVL שיהיה דומה לעץ WAVL שלם בכיתה או עם מספר שינויים. יהי T עץ חיפוש בינארי.  נאמר ש T הינו עץ חיפוש בינארי מסוג XAVL אם קיימת השמה של דרגות לצמתי העץ כך שמתקיים:
•	דרגת כל עלה היא 0, ודרגת ""external leaves"") EXT, בנים של עלה) היא 1-.
•	הפרשי הדרגות בין כל צומת פנימי (שאינו עלה)  לשני בניו הם אחד מבין: 2,1 או 1,2 או 2,2  (שימו לב להבדל, בעץ AVL מותר הפרשי דרגות 2,1 או 1,2 או 1,1 ובעץ WAVL מותר הפרשי דרגות 2,1 או 1,2 או 1,1 או 2,2). 
א. יהיה T עץ XAVL כך שדרגת השורש הינה r. מהו אורך המסלול הקצר ביותר מהשורש לעלה? מהו אורך המסלול הארוך ביותר משורש לעלה?",na,,,,
B,FALSE,2017,B,A,2-b,T3/ds17 BA sol 100(vaad).pdf,TAU,6,"\textbf{In this question we will define a binary search tree called XAVL that will be similar to the WAVL tree presented in class or with a few changes. Let \( T \) be a binary search tree. We say that \( T \) is a binary search tree of type XAVL if there exists an assignment of ranks to the nodes of the tree such that:}
\begin{itemize}
    \item \textbf{The rank of every leaf is 0, and the rank of ""external leaves"" (EXT, children of a leaf) is \(-1\).}
    \item \textbf{The rank differences between every internal node (which is not a leaf) and its two children are one of: \( 2,1 \) or \( 1,2 \) or \( 2,2 \) (note the difference, in an AVL tree rank differences of \( 2,1 \) or \( 1,2 \) or \( 1,1 \) are allowed, and in a WAVL tree rank differences of \( 2,1 \) or \( 1,2 \) or \( 1,1 \) or \( 2,2 \) are allowed).}
\end{itemize}
\textbf{b. Provide an asymptotic lower bound on the number of nodes in an XAVL tree whose root rank is \( r \). Deduce that the height of an XAVL tree containing \( n \) nodes is \( O(\log n) \).}",na,na,na,"f,p,e",tested,,"בשאלה זו נגדיר עץ חיפוש בינארי בשם XAVL שיהיה דומה לעץ WAVL שלם בכיתה או עם מספר שינויים. יהי T עץ חיפוש בינארי.  נאמר ש T הינו עץ חיפוש בינארי מסוג XAVL אם קיימת השמה של דרגות לצמתי העץ כך שמתקיים:
•	דרגת כל עלה היא 0, ודרגת ""external leaves"") EXT, בנים של עלה) היא 1-.
•	הפרשי הדרגות בין כל צומת פנימי (שאינו עלה)  לשני בניו הם אחד מבין: 2,1 או 1,2 או 2,2  (שימו לב להבדל, בעץ AVL מותר הפרשי דרגות 2,1 או 1,2 או 1,1 ובעץ WAVL מותר הפרשי דרגות 2,1 או 1,2 או 1,1 או 2,2). 
ב. תנו חסם תחתון (אסימפטוטי) על מספר הצמתים בעץ XAVL שדרגת השורש שלו היא  r. הסיקו שגובהו של עץ XVAL שמכיל n צמתים הינו  O(log n).",na,,,,
A,FALSE,2017,B,A,2-c,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"ג. תארו אלגוריתם יעיל ככל האפשר המקבץ עץ בינארי, ומחזיר השמה חוקית כלשהי של דרגות לצמתי העץ אם יש כזו, ואחרת מחזיר שאין השמה חוקית לעץ  XAVL. שימו לב כי יש להחזיר השמה חוקית, ולא תשובה בינארית האם קיימת השמה חוקית או לא.  נתחו את זמן הריצה של האלגוריתם. ",na,,,,
A,FALSE,2017,B,A,2-d,T3/ds17 BA sol 100(vaad).pdf,TAU,7,na,na,na,na,na,na,,"ד. הוכח/הפרך: יהא T עץ מסוג XAVL, אזי קיימת השמה חוקית יחידה של דרגות לצמתי העץ. 
(הוכח שההשמה של הדרגות הינה יחידה, או הפרך על ידי דוגמא נגדית של עץ חיפוש בינארי עם שתי השמות חוקיות שונות של דרגות לצמתי העצים)",na,,,,
A,FALSE,2017,B,A,3-a,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זו יש לתאר מבנה נתונים שתומך בפעולות הבאות על קבוצה S שבה לכל איבר יש ערך מתחום סדור. הערה: בכל רגע בקבוצה S קיים לכל היותר איבר אחד שערכו i.

•	Init(S): אתחל את S לקבוצה הריקה בזמן O(1).
•	Insert(x, S): מוסיף איבר x ל-S.
•	Delete(x, S): מוחק את x מ-S. בפעולה זו נניח שנתון לנו מצביע לאיבר x וכן ש-x נמצא ב- S לפני הפעולה.
•	EverDeleted(i, S): מחזיר 'כן' אם נעשתה בעבר פעולת Delete על איבר שערכו i (בין אם לאחר מחיקתו הוכנס מחדש ל S איבר שערכו  iאו לא), אחרת מחזיר 'לא'. בפעולה זו נתון ערך i ולא מצביע לאיבר. 

א.	תאר מבנה נתונים עבורו לפעולות Delete, Insert יש זמן ריצה של O(logn) במקרה הגרוע ולפעולה EverDeleted יש זמן ריצה של O(log k) במקרה הגרוע, כאשר k הוא מספר הפעולות Delete שבוצעו מאז שמבנה הנתונים אותחל.  
שים לב: k הוא מספר פעולות ה Delete שבוצע וייתכן שהוא קטן באופן משמעותי מהמספר הכולל של פעולות שבוצעו, כלומר ייתכן ש k<<n.",na,,,,
A,FALSE,2017,B,A,3-b,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"ב.	נוסיף למבנה נתונים את הפעולה הבאה:
StillDeleted(i, S): מחזיר 'כן' אם  לאחר המחיקה האחרונה של איבר שערכו i  מ S  לא הוכנס מחדש איבר כלשהו שערכו i  , אחרת מחזיר 'לא'.
תאר מבנה נתונים עבורו לפעולות Insert, Delete יש זמן ריצה של O(log n)  במקרה הגרוע, ולפעולות    EverDeleted ו- StillDeleted  יש זמן ריצה של O(logk)  במקרה הגרוע, כאשר k הוא מספר פעולות ה Delete שבוצעו מאז שמבנה הנתונים אותחל. ",na,,,,
A,FALSE,2017,B,A,3-c,T3/ds17 BA sol 100(vaad).pdf,TAU,7,na,na,na,na,na,na,,"ג.	תאר מבנה נתונים עבורו ל Delete יש זמן ריצה של O(1) במקרה הגרוע ביותר  לפעולה Insert יש זמן ריצה של O(logn) ב amortized, ול-  EverDeleted ו- StillDeleted  יש זמן ריצה של O(logk) amortized , כאשר k  הוא מספר פעולות ה Delete שבוצעו מאז שמבנה הנתונים אותחל. ",na,,,,
A,FALSE,2017,B,A,3-d,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"ד.	נניח לצורך הסעיף שמספר הפעמים שהאלגוריתם יעשה Insert חסום ע""י פרמטר N שידוע למבנה הנתונים. תאר מבנה נתונים עבורו ל Delete, Insert,   EverDeleted  ו- StillDeletedיש זמן ריצהO(1)  בתוחלת (בלי תלות ב N) מותר להשתמש בסיבוכיות מקום O(N).",na,,,,
A,FALSE,2017,B,A,4-a,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"בשאלה זאת נדון במבנה נתונים שתומך בפעולות הבאות על קבוצה S  מתחום סדור. נסמן ב- n את מספר האיברים של S, ויהי  k << n פרמטר (לא קבוע).  
•	Init(S): אתחל את S לקבוצה הריקה בזמן O(1).
•	Insert(x, S): מוסיף איבר x ל-S.
•	Delete(x, S): מוחק את x מ-S. בפעולה זו נניח שנתון לנו מצביע לאיבר x וכן ש-x נמצא ב S לפני הפעולה. 
•	Select_{\leq k} (i, S): הפעולה מחזירה את האיבר ה-i בגודלו (ה-i-th order statistic, שיש i-1  אברים אחרים קטנים או שווים לו) מבין איברי S. 
בפעולה זו תמיד נניח שמתקיים 1<=i<=k.

א.	תאר מבנה נתונים עבורו זמן הריצה של הפעולות Insert  ו Delete  הוא O(log n) במקרה הגרוע, וזמן הריצה של פעולת Select_{\leq k}  הוא O(log k)  במקרה הגרוע (פתרון שתומך בכל הפעולות בזמן  O(log n) יקבל חצי מהנקודות של סעיף זה)",na,,,,
A,FALSE,2017,B,A,4-b,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,na,na,,"ב.	תאר מבנה נתונים עבורו פעולות Insert, Select_{\leq k}   מתבצעות בזמן O(log k) במקרה הגרוע ביותר, ופעולת delete מתבצעת בזמן amortized O(log n).",na,,,,
B,FALSE,2017,B,A,4-c,T3/ds17 BA sol 100(vaad).pdf,TAU,6,na,na,na,na,k,untested,,"ג.	הוכח/הפרך:
בסעיף זה נניח k=7 קבוע. האם ניתן  לתמוך בכל הפעולות Insert ,Delete, Select_{\leq k}  בזמן קבוע במקרה הגרוע ביותר? במידה וניתן – תאר מבנה נתונים מתאים, אחרת הוכח שלא ניתן. ",na,,,,
A,FALSE,2017,B,A,4-d,T3/ds17 BA sol 100(vaad).pdf,TAU,7,na,na,na,na,na,na,,"	תאר מבנה נתונים שעונה לדרישות של סעיף ב', כלומר עדיין צריך לתמוך בפעולות:
	Insert, Select_{\leq k} בזמן O(log k)  במקרה הגרוע.
	Delete בזמן amortized O(log n).
בנוסף מבנה הנתונים צריך לתמוך גם בפעולה:
	DecreaseKey(x ,Δ , S): בהינתן מצביע לאיבר ס שנמצא ב- S , הפעולה מפחיתה Δ מהמפתח של האיבר x. בפעולה זו נניח שנתון לנו מצביע לאיבר x, ש-x נמצא ב-S, וכן Δ>0.

יש לממש את הפעולה DecreaseKey(x , Δ, S) בזמן amortized O(log k).
בניתוח זמן הריצה של DecreaseKey  יש להתייחס למקרה שהמיקום הסופי (הסדר הסטטיסטי של האיבר, כלומר המיקום של האיבר בסדר הממוין לאחר הקטנת המפתח) גדול  מ k, והמקרה שהמיקום הסופי קטן שווה k.


הסבר מדוע זמן הריצה שח DecreaseKey הינו amortized O(log k) (או טוב יותר) עבור המקרה שהמיקום הסופי של x גדול מ-k :

הסבר מדוע זמן הריצה שח DecreaseKey הינו amortized O(log k) (או טוב יותר) עבור המקרה שהמיקום הסופי של x קטן או שווה ל-k :",na,,,,
D,TRUE,2013,B,B,1,T3/ds13BB-sol.pdf,TAU,5,"\textbf{The ""d-ary heap insertion position problem"" is the following problem:} Given a d-ary heap, represented by an array as learned in class. The root is at position 0, and the children of index i are at positions i·d+1, … , i·d+d. Additionally, a key is given that is not in the heap. We need to find the index where the key would be inserted at the end of the insertion process (the heap should not be modified). The insertion process is identical to the insertion process in a binary heap, except the parent of node i is located at the floor of (i-1)/d. It can be assumed that log and exponentiation operations take constant time.

What is the best running time to solve it?
A. \(O(1)\) 
B. \(O(d \log \log n)\) 
C. \(O(\log \log n - \log \log d)\) 
D. \(O(n \log \log d)\) 
E. \(O(\log \log n)\) 
F. \(O(\log n / \log d)\)",C,na,6,h,tested,,"בעיית ""מציאת מקום הכנסה d ""היא הבעיה הבאה: נתונה ערימה d-ארית, המיוצגת 
באמצעות מערך, כפי שנלמד בכיתה. השורש במקום 0, והילדים של אינדקס i במקומות 
i·d+1, … , i·d+d. כמו כן, נתון מפתח, שלא נמצא בערימה. צריך למצוא את האינדקס 
שהמפתח היה נכנס אליו בסוף תהליך ההכנסה )אין לשנות את הערימה). תהליך ההכנסה 
זהה לתהליך ההכנסה בערימה בינארית, רק שההורה של צומת i נמצא בערך תחתון של 
(i-1)/d. ניתן להניח שפעולות log והעלאה בחזקה לוקחות זמן קבוע

מה זמן הריצה הטוב ביותר לפתרון?
א. (1)O
ב. O(d log log n) 
ג. O(log log n - log log d)
ד. O(n log log d) 
ה. O(log log n)
ו. O(log n / log d) ",na,,,,
C,TRUE,2013,B,B,2,T3/ds13BB-sol.pdf,TAU,5,"The problem of ""finding the degree of a Fibonacci heap insertion tree"" is as follows: Given a Fibonacci heap represented by a list of tree roots, where the degree is given at the root (as we learned in class). Also, a key is given that is not in the heap. You need to find what the degree of the tree to which the key would belong at the end of the insertion process would be (the heap should not be altered).

What is the best running time for the solution?  
A. \(O(1)\)  
B. \(O(\log \log n)\)  
C. \(O(\log n)\)  
D. \(O(\log^2 n)\)  
E. \(O(n)\)  
F. \(O(n \log n)\)  ",A,na,6,i,tested,,"בעיית ""מציאת דרגת עץ ההכנסה פיבונצ'י"" היא הבעיה הבאה: נתונה ערימת פיבונצ'י, 
המיוצגת באמצעות רשימת שורשי העצים, כשבשורש העץ נתונה דרגתו (כפי שנלמד 
בכיתה). כמו כן, נתון מפתח, שלא נמצא בערימה. צריך למצוא מה תהיה דרגת העץ שאליו 
המפתח היה נכנס בסוף תהליך ההכנסה (אין לשנות את הערימה).
מה זמן הריצה הטוב ביותר לפתרון?
א. (1)O
ב. O(log log n) 
ג. O(log n)
ד. O(log^2 n)
ה. O(n)
ו. O(n log n) ",na,,,,
D,TRUE,2013,B,B,3,T3/ds13BB-sol.pdf,TAU,5,"\textbf{A student analyzed the running time of the binary counter data structure, as learned in the practice session.} \\
\text{Recall, the counter holds a binary number (initialized to 0) in an infinite array from index 0 (Least} \\
\text{significant bit, defined as the right side). The increment operation increases the counter value by 1 by} \\
\text{changing the contiguous 1s to the right of the first 0 to 0, and the first adjacent 0 to 1.} \\
\text{The student proposed the following potential function: the number of contiguous ones to the right} \\
\text{of the first 0. For example, if the stored number is 100100111011.. the potential value is 2.} \\
\text{The student used the formula learned in class to calculate amortized time: actual + } \\
\text{amortized = delta potential. What result will be obtained? Let n denote the number of increment operations.} \\
\text{A. Amortized time } O(1) \text{ for the increment operation.} \\
\text{B. Amortized time } O(1) \text{ for the increment operation when the value before the operation is odd, and } O(\log n) \text{ when the value before the operation is even.} \\
\text{C. Amortized time } O(1) \text{ for the increment operation when the value before the operation is even, and } O(\log n) \text{ when the value before the operation is odd.} \\
\text{D. Amortized time } O(\log n) \text{ for the increment operation.} \\
\text{E. Amortized time } O(n) \text{ for the increment operation.} \\
\text{F. The function is not valid for amortized time analysis.}",B,na,6,"b,p",tested,,"סטודנט ניתח את זמן הריצה של מבנה הנתונים מונה בינארי, כפי שנלמד בתרגול. 
להזכירכם, המונה מחזיק מספר בינארי (מאותחל ל0) במערך אינסופי מאינדקס 0 (Least
bit significant, נגדיר צד ימין). הפעולה increment מגדילה ב1 את הערך במונה על-
ידי שינוי ה1 הרצופים מימין ל0 הראשון, וה0 הראשון הצמוד אליהם ל1.
הסטודנט הציע את פונקציית הפוטנציאל הבאה: מספר האחדים הרצופים מימין ל0 הראשון. 
למשל, אם המספר השמור הוא 100100111011.. ערך הפוטנציאל הוא 2. 
הסטודנט נעזר בנוסחה שלמד בכיתה כדי לחשב זמן אמורטייזד: + actual = amortized
delta potential. מה התוצאה שיקבל? נסמן ב-n את מספר פעולות increment.
א. זמן (1)O אמורטייזד לפעולת increment.
ב. זמן (1)O אמורטייזד לפעולת increment כאשר הערך לפני הפעולה אי-זוגי, ו-O(log n) כאשר הערך לפני הפעולה זוגי.
ג. זמן (1)O אמורטייזד לפעולת increment, כאשר הערך לפני הפעולה זוגי, ו- O(log n) כאשר הערך לפני הפעולה אי-זוגי.
ד. זמן O(log n) אמורטייזד לפעולת increment.
ה. זמן O(n) אמורטייזד לפעולת increment.
ו. הפונקציה לא תקינה לניתוח זמן אמורטייזד.",na,,,,מונה בינארי
D,TRUE,2013,B,B,4,T3/ds13BB-sol.pdf,TAU,5,"\textbf{A student analyzed the running time of a binary counter data structure, as learned in the exercise.} 

\textbf{As a reminder, the counter holds a binary number (initialized to 0) in an infinite array from index 0 (least bit significant, defined as the right side). The increment operation increases the value in the counter by 1 by changing the consecutive 1s to the right of the first 0, and the first 0 adjacent to them to 1.}

\textbf{The student proposed the following potential function: [number of ones] minus [number of zeros up to the leftmost one]. For example, if the number stored is 100100111011.., the potential value is 2 (7 minus 5).}

\textbf{The student used the formula learned in class to calculate amortized time: actual + delta potential = amortized. What result will be obtained? Let n denote the number of increment operations.}

\begin{enumerate}
\item Amortized time of \(O(1)\) for an increment operation.
\item Amortized time of \(O(1)\) for an increment operation when the value before the operation is odd, and \(O(\log n)\) when the value before the operation is even.
\item Amortized time of \(O(1)\) for an increment operation when the value before the operation is even, and \(O(\log n)\) when the value before the operation is odd.
\item Amortized time of \(O(\log n)\) for an increment operation.
\item Amortized time of \(O(n)\) for an increment operation.
\item The function is invalid for analyzing amortized time.
\end{enumerate}",F,na,6,"b,p",tested,,"סטודנט ניתח את זמן הריצה של מבנה הנתונים מונה בינארי, כפי שנלמד בתרגול. 
להזכירכם, המונה מחזיק מספר בינארי (מאותחל ל0) במערך אינסופי מאינדקס 0 (Least
bit significant, נגדיר צד ימין). הפעולה increment מגדילה ב1 את הערך במונה על-
ידי שינוי ה1 הרצופים מימין ל0 הראשון, וה0 הראשון הצמוד אליהם ל1.
הסטודנט הציע את פונקציית הפוטנציאל הבאה: [מספר האחדים] פחות [מספר האפסים עד האחד השמאלי ביותר]. למשל, אם המספר השמור הוא 100100111011.. ערך הפוטנציאל הוא 2 (7 פחות 5). 
הסטודנט נעזר בנוסחה שלמד בכיתה כדי לחשב זמן אמורטייזד: + actual = amortized
delta potential. מה התוצאה שיקבל? נסמן ב-n את מספר פעולות increment.

א. זמן (1)O אמורטייזד לפעולת increment.
ב. זמן (1)O אמורטייזד לפעולת increment כאשר הערך לפני הפעולה אי-זוגי, ו- O(log n) כאשר 
הערך לפני הפעולה זוגי.
ג. זמן (1)O אמורטייזד לפעולת increment, כאשר הערך לפני הפעולה זוגי, ו- O(log n) כאשר הערך לפני הפעולה אי-זוגי.
ד. זמן O(log n) אמורטייזד לפעולת increment.
ה. זמן O(n) אמורטייזד לפעולת increment.
ו. הפונקציה לא תקינה לניתוח זמן אמורטייזד.",na,,,,מונה בינארי
D,TRUE,2013,B,B,5,T3/ds13BB-sol.pdf,TAU,5,"\[
\text{Graph } G=(V,E) \text{ contains vertices } v_1, \ldots, v_n \text{ and } m \text{ edges } (m > n), \text{ which are pairs } (v_i,v_j). \text{ Assume that each vertex and edge can be accessed in } O(1). \text{ Let algorithm } A \text{ use the Union-Find data structure. The implementation of each set is by a linked list containing the members of the set (with a pointer to the head of the list). Each element points to the representative of the set. Make-set creates a list with one element, pointing to the representative (in time } O(1)). \text{ Find is in } O(1) \text{ because there is a pointer to the representative. The Union operation links the lists (in time } O(1)) \text{ and updates all members of the smaller set to point to the representative of the larger set in linear time relative to the number of elements in the smaller set (the structure was presented in the tutorial). The size of the set is stored in the representative and updated in Union.}
\]

\noindent
\text{Algorithm A:}
\begin{enumerate}
    \item \text{For each vertex } i = 1 \text{ to } n, \text{ perform Make-set}(v_i).
    \item \text{Iterate over each edge and check if } \text{find}(v_i) = \text{find}(v_j). \text{ If not, perform Union}(v_i, v_j).
\end{enumerate}

\noindent
\text{What is the worst-case running time for the union operation?}

\begin{enumerate}[label=\alph*.]
    \item O(\alpha(n))
    \item O(\alpha(m))
    \item O(\log n)
    \item O(\log m)
    \item O(n)
    \item O(m)
\end{enumerate}",E,na,6,"a,n",tested,,"גרף G=(V,E) מכיל צמתים v1,…,vn וm קשתות (m>n), שהן זוגות (vi,vj). הניחו כי ניתן  לגשת לכל צומת וקשת ב-(1)O. יהי אלגוריתם A המשתמש במבנה נתונים -Union
Find. המימוש של כל קבוצה הוא על-ידי רשימה מקשורת שמכילה את איברי הקבוצה (עם 
מצביע לראש הרשימה). כל איבר מצביע לנציג של הקבוצה. Make-set יוצרת רשימה עם 
איבר אחד, שמצביע לנציג (בזמן O(1)). Find בזמן (1)O כי יש מצביע לנציג. הפעולה 
Union משרשרת את הרשימות (בזמן (1)O) ומעדכנת את כל איברי הקבוצה הקטנה יותר 
להצביע על הנציג של הקבוצה הגדולה יותר בזמן לינארי במספר איברי הקבוצה הקטנה 
(המבנה הוצג בתרגול). גודל הקבוצה שמור בנציג ומעודכן ב-Union.
האלגוריתם A:
1. לכל צומת מ1=i עד n בצע Make-set(vi).
2. עבור על כל קשת ובדוק אם find(vi)=find(vj). אם לא, בצע Union(vi,vj). 
מה זמן הריצה ב-case worst לפעולת union?
א.	O(α(n)) 
ב.	O(α(m)) 
ג.	O(log n) 
ד.	O(log m) 
ה.	O(n) 
ו.	O(m)",na,,,,
C,TRUE,2013,B,B,6,T3/ds13BB-sol.pdf,TAU,5,na,E,na,6,"a,n",untested,,"גרף G=(V,E) מכיל צמתים v1,…,vn וm קשתות (m>n), שהן זוגות (vi,vj). הניחו כי ניתן  לגשת לכל צומת וקשת ב-(1)O. יהי אלגוריתם A המשתמש במבנה נתונים -Union
Find. המימוש של כל קבוצה הוא על-ידי רשימה מקשורת שמכילה את איברי הקבוצה (עם 
מצביע לראש הרשימה). כל איבר מצביע לנציג של הקבוצה. Make-set יוצרת רשימה עם 
איבר אחד, שמצביע לנציג (בזמן O(1)). Find בזמן (1)O כי יש מצביע לנציג. הפעולה 
Union משרשרת את הרשימות (בזמן (1)O) ומעדכנת את כל איברי הקבוצה הקטנה יותר 
להצביע על הנציג של הקבוצה הגדולה יותר בזמן לינארי במספר איברי הקבוצה הקטנה 
(המבנה הוצג בתרגול). גודל הקבוצה שמור בנציג ומעודכן ב-Union.
האלגוריתם A:
1. לכל צומת מ1=i עד n בצע Make-set(vi).
2. עבור על כל קשת ובדוק אם find(vi)=find(vj). אם לא, בצע Union(vi,vj). 
מה זמן הריצה של האלגוריתם A במימוש מבנה הנתונים find-union המתואר בשאלה? בחר בחסם ההדוק ביותר.
א.	O(m+n)
ב.	O(m log n + n) 
ג.	O(m α(n) + n) 
ד.	O(m α(n) + n log n) 
ה.	O(m + n log n) 
ו.	O(m + n α(n)) ",na,,,,
D,TRUE,2013,B,B,7,T3/ds13BB-sol.pdf,TAU,5,na,A,na,6,"a,p",untested,,"נתון עץ אדום-שחור עם מצביע למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר (מובטח שהוא גדול משאר איברי העץ) כילד של המקסימום 
עדכן מצביע למקסימום.
Delete-min– מחק את המינימום ממקומו. עדכן את המצביע למינימום על-ידי חיפוש 
האיבר המינימלי מהשורש.
כמובן, שאחרי כל מחיקה או הכנסה מבצעים תיקונים בעץ אדום-שחור, כפי שנלמד.
מבצעים את סדרת הפעולות הבאה: נתון מערך ממויין בגודל n ועץ אדום-שחור ריק, 
ומבצעים Insert-max על איברי המערך מהקטן לגדול. לאחר מכן, מבצעים Delete-min
עד שהעץ ריק.
מה מספר פעולות רוטציה worst case בפעולה בודדת של Insert-max:
א. (1)O
ב. O(log log n)
ג. O(log n) 
ד. O(n)
ה. O(n log n) 
ו. O(n^2)",na,,,,עץ אדום שחור
C,TRUE,2013,B,B,8,T3/ds13BB-sol.pdf,TAU,5,"Given a red-black tree with a pointer to the maximum and minimum and two additional operations are added:
Insert-max – Insert an element (guaranteed to be larger than all other elements in the tree) as a child of the maximum. Update the pointer to the maximum.
Delete-min– Remove the minimum from its position. Update the pointer to the minimum by searching for the minimum element from the root.
Of course, after each deletion or insertion, corrections are made to the red-black tree, as learned.
Execute the following series of operations: Given a sorted array of size \( n \) and an empty red-black tree, perform Insert-max on the array elements from smallest to largest. Then, perform Delete-min until the tree is empty.
Provide the tightest possible bound on the runtime of the series of operations.
a. \( O(1) \)
b. \( O(\log \log n) \)
c. \( O(\log n) \)
d. \( O(n) \)
e. \( O(n \log n) \)
f. \( O(n^2) \)",E,na,6,"a,p",tested,,"נתון עץ אדום-שחור עם מצביע למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר (מובטח שהוא גדול משאר איברי העץ) כילד של המקסימום 
עדכן מצביע למקסימום.
Delete-min– מחק את המינימום ממקומו. עדכן את המצביע למינימום על-ידי חיפוש 
האיבר המינימלי מהשורש.
כמובן, שאחרי כל מחיקה או הכנסה מבצעים תיקונים בעץ אדום-שחור, כפי שנלמד.
מבצעים את סדרת הפעולות הבאה: נתון מערך ממויין בגודל n ועץ אדום-שחור ריק, 
ומבצעים Insert-max על איברי המערך מהקטן לגדול. לאחר מכן, מבצעים Delete-min
עד שהעץ ריק.
תן חסם הדוק ככל שניתן לזמן הריצה של סדרת הפעולות.
א. (1)O
ב. O(log log n)
ג. O(log n) 
ד. O(n)
ה. O(n log n) 
ו. O(n^2)",na,,,,עץ אדום שחור
D,TRUE,2013,B,B,9,T3/ds13BB-sol.pdf,TAU,5,na,C,na,6,"m,c",untested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
.1 חלק מערך לחמישיות.
.2 מיין כל חמישיה.
.3 מצא חציון חציוני החמישיות על-ידי select( סמן אותו ב-x).
.4 בצע partition על המערך לפי x( סמן m המקום אליו x הגיע(.
.5 אם m=i, החזר x. אחרת, אם i<m המשך רקורסיבית על חלק שמאל )הקטנים מ-x )עם i, אחרת המשך רקורסיבית על חלק ימין )הגדולים מ-x )עם i-m.
סטודנט מימש את האלגוריתם, אך בשלב 3 בטעות מצא את מקסימום החציונים. כלומר,
במקום למצוא את חציון חציוני החמישיות, הוא לקח את המקסימום מבין חציוני החמישיות, 
שאותו מצא על-ידי מעבר לינארי על החציונים. מה נוסחת הנסיגה המתארת את זמן הריצה?
T(n) ≤ T(9n/10) + O(n) .א
T(n) ≤ T(4n/5) + O(n) .ב
T(n) ≤ T(n-3) + O(n) .ג
T(n) ≤ T(9n/10) + T(n/5) + O(n) .ד
T(n) ≤ T(4n/5) + T(n/5) + O(n) .ה
T(n) ≤ T(n-3) + T(n/5) + O(n) .ו",na,,,,
C,TRUE,2013,B,B,10,T3/ds13BB-sol.pdf,TAU,5,"\begin{enumerate}
    \item Reminder for the SELECT(i) algorithm to find the i-th largest element:
    \begin{enumerate}
        \item Divide the array into chunks of five.
        \item Sort each chunk of five.
        \item Find the median of the medians of the five-element groups using select and denote it as x.
        \item Perform a partition on the array based on x, marking m as the position to which x arrived.
        \item If m=i, return x. Otherwise, if i<m, continue recursively on the left side (elements smaller than x) with i; otherwise, continue recursively on the right side (elements larger than x) with i-m.
    \end{enumerate}
    A student implemented the algorithm, but in step 3 mistakenly found the maximum of the medians. That is, instead of finding the median of the medians of the five-element groups, he took the maximum among the medians of the groups, found by passing linearly over the medians. What is the runtime and does the algorithm guarantee a correct result?
    \item[(A)] O(n), and the algorithm is correct.
    \item[(B)] O(n \log n), and the algorithm is correct.
    \item[(C)] O(n^2), and the algorithm is correct.
    \item[(D)] O(n), and the algorithm is incorrect.
    \item[(E)] O(n \log n), and the algorithm is incorrect.
    \item[(F)] O(n^2), and the algorithm is incorrect.
\end{enumerate}",C,na,6,"m,a",tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
.1 חלק מערך לחמישיות.
.2 מיין כל חמישיה.
.3 מצא חציון חציוני החמישיות על-ידי select( סמן אותו ב-x).
.4 בצע partition על המערך לפי x( סמן m המקום אליו x הגיע(.
.5 אם m=i, החזר x. אחרת, אם i<m המשך רקורסיבית על חלק שמאל )הקטנים מ-x )עם i, אחרת המשך רקורסיבית על חלק ימין )הגדולים מ-x )עם i-m.
סטודנט מימש את האלגוריתם, אך בשלב 3 בטעות מצא את מקסימום החציונים. כלומר,
במקום למצוא את חציון חציוני החמישיות, הוא לקח את המקסימום מבין חציוני החמישיות, 
שאותו מצא על-ידי מעבר לינארי על החציונים. מה זמן הריצה והאם האלגוריתם בוודאות יוציא תוצאה נכונה?

א. (n(O, והאלגוריתם נכון.
.נכון והאלגוריתם O(n log n) .ב
ג. O(n^2) והאלגוריתם נכון.
ד. O(n), והאלגוריתם שגוי.
ה. O(n log n) והאלגוריתם שגוי. 
ו. O(n^2) והאלגוריתם שגוי.",na,,,,
D,TRUE,2013,B,B,11,T3/ds13BB-sol.pdf,TAU,5,"\textit{We define a family of functions (mapping $n$ keys to a table of size $m$) as almost universal: \newline
For any two distinct values from the domain of $n$ keys, the probability of randomly selecting a function from the family such that it returns the same value (among $m$ values) for both is bounded by $m^{-1/3}$. \newline
What is the minimum table size $m$ such that if we choose a function randomly from an almost universal family, the expected number of collisions is bounded by $\frac{1}{2}$? \newline
A. $n^{1/3}$ \newline
B. $n^{2/3}$ \newline
C. $n^{4/3}$ \newline
D. $n^2$ \newline
E. $n^3$ \newline
F. $n^6$}",F,na,6,"g,p",tested,,"נגדיר משפחת פונקציות )הממפות n מפתחות לטבלה בגודל m )כמעט אוניברסאלית:
לכל שני ערכים שונים מתחום n המפתחות, ההסתברות שנגריל פונקציה באקראי 
מהמשפחה והיא תחזיר אותו ערך )מבין m ערכים( עבור שניהם חסומה על-ידי m^(-1/3).
מה גודל הטבלה m המינימלי שאם נבחר פונקציה באקראי ממשפחה כמעט 
אוניברסאלית, מס' ההתנגשויות בתוחלת חסום על-ידי 1/2?
א.	n^(1/3)
ב.	n^(2/3)
ג.	n^(4/3)
ד.	n^2
ה.	n^3
ו.	n^6",na,,,,פונקציות אוניברסליות
C,TRUE,2013,B,B,12,T3/ds13BB-sol.pdf,TAU,5,"\[
\text{Define a family of functions (mapping n keys to a table of size m) that is almost universal:}
\]
\[
\text{For any two different values from the domain of n keys, the probability of randomly selecting a function }
\]
\[
\text{from the family that returns the same value (out of m values) for both is bounded by } m^{-1/3}.
\]
\[
\text{Let } X \text{ denote the minimum table size such that if we randomly select a function from an almost universal family,}
\]
\[
\text{the expected number of collisions is bounded by 1/2.}
\]
\[
\text{A student constructed a table of size } 8X. \text{ After how many expected trials will you find a function with no collisions?}
\]
\[
\text{Choose the tightest upper bound.}
\]
\[
\text{A. 1}
\]
\[
\text{B. \frac{8}{7}}
\]
\[
\text{C. \frac{4}{3}}
\]
\[
\text{D. 2}
\]
\[
\text{E. 4}
\]
\[
\text{F. 8}
\]",C,na,6,"g,p",tested,,"נגדיר משפחת פונקציות )הממפות n מפתחות לטבלה בגודל m )כמעט אוניברסאלית:
לכל שני ערכים שונים מתחום n המפתחות, ההסתברות שנגריל פונקציה באקראי 
מהמשפחה והיא תחזיר אותו ערך )מבין m ערכים( עבור שניהם חסומה על-ידי m^(-1/3).
נסמן ב-X את גודל הטבלה המינימלי שאם נבחר פונקציה באקראי ממשפחה כמעט 
אוניברסאלית, מס' ההתנגשויות בתוחלת חסום על-ידי 1/2. 
סטודנט בנה טבלה בגודל 8X. תוך כמה הגרלות בתוחלת תמצא פונקציה שאין עבורה 
התנגשויות? בחר את החסם העליון ההדוק ביותר.
א. 1
ב. 8/7
ג. 4/3
ד. 2
ה. 4
ו. 8",na,,,,פונקציות אוניברסליות
D,TRUE,2013,B,B,13,T3/ds13BB-sol.pdf,TAU,5,"\begin{quote}
Define a structure of a dictionary containing $n$ words. The dictionary is divided into $n/k$ pages, with each page containing $k$ words (assume $n/k$ is an integer). The words are sorted such that every word on page $i$ is lexicographically before all the words on page $i+1$, but within each page, the words are not sorted. The pages are placed in an array, providing direct access to them, and each page is also an array of words, allowing direct access to them as well. Assume all words are distinct from each other and a comparison between two words takes $O(1)$ time. We want to implement a search operation for a word in the entire dictionary. What size of $k$ will allow the best asymptotic runtime?

\begin{enumerate}
    \item $k = \log n$
    \item $k = \frac{n}{\log n}$
    \item $k = 1$
    \item $k = \sqrt{n}$
    \item Answers \textbf{a} and \textbf{c} are equivalent and will provide the best asymptotic runtime.
    \item The size of $k$ is irrelevant, search time for a word will be the same for any value of $k$.
\end{enumerate}
\end{quote}",E,na,6,"a,d,p",tested,,"נגדיר מבנה של מילון המכיל n מילים. המילון מחולק ל-n/k עמודים כאשר בכל עמוד
יש k מילים )הניחו n/k מספר שלם(. המילים ממוינות כך שכל מילה בעמוד i נמצאת 
לקסיקוגרפית לפני כל המילים בעמוד i+1, אבל בתוך כל עמוד המילים לא ממוינות.
העמודים יושבים במערך, כך שיש גישה ישירה אליהם. וכל עמוד הוא מערך של מילים, 
וגם אליהם גישה ישירה. הניחו שכל המילים שונות זו מזו והשוואה בין שתי מילים 
לוקחת (1)O.
אנו רוצים לממש פעולת חיפוש של מילה בכל המילון. איזה גודל של k יאפשר את זמן
הריצה הטוב ביותר מבחינה אסימפטוטית?
k = log n .א
k = n / log n .ב
ג. 1 = k
k = sqrt(n( .ד
ה. תשובות א' ו ג' שקולות ויתנו את זמן הריצה האסימפטוטי הטוב ביותר.
ו. אין חשיבות לגודלו של k, זמן הריצה עבור חיפוש מילה יהיה זהה עבור כל ערך של k",na,,,,"מיון מערך, לוודא לאיזה חומר קשור"
C,TRUE,2013,B,B,14,T3/ds13BB-sol.pdf,TAU,5,"\begin{quote}
We define the structure of a dictionary containing \(n\) words. The dictionary is divided into \(n/k\) pages, with \(k\) words on each page (assume \(n/k\) is an integer). The words are sorted such that every word on page \(i\) is lexicographically before all the words on page \(i+1\), but within each page, the words are not sorted. The pages are stored in an array, so there is direct access to them, and each page is an array of words, which are also directly accessible. Assume all the words are distinct from each other and comparing two words takes \(O(1)\). We want to implement a search operation for a word in the entire dictionary. What value of \(k\) will allow for the best asymptotic running time, assuming additionally that the words within each page are lexicographically sorted?
\begin{enumerate}
    \item \(k = \log n\)
    \item \(k = \frac{n}{\log n}\)
    \item \(k = 1\)
    \item \(k = \sqrt{n}\)
    \item Options a and c are equivalent and will yield the best asymptotic running time.
    \item The size of \(k\) is not important; the running time for a word search will be the same for every value of \(k\).
\end{enumerate}
\end{quote}",F,na,6,"a,d,p",tested,,"נגדיר מבנה של מילון המכיל n מילים. המילון מחולק ל-n/k עמודים כאשר בכל עמוד
יש k מילים )הניחו n/k מספר שלם(. המילים ממוינות כך שכל מילה בעמוד i נמצאת 
לקסיקוגרפית לפני כל המילים בעמוד i+1, אבל בתוך כל עמוד המילים לא ממוינות.
העמודים יושבים במערך, כך שיש גישה ישירה אליהם. וכל עמוד הוא מערך של מילים, 
וגם אליהם גישה ישירה. הניחו שכל המילים שונות זו מזו והשוואה בין שתי מילים 
לוקחת (1)O.
אנו רוצים לממש פעולת חיפוש של מילה בכל המילון. איזה גודל של k יאפשר את זמן
הריצה הטוב ביותר מבחינה אסימפטוטית, אם נניח בנוסף שהמילים בתוך כל עמוד יהיו ממוינות לקסיקוגרפית?
k = log n .א
k = n / log n .ב
ג. 1 = k
k = sqrt(n( .ד
ה. תשובות א' ו ג' שקולות ויתנו את זמן הריצה האסימפטוטי הטוב ביותר.
ו. אין חשיבות לגודלו של k, זמן הריצה עבור חיפוש מילה יהיה זהה עבור כל ערך של k",na,,,,"מיון מערך, לוודא לאיזה חומר קשור"
C,TRUE,2013,B,B,15,T3/ds13BB-sol.pdf,TAU,3,na,FALSE,na,2,"a,d,k",untested,,"נגדיר מערך ""כמעט ממוין"" באופן הבא: כל איבר במערך נמצא במרחק של עד log n
מקומות ממיקומו במערך ממוין. ניתן להניח שהאיברים שונים זה מזה.
נעסוק בזמן הריצה של מיון המערך.
סמן נכון / לא נכון: ניתן למיין את המערך בזמן ליניארי O(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,16,T3/ds13BB-sol.pdf,TAU,3,"\textbf{Define an ""almost sorted"" array as follows: every element in the array is at a distance of up to $\log n$ positions from its location in a sorted array. It can be assumed that the elements are distinct from each other. We will discuss the runtime of sorting the array. Mark True/False: The array can be sorted in time $O(n \log \log n)$. Add a brief explanation.}",1,na,2,"a,d,k",tested,,"נגדיר מערך ""כמעט ממוין"" באופן הבא: כל איבר במערך נמצא במרחק של עד log n
מקומות ממיקומו במערך ממוין. ניתן להניח שהאיברים שונים זה מזה.
נעסוק בזמן הריצה של מיון המערך.
סמן נכון / לא נכון: ניתן למיין את המערך בזמן O(n log log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,17,T3/ds13BB-sol.pdf,TAU,3,"\begin{quote}
Define an ""almost sorted"" array as follows: each element in the array is at a distance of up to $\log n$ places from its position in a sorted array. You can assume that the elements are distinct from each other. We will deal with the running time of sorting the array.

Mark correct / incorrect: The array can be sorted in time $O(n \log n)$.
Add a brief explanation.
\end{quote}",1,na,2,"a,d,k",tested,,"נגדיר מערך ""כמעט ממוין"" באופן הבא: כל איבר במערך נמצא במרחק של עד log n
מקומות ממיקומו במערך ממוין. ניתן להניח שהאיברים שונים זה מזה.
נעסוק בזמן הריצה של מיון המערך.
סמן נכון / לא נכון: ניתן למיין את המערך בזמן O(n log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,18,T3/ds13BB-sol.pdf,TAU,3,na,1,na,2,"a,d,k",untested,,"נגדיר מערך ""כמעט ממוין"" באופן הבא: כל איבר במערך נמצא במרחק של עד log n
מקומות ממיקומו במערך ממוין. ניתן להניח שהאיברים שונים זה מזה.
נעסוק בזמן הריצה של מיון המערך.
סמן נכון / לא נכון: על-פי מודל ההשוואות, החסם התחתון למיון המערך הוא Ω(n log log n).

הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,19,T3/ds13BB-sol.pdf,TAU,3,"\textbf{Define an ""almost sorted"" array as follows: each element in the array is within a distance of at most $\log n$ places from its position in a sorted array. It can be assumed that the elements are distinct. We will discuss the runtime of sorting the array. Mark true / false: It is possible to reduce to the problem of sorting a general array and therefore the lower bound for sorting the array is $\Omega(n \log n)$. Add a short justification.}",FALSE,na,2,"a,d,k",tested,,"נגדיר מערך ""כמעט ממוין"" באופן הבא: כל איבר במערך נמצא במרחק של עד log n
מקומות ממיקומו במערך ממוין. ניתן להניח שהאיברים שונים זה מזה.
נעסוק בזמן הריצה של מיון המערך.
סמן נכון / לא נכון: אפשר לבצע רדוקציה לבעיית מיון מערך כללי ולכן החסם התחתון למיון המערך הוא Ω(n log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,20,T3/ds13BB-sol.pdf,TAU,3,"\text{Write whether the following statement is true/false (assuming that the elements are distinct from each other):}\\
\text{Given 2 min-heaps of n elements each (each represented in an array), they can be combined into one min-heap of 2n elements in } O(n).\\
\text{Add a short explanation.}",1,na,2,"a,h",tested,,"כתבו האם הטענה הבאה נכונה / לא נכונה (ניתן להניח שהאיברים שונים זה מזה):
בהינתן 2 ערימות מינימום של n איברים כל אחת )מיוצגות כל אחת במערך( ניתן לחבר
אותן לערימת מינימום אחת של 2n איברים ב O(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,21,T3/ds13BB-sol.pdf,TAU,3,"\begin{quote}
State whether the following claim is true or false (it can be assumed that the elements are distinct from each other):
Given 2 binomial heaps, each with $n$ elements, they can be merged into a single binomial heap with $2n$ elements in $O(n)$.
Add a brief justification.
\end{quote}",1,na,2,"a,i",tested,,"כתבו האם הטענה הבאה נכונה / לא נכונה (ניתן להניח שהאיברים שונים זה מזה):
בהינתן 2 ערימות בינומיות של n איברים כל אחת ניתן לחבר אותן לערימה בינומית אחת
של 2n איברים ב O(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,22,T3/ds13BB-sol.pdf,TAU,3,"\textbf{Write whether the following statement is true / false (it can be assumed that the elements are distinct from each other):} Given 2 binomial heaps of $n$ elements each, they can be combined into one binomial heap of $2n$ elements in $O(\log n)$. \textbf{Add a brief justification.}",1,na,2,"a,i",tested,,"כתבו האם הטענה הבאה נכונה / לא נכונה (ניתן להניח שהאיברים שונים זה מזה):
בהינתן 2 ערימות בינומיות של n איברים כל אחת ניתן לחבר אותן לערימה בינומית אחת
של 2n איברים ב O(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2013,B,B,23,T3/ds13BB-sol.pdf,TAU,3,na,1,na,2,"a,p",untested,,"כתבו האם הטענה הבאה נכונה / לא נכונה (ניתן להניח שהאיברים שונים זה מזה):
בהינתן 2 עצים אדומים-שחורים של n איברים כל אחד ניתן לחבר אותם לעץ אדום שחור
של 2n איברים ב O(n).
הוסף נימוק קצר. ",na,,,,עץ אדום שחור
C,TRUE,2013,B,B,24,T3/ds13BB-sol.pdf,TAU,3,"\textbf{Write whether the following claim is true/false (it can be assumed that the elements are distinct from each other):} Given 2 red-black trees each with \( n \) elements, it is possible to join them into a red-black tree with \( 2n \) elements in \( O(\log n) \). \textbf{Add a brief argument.}",FALSE,na,2,"a,p",tested,,"כתבו האם הטענה הבאה נכונה / לא נכונה (ניתן להניח שהאיברים שונים זה מזה):
בהינתן 2 עצים אדומים-שחורים של n איברים כל אחד ניתן לחבר אותם לעץ אדום שחור
של 2n איברים ב O(log n).
הוסף נימוק קצר. ",na,,,,עץ אדום שחור
A,TRUE,2015,B,A,1-a,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון מערך עם n מספרים.
תאר/י אלגוריתם בסיבוכיות O(n) שבודק האם יש איבר שמופיע לפחות n/8 פעמים במערך. הוכח/י את תשובתך.","נבצע select על האיברים במקום n/9,  2n/9,  3n/9,  4n/9,  5n/9,  6n/9,  7n/9,  8n/9. כעת נעבור על המערך ונבדוק אם אחד מ – 8 המועמדים מופיע לפחות n/8 פעמים.",,,,
A,TRUE,2015,B,A,1-b,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון מערך עם n מספרים.
ב.	תאר/י אלגוריתם דטרמניסטי בסיבוכיות O(nlogn) שמחזיר את מספר האיברים השונים במערך. הוכח/י את תשובתך.","נמיין את המערך ע""י merge sort. כעת נעבור על המערך הממויין ובכל פעם שניתקל באיבר ששונה מהאיבר שלפניו נגדיל מונה ב – 1.",,,,
A,TRUE,2015,B,A,1-c,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון מערך עם n מספרים.

ג.	תאר/י אלגוריתם בסיבוכיות O(n) בתוחלת שמחזיר את מספר האיברים השונים במערך. הוכח/י את תשובתך.",נכניס את האיברים ל – hash table. בכל פעם שהאיבר שונה מהאיברים האחרים שהוכנסו (נכנס לתא ריק או נכנס לתא שכל האיברים ברשימה המקושרת שבו שונים ממנו) נגדיל מונה ב – 1.,,,,
A,TRUE,2015,B,A,2-a,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון אוסף של קבוצות s_1,s_2,…,s_m.
תאר/י מבנה נתונים התומך בפעולות הבאות:
MakeItem(i)  A – צור את האיבר A שמחזיק את המספר i
Insert(j,A) – הכנס את האיבר A לקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
Delete(j,A) – מחק את האיבר A מקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
FindMin(j) – החזר את האיבר המינימלי בקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
CreateSet(j,Arr) – בנה את הקבוצה j מתוך מערך לא ממויין של מספרים.
FindMin() – החזר את האיבר המינימלי מבין כל האיברים בקבוצות s_1,s_2,…,s_m.
על כל הפעולות מלבד CreateSet לרוץ בסיבוכיות O(logn) כאשר n הוא מספר האיברים הכולל בקבוצות s_1,s_2,…,s_m. על CreateSet לרוץ בסיבוכיות ליניארית בגודל מערך הקלט.","נחזיק ערימת מינימום לכל קבוצה ובנוסף ערימת מינימום שבה יוחזקו ערך המינימום של כל אחת מהקבוצות Delete(j,A) ,CreateSet(j,arr) , Insert(j,A)  יעדכנו את ערימת המינימום של קבוצה s_j ואם איבר המינימום שלו התעדכן גם את ערימת המינימום של כל הקבוצות. FindMin(j) יחזיר את איבר המינימום מהערימה המתאימה לקבוצה s_j. FindMin() יחזיר את איבר המינימום מהערימה של כל הקבוצות.",,,,
A,TRUE,2015,B,A,2-b,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון אוסף של קבוצות s_1,s_2,…,s_m.
	תאר/י מבנה נתונים התומך בפעולות הבאות:
MakeItem(i)  A – צור את האיבר A שמחזיק את המספר i
Insert(j,A) – הכנס את האיבר A לקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
Delete(j,A) – מחק את האיבר A מקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
FindMin(j) – החזר את האיבר המינימלי בקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
CreateSet(j,Arr) – בנה את הקבוצה j מתוך מערך לא ממויין של מספרים.
FindMin() – החזר את האיבר המינימלי מבין כל האיברים בקבוצות s_1,s_2,…,s_m.
FindMax(j) – החזר את האיבר המקסימלי בקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
FindMax() – החזר את האיבר המקסימלי מבין כל האיברים בקבוצות s_1,s_2,…,s_m.
על כל הפעולות מלבד CreateSet לרוץ בסיבוכיות O(logn) כאשר n הוא מספר האיברים הכולל בקבוצות s_1,s_2,…,s_m. על CreateSet לרוץ בסיבוכיות ליניארית בגודל מערך הקלט.","כמו בסעיף הקודם, אבל הערימות יהיו ערימת מקסימום-מינימום. כלומר האיברים יוחזקו הן בערימת מינימום והן בערימת מקסימום עם פוינטרים ביניהם.",,,,
A,TRUE,2015,B,A,2-c,T3/ds15ba-sol(vaad).docx,TAU,8,na,na,na,na,na,na,,"נתון אוסף של קבוצות s_1,s_2,…,s_m.

תאר/י מבנה נתונים התומך בפעולות הבאות:
MakeItem(i)  A – צור איבר A עם מפתח i
Insert(j,A) – הכנס את האיבר A לקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
Delete(j,A) – מחק את האיבר A מקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
Search(j,i) – מצא את האיבר עם מפתח i בקבוצה S_j (ניתן להניח שהקבוצה S_j קיימת).
FindMin() – החזר את האיבר המינימלי מבין כל האיברים בקבוצות s_1,s_2,…,s_m.
על כל הפעולות לרוץ בסיבוכיות O(logn) כאשר n הוא מספר האיברים הכולל בקבוצות s_1,s_2,…,s_m.",נחזיק עץ אדום שחור לכל קבוצה עם פוינטר לאיבר המינימום שלו ובנוסף ערימת מינימום שבה יוחזקו ערך המינימום של כל אחת מהקבוצות.,,,,
C,TRUE,2015,B,A,3,T3/ds15ba-sol(vaad).docx,TAU,5,"In the course, there are \(N\) students. The grades awarded in the course are any real numbers, and no two grades are identical. The instructors proposed four optional data structures for submission to the secretariat: 
1) A regular binary search tree with a size field. 
2) A red-black tree with a size field. 
3) A Fibonacci heap. 
4) A binary heap.

The secretariat must perform \(\sqrt{N}\) order statistics searches (such as finding the median score, the 100th largest score, etc.). The structures cannot be changed, and the auxiliary memory available for use is \(O(1)\).

We are interested in a structure that will minimize the asymptotic complexity of the secretariat's tasks (but not including the complexity of building the data structure by the instructors):

a. A Fibonacci heap and a red-black tree with a size field will deliver the best performance and will allow execution in \(\Theta(\log N)\).
b. The best performance that can be achieved on a regular binary search tree with a size field will cost \(\Theta(N \log N)\).
c. A binary heap will allow the task to be performed in \(\Theta(N \log \log N)\).
d. A red-black tree with a size field will deliver the best performance and will allow execution in \(\mathcal{O}(\sqrt{N} \log N)\).
e. A binary search tree with a size field and a red-black tree with a size field will deliver the best performance and will allow execution in \(\Theta(N)\).
f. None of the answers are correct.",D,na,6,"a,e,i,p",tested,,"בקורס  ישנם N  סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם  ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונאלים להגשה למזכירות:
1) עץ חיפוש בינארי רגיל עם שדה size. 2) עץ אדום שחור עם שדה  size. 3) ערימת פיבונאצי. 4) ערימה בינארית. 

על המזכירות לבצע \(\sqrt{N}\) חיפושי order statistics   (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו').  לא ניתן לשנות המבנים וזכרון העזר שניתן להשתמש בו הינו O(1). 

הננו מעוניינם במבנה שיקטין את הסיבוכיות אסימפטוטית של בצוע העבודה על ידי המזכירות (אבל לא כולל את סיבוכיות בנית מבנה הנתונים על ידי המרצים):  

א.	ערימת פיבונאצי ועץ  אדום שחור עם שדה size ייתנו את הביצועים הטובים ביותר ויאפשרו בצוע ב  \(\Theta(\log N)\).
ב.	הבצוע הטוב ביותר שניתן לבצע על עץ חיפוש בינארי רגיל  עם שדה size  יעלה \(\Theta(N \log N)\).
ג.	ערימה בינארית תאפשר לבצע את העבודה ב \(\Theta(N \log \log N)\).
ד.	עץ  אדום שחור עם שדה  size ייתן את הביצועים הטובים ביותר ויאפשר בצוע \(\O(\sqrt{N} \log N)\). 
ה.	עץ חיפוש בינארי עם שדה size  ועץ  אדום שחור עם שדה size  ייתנו את הביצועים הטובים ביותר ויאפשרו בצוע ב \(\Theta(N)\)
ו.	אף תשובה לא נכונה.",na,,,,עץ אדום שחור
C,TRUE,2015,B,A,4,T3/ds15ba-sol(vaad).docx,TAU,3,"In a course, there are \(N\) students. The grades awarded in the course are any real numbers, and no two grades are identical to each other. The lecturers proposed 4 optional data structures for submission to the secretariat:
1) A regular binary search tree with a size field. 2) A red-black tree with a size field. 3) A Fibonacci heap. 4) A binary heap.

The secretariat needs to perform \(\sqrt{N}\) order statistics searches (like finding the median score, the 100th largest score, etc.). The structures cannot be changed, and the auxiliary memory that can be used is \(O(1)\).

We are interested in a structure that minimizes the asymptotic complexity of performing the task by the secretariat (but not including the complexity of constructing the data structure by the lecturers).

Answer true/false:
In the above problem, in the worst case, the performance of a binary search tree with a size field will be asymptotically the same as those of a binary search tree without a size field.
A. True
B. False",A,na,2,"a,e",tested,,"בקורס  ישנם N  סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם  ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונאלים להגשה למזכירות:
1) עץ חיפוש בינארי רגיל עם שדה size. 2) עץ אדום שחור עם שדה  size. 3) ערימת פיבונאצי. 4) ערימה בינארית. 

על המזכירות לבצע \(\sqrt{N}\) חיפושי order statistics   (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו').  לא ניתן לשנות המבנים וזכרון העזר שניתן להשתמש בו הינו O(1). 

הננו מעוניינם במבנה שיקטין את הסיבוכיות אסימפטוטית של בצוע העבודה על ידי המזכירות (אבל לא כולל את סיבוכיות בנית מבנה הנתונים על ידי המרצים).

ענו נכון\לא נכון : 
בבעיה שלעיל, במקרה הגרוע ביותר ביצועי עץ חיפוש בינארי עם שדה size  יהיו זהים אסימפטוטית לאלו של עץ חיפוש בינארי בלי שדה size. 
א.	נכון
ב.	לא נכון",na,,,,
C,TRUE,2015,B,A,5,T3/ds15ba-sol(vaad).docx,TAU,4,na,A,na,6,"a,e,i,p",untested,,"בקורס  ישנם N  סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם  ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונאלים להגשה למזכירות:
1) עץ חיפוש בינארי רגיל עם שדה size. 2) עץ אדום שחור עם שדה  size. 3) ערימת פיבונאצי. 4) ערימה בינארית. 

על המזכירות לבצע \(\sqrt{N}\) חיפושי order statistics   (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו').  לא ניתן לשנות המבנים וזכרון העזר שניתן להשתמש בו הינו O(1). 

הננו מעוניינם במבנה שיקטין את הסיבוכיות אסימפטוטית של בצוע העבודה על ידי המזכירות (אבל לא כולל את סיבוכיות בנית מבנה הנתונים על ידי המרצים).

מעוניינים כעת לבצע סדרה של Θ(N) בקשות order statistics. כדי להקל במשימה הנהלת האוניברסיטה מוכנה לספק למזכירות את סדרת הבקשות  לחיפושי order statistics בצורה ממויינת. לדוגמה ההנהלה תגיש למזכירות את הרשימה
 (1,3, 5, 7,…,N)    או את הרשימה (1, 2, 3, …, N/4). הזמן הטוב ביותר שניתן לבצע בעזרת המבנה הטוב ביותר בין 4 המבנים הינו: 
	Θ(N)
	Θ(N log⁡N )
	Θ(N √N)
	O(√N  log⁡〖N)〗
	Θ(N 〖 log log〗⁡N )
	אף תשובה לא נכונה. ",na,,,,עץ אדום שחור
C,TRUE,2015,B,A,6,T3/ds15ba-sol(vaad).docx,TAU,6,"In the course, there are \(N\) students. The grades awarded in the course are any real numbers, and no two grades are identical to each other. The lecturers proposed 4 optional data structures for submission to the secretariat: 1) A regular binary search tree with a size field. 2) A red-black tree with a size field. 3) A Fibonacci heap. 4) A binary heap.

The secretariat needs to perform \(\sqrt{N}\) order statistics searches (such as finding the median grade, the 100th largest grade, etc.). The structures cannot be modified, and the auxiliary memory available for use is \(O(1)\).

We are interested in a structure that will reduce the asymptotic complexity of performing the task by the secretariat (but not including the complexity of building the data structure by the lecturers).

Now we want to perform a series of \(\Theta(N)\) order statistics requests. To ease the task, the university administration is willing to provide the secretariat with the series of requests for order statistics searches in sorted order. For example, the administration will submit to the secretariat the list (1, 3, 5, 7, \ldots, N) or the list (1, 2, 3, \ldots, N/4). Among the four structures, the one through which the best time can be achieved is:
a. Fibonacci heap.
b. Red-black tree with a size field.
c. Binary search tree with a size field.
d. b+c
e. a+c
f. a+b+c.",D,na,6,"a,e,i,p",tested,,"בקורס  ישנם N  סטודנטים. הציונים המוענקים בקורס הינם מספרים ממשיים כלשהם  ואין שני ציונים זהים זה לזה. המרצים הציעו 4 מבני נתונים אופציונאלים להגשה למזכירות:
1) עץ חיפוש בינארי רגיל עם שדה size. 2) עץ אדום שחור עם שדה  size. 3) ערימת פיבונאצי. 4) ערימה בינארית. 

על המזכירות לבצע \(\sqrt{N}\) חיפושי order statistics   (כמו מצא את ציון החציון, הציון ה-100 בגודלו וכו').  לא ניתן לשנות המבנים וזכרון העזר שניתן להשתמש בו הינו O(1). 

הננו מעוניינם במבנה שיקטין את הסיבוכיות אסימפטוטית של בצוע העבודה על ידי המזכירות (אבל לא כולל את סיבוכיות בנית מבנה הנתונים על ידי המרצים).

מעוניינים כעת לבצע סדרה של Θ(N) בקשות order statistics. כדי להקל במשימה הנהלת האוניברסיטה מוכנה לספק למזכירות את סדרת הבקשות  לחיפושי order statistics בצורה ממויינת. לדוגמה ההנהלה תגיש למזכירות את הרשימה
 (1,3, 5, 7,…,N)    או את הרשימה (1, 2, 3, …, N/4). מבין ארבעת המבנים המבנה שבעזרתו ניתן להשיג את הזמן הטוב ביותר הינו: 
א. ערימת פיבונצי.
ב. עץ אדום שחור עם שדה size.
ג. עץ חיפוש בינארי עם שדה size. 
ד. ב+ג
ה. א+ג
ו. א+ב+ג.",na,,,,עץ אדום שחור
C,TRUE,2015,B,A,7,T3/ds15ba-sol(vaad).docx,TAU,5,"\textbf{Reminder for the SELECT(i) algorithm for finding the i-th largest element:}
1. Divide the array into groups of five.
2. Sort each group of five.
3. Find the median of the medians of the groups using select (let's call it x).
4. Perform a partition on the array based on x (let m be the position to which x moves).
5. If i=m, return X. Otherwise, if i<m, continue recursively on the left part with i, else continue recursively on the right part with i-m.
\[ \text{A student implemented the algorithm, but in step 3 accidentally found the } 2/5 \text{ element. That is, instead of finding the median of the medians of the quintets, he took the } 2/5 \text{ element among the medians of the quintets, which he found using select. What is the recurrence formula that describes the running time?}

\text{a.} \ T(n) \leq T(9n/10) + O(n) \\
\text{b.} \ T(n) \leq T(3n/5) + T(3n/5) + O(n) \\
\text{c.} \ T(n) \leq T(7n/10) + O(n) \\
\text{d.} \ T(n) \leq T(19n/25) + T(n/5) + O(n) \\
\text{e.} \ T(n) \leq T(3n/5) + T(n/5) + O(n) \\
\text{f.} \ T(n) \leq T(9/25n) + T(n/5) + O(n) \\
\text{g.} \ \text{None of the answers is correct} \]",D,na,7,"a,m",tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
1.	חלק מערך לחמישיות.
2.	מיין כל חמישיה.
3.	מצא חציון חציוני החמישיות על-ידי select (סמן אותו ב-x).
4.	בצע partition על המערך לפי x (סמן m המקום אליו x הגיע).
5.	אם i=m, החזר X. אחרת, אם i<m המשך רקורסיבית על חלק שמאל עם i, אחרת המשך רקורסיבית על חלק ימין עם i-m.
סטודנט מימש את האלגוריתם, אך בשלב 3 בטעות מצא את האיבר ה 2/5. כלומר במקום למצוא את חציון חציוני החמישיות, הוא לקח את האיבר ה2/5 מבין חציוני החמישיות, שאותו מצא על-ידי select. מה נוסחת הנסיגה המתארת את זמן הריצה?

א.	T(n) ≤ T(9n/10) + O(n)
ב.	T(n) ≤ T(3n/5) + T(3n/5) + O(n)
ג.	T(n) ≤ T(7n/10) + O(n)
ד.	T(n) ≤ T(19n/25) + T(n/5) + O(n)
ה.	T(n) ≤ T(3n/5) + T(n/5) + O(n)
ו.	T(n) ≤ T(9/25n) + T(n/5) + O(n)
ז.	אף תשובה לא נכונה",na,,,,
C,TRUE,2015,B,A,8,T3/ds15ba-sol(vaad).docx,TAU,5,"\textbf{Reminder for the SELECT(i) algorithm for finding the i-th largest element:}
1. Divide the array into groups of five.
2. Sort each group of five.
3. Find the median of the medians of the groups using select (let's call it x).
4. Perform a partition on the array based on x (let m be the position to which x moves).
5. If i=m, return X. Otherwise, if i<m, continue recursively on the left part with i, else continue recursively on the right part with i-m.
A student implemented the algorithm, but in step 3, he mistakenly found the 2/5-th element. In other words, instead of finding the median of the medians of the groups, he selected the 2/5-th element among the medians, which he found using select. What is the recurrence formula describing the running time?

What is the running time and does the algorithm definitely produce the correct result?
A. O(n), and the algorithm is correct.
B. O(n \log n), and the algorithm is correct.
C. O(n^2), and the algorithm is correct.
D. O(n), and the algorithm is incorrect.
E. O(n \log n), and the algorithm is incorrect.
F. O(n^2), and the algorithm is incorrect.
G. The running time is infinite and the algorithm is incorrect.",A,na,7,"a,m",tested,,"תזכורת לאלגוריתם SELECT(i) למציאת האיבר ה-i בגודלו:
1.	חלק מערך לחמישיות.
2.	מיין כל חמישיה.
3.	מצא חציון חציוני החמישיות על-ידי select (סמן אותו ב-x).
4.	בצע partition על המערך לפי x (סמן m המקום אליו x הגיע).
5.	אם i=m, החזר X. אחרת, אם i<m המשך רקורסיבית על חלק שמאל עם i, אחרת המשך רקורסיבית על חלק ימין עם i-m.
סטודנט מימש את האלגוריתם, אך בשלב 3 בטעות מצא את האיבר ה 2/5. כלומר במקום למצוא את חציון חציוני החמישיות, הוא לקח את האיבר ה2/5 מבין חציוני החמישיות, שאותו מצא על-ידי select. מה נוסחת הנסיגה המתארת את זמן הריצה?

מה זמן הריצה והאם האלגוריתם בוודאות יוציא תוצאה נכונה?
א. O(n), והאלגוריתם נכון.
ב. O(n log n) והאלגוריתם נכון.
ג. O(n2) והאלגוריתם נכון.
ד. O(n), והאלגוריתם שגוי.
ה. O(n log n) והאלגוריתם שגוי.
ו. O(n2) והאלגוריתם שגוי.
ז. זמן הריצה אינסופי והאלגוריתם שגוי.",na,,,,
C,TRUE,2015,B,A,9,T3/ds15ba-sol(vaad).docx,TAU,5,"\textbf{A counter is a data structure that holds a non-negative integer and supports the Increment operation. A call to the Increment operation increases the value of the counter by 1. The counter is implemented using an array initialized to zeros, holding the counter's value in binary representation. The Increment implementation is performed by iterating over the array from the least significant bit (LSB) in ascending order: for each bit encountered with a value of 1, it is changed to 0. The first bit with a value of 0 encountered is changed to 1, and then the process stops. It is assumed that the size of the array is sufficient to hold the counter's value.}

\textbf{Assume that the current counter value is $b$, and $m$ Increment calls are made from this state (where $b$ is not necessarily fixed!). What is the total runtime of these $m$ calls?}

\begin{itemize}
    \item (a) The runtime is $O(m)$.
    \item (b) The runtime is $O(b)$.
    \item (c) Given that $n = \Omega(b)$, the runtime is $O(m)$.
    \item (d) Given that $m = \Omega(b)$, the runtime is $O(m)$. If $m = o(b)$, any sequence of $m$ calls will run in time $\Theta(b)$.
    \item (e) None of the answers are correct.
\end{itemize}",C,na,5,"a,d,p",tested,,"מונה הוא מבנה נתונים המחזיק מספר אי-שלילי ותומך בפעולת Increment. קריאה לפעולה Increment מעלה את ערך המונה ב1. ממשים מונה ע""י מערך המאותחל לאפסים ומחזיק את ערך המונה בייצוג בינארי. מימוש Increment מתבצע ע""י מעבר על המערך מהLSB בסדר עולה: כל ביט שנתקלים בו וערכו 1 משונה להיות 0, והביט הראשון עם הערך 0 שנתקלים בו משונה להיות  1 ועוצרים. ניתן להניח כי גודל המערך מספיק לצורך החזקת ערך המונה. 

נניח כי ערך המונה הנוכחי הוא b, ושמבצעים m קריאות לIncrement ממצב זה (b אינו בהכרח קבוע!). מהו זמן הריצה הכולל של m הקריאות?

א. זמן הריצה הוא O(m).
ב. זמן הריצה הוא O(b).
ג. בהינתן שn=Ω(b), זמן הריצה הוא  O(m).
ד. בהינתן ש m=Ω(b), זמן הריצה הוא   O(m) . אם m=o(b), כל סדרה של m  קריאות תרוץ בזמן  Θ(b).
ה. אף תשובה לא נכונה",na,,,,מונה בינארי
C,TRUE,2015,B,A,10,T3/ds15ba-sol(vaad).docx,TAU,5,"\textbf{A counter is a data structure that holds a non-negative number and supports the Increment operation. A call to the Increment operation increases the value of the counter by 1. A counter is implemented by an array initialized to zeros and holds the counter's value in binary representation. The implementation of Increment is done by traversing the array from the LSB in ascending order: every bit encountered with a value of 1 is changed to 0, and the first bit with a value of 0 that is encountered is changed to 1, and then the process stops. It can be assumed that the array size is sufficient to hold the counter's value.}

\textbf{An additional operation, k-Increment, is added to the counter structure, which increases the current counter value by k, where k is a positive integer. (k should not be considered constant, but rather an additional parameter of the problem!) k-Increment is implemented by k consecutive calls to Increment.}

\textbf{In this question, it is assumed that the counter is initialized to 0. What is the amortized time complexity of the k-Increment function? (The answer may depend on the parameter k, the number of function calls so far, m, and/or the counter's final value, n.)}
\begin{enumerate}
    \item The amortized time complexity is \(O(1)\), as in the case of the Increment operation.
    \item The amortized time complexity is \(O(\log n)\), where \(n\) is the final counter value, as in the case of the Increment operation.
    \item The amortized time complexity is \(O(\log m)\), where \(m\) is the number of function calls.
    \item The amortized time complexity is \(O(k)\).
    \item The amortized time complexity is \(O(k \log n)\), where \(n\) is the final counter value.
    \item None of the answers is correct.
\end{enumerate}",D,na,6,"b,d,p",tested,,"מונה הוא מבנה נתונים המחזיק מספר אי-שלילי ותומך בפעולת Increment. קריאה לפעולה Increment מעלה את ערך המונה ב1. ממשים מונה ע""י מערך המאותחל לאפסים ומחזיק את ערך המונה בייצוג בינארי. מימוש Increment מתבצע ע""י מעבר על המערך מהLSB בסדר עולה: כל ביט שנתקלים בו וערכו 1 משונה להיות 0, והביט הראשון עם הערך 0 שנתקלים בו משונה להיות  1 ועוצרים. ניתן להניח כי גודל המערך מספיק לצורך החזקת ערך המונה. 

מוסיפים למבנה המונה פעולה נוספת, k-Increment, שמעלה את ערך המונה הנוכחי ב k, כאשר k הוא מספר שלם חיובי. (אין להתייחס לk כקבוע, אלא כפרמטר נוסף של השאלה!). 
מממשים את k-Increment על ידי k קריאות רצופות לIncrement. 

בשאלה זו מניחים כי המונה מאותחל להיות 0. 
מהי סיבוכיות זמן הריצה אמורטייזד של הפונקציה  k-Increment ?
(התשובה יכולה להיות תלויה בפרמטר k, במספר הקריאות לפונקציה עד כה,  m, ו/או בערך המונה הסופי, n.)
א. זמן הריצה אמורטייזד הוא O(1), כמו במקרה של הפעולה Increment.
ב. זמן הריצה אמורטייזד הוא O(log n), כאשר n הוא ערך המונה הסופי, כמו במקרה של הפעולה Increment.
ג. זמן הריצה אמורטייזד הוא O(log m), כאשר m הוא מספר הקריאות לפונקציה.
ד. זמן הריצה אמורטייזד הוא O(k).
ה. זמן הריצה אמורטייזד הוא O(k log⁡n ), כאשר n הוא ערך המונה הסופי.
ו. אף תשובה אינה נכונה.",na,,,,מונה בינארי
C,TRUE,2015,B,A,11,T3/ds15ba-sol(vaad).docx,TAU,5,"Given a comparison tree suitable for an algorithm that sorts $n$ numbers, what is the minimum depth of a leaf in the tree?
\begin{enumerate}
    \item Every path between the root and a leaf in such a tree is of length \(\Omega(n \log n)\).
    \item While the maximum depth is \(\Omega(n \log n)\), the minimum depth can be \(O(1)\).
    \item The minimum depth of a leaf in the tree is \(O(1)\).
    \item The minimum depth of a leaf in the tree is \(\Omega(\log n)\).
    \item The minimum depth of a leaf in the tree is \(\Omega(n)\).
    \item If there is a leaf at depth \(o(n \log n)\), there must be another leaf at depth \(\omega(n \log n)\), which means that the worst-case running time of the sorting algorithm discussed in the question is necessarily \(\omega(n \log n)\).
\end{enumerate}",E,na,6,"e,k",tested,,"נתון עץ השוואות המתאים לאלגוריתם הממיין n מספרים. מהו העומק המינימלי של עלה בעץ?

א. כל מסלול בין שורש לעלה בעץ כזה הוא באורך Ω(n log⁡〖n)〗.
ב. בעוד העומק המקסימלי הוא Ω(n log⁡〖n)〗, העומק המינימלי יכול להיות O(1).
ג. העומק המינימלי של עלה בעץ הוא O(1).
ד. העומק המינימלי של עלה בעץ הוא Ω(log⁡〖n)〗.
ה. העומק המינימלי של עלה בעץ הוא Ω(n).
ו. אם יש עלה בעומק o(n log⁡〖n)〗, חייב להיות עלה אחר בעומק ω(n log⁡〖n)〗, וזה אומר שזמן הריצה worst case של אלגוריתם המיון הנידון בשאלה הוא בהכרח ω(n log⁡〖n)〗.",na,,,,
C,TRUE,2015,B,A,12,T3/ds15ba-sol(vaad).docx,TAU,5,na,A,na,7,"e,k",untested,,"נתון אלגוריתם המקבל כקלט שתי רשימות ממויינות  וממזג אותן לכדי רשימה ממויינת אחת. תחת ההנחה של מודל ההשוואות, מה ניתן לומר על זמן הריצה worst case של האלגוריתם?

א. שווה לאורך המסלול המקסימלי בין שורש לעלה בעץ, ובמקרה זה Ω(n).
ב. שווה לאורך המסלול המינימלי בין שורש לעלה בעץ, ובמקרה זה Ω(n).
ג. שווה לאורך המסלול המקסימלי בין שורש לעלה בעץ, ובמקרה זה Ω(log⁡n).
ד. שווה לאורך המסלול המינימלי בין שורש לעלה בעץ, ובמקרה זה  Ω(log⁡n).
ה. שווה לאורך המסלול המקסימלי בין שורש לעלה בעץ, ובמקרה זה Ω(n log⁡n).
ו. שווה לאורך המסלול המינימלי בין שורש לעלה בעץ, ובמקרה זה Ω(n log⁡n).
ז. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2015,B,A,13,T3/ds15ba-sol(vaad).docx,TAU,5,"
\textbf{The following is the pseudocode for the Huffman algorithm. What is the runtime of the algorithm when the priority queue $Q$ is implemented with a binomial heap using lazy meld? Choose the most accurate answer.}

\textbf{Huffman}($C$) \quad /* $C$ is an array containing the alphabet */
\begin{itemize} \item $n \gets |C|$ \item \textbf{for} $i \gets 1$ \textbf{to} $n$ \begin{itemize} \item $z \gets C[i]$ \item \textbf{insert}($z, Q$) \end{itemize} \item \textbf{for} $i \gets 1$ \textbf{to} $n-1$ \begin{itemize} \item \textbf{do new}($z$) \item \textbf{left}($z$) $\gets x \gets$ \textbf{delete-min}($Q$) \item \textbf{right}($z$) $\gets y \gets$ \textbf{delete-min}($Q$) \item $f(z) \gets f(x) + f(y)$ \item \textbf{insert}($z, Q$) \end{itemize} \item \textbf{return} \textbf{delete-min}($Q$) \end{itemize}
\begin{enumerate}
    \item All the delete-min(Q) operations in the algorithm cost $O(\log n)$.
    \item All the delete-min(Q) operations in the algorithm cost $O(n)$ and none of them can be said to be $o(n)$.
    \item All the delete-min(Q) operations in the algorithm cost $O(\log n)$ except for the first two, which are $\Theta(n)$.
    \item All the delete-min(Q) operations in the algorithm cost $O(\log n)$ except for the first one, which is $\Theta(n)$.
    \item All the delete-min(Q) operations in the algorithm cost $O(1)$ except for the first one, which is $\Theta(\log n)$.
    \item Incorrect answer.
\end{enumerate}",D,na,6,"a,i",tested,,"מצורף פסאודו קוד של אלגוריתם האפמן.
מה זמן הריצה של האלגוריתם, כשמממשים את תור העדיפויות Q באמצעות ערימה בינומית עם lazy meld?  בחרו את התשובה המדויקת ביותר.

Huffman(C)    /* C is an array containing the alphabet */ 
     n ← |C|
    for i ← 1 to n
        z ←C[i]
        insert(z,Q)
    
     for i ← 1 to n-1
          do new(z)
               left(z) ← x ← delete-min(Q)
               right(z) ← y ← delete-min(Q)
               f(z) ← f(x) + f(y)
               insert(z,Q)
    return delete-min(Q)


א. כל פעולות ה deletemin(Q) באלגוריתם עולות O(log n) .
ב. כל פעולות ה deletemin(Q) באלגוריתם עולות O(n)   ולא ניתן לומר על אף אחת מהן שהיא o(n).
ג. כל פעולות ה deletemin(Q) באלגוריתם עולות O(log n)  פרט לשתי הראשונות שהינן Θ(n).
ד. כל פעולות ה deletemin(Q) באלגוריתם עולותO(log n)  פרט לראשונה שהינה  Θ(n).
ה. כל פעולות ה deletemin(Q) באלגוריתם עולותO(1)  פרט לראשונה שהינה Θ(log⁡〖n)〗.
ו. תשובה לא נכונה.",na,,,,
C,TRUE,2014,B,A,1,T3/ds14ba-sol(vaad).pdf,TAU,5,"A new algorithm named new-rand-partition receives an array A with indices from 1 to n. It performs:
1. Randomly select an integer between 1 and n (inclusive) without repetition and store it in variable x. Let A[x] be denoted by p.
2. Perform a partition according to the pivot element p. Denote by m the position of the element p in the array at the end of the process.
3. If m<n/6 or m>5n/6, return the array to its state before step 2 and go back to section 1. Otherwise, finish.

Assume that in section 1, each time a different number is drawn (i.e., drawing without repetition).
What is the number of comparisons the algorithm makes in the worst case?
a. \(O(1)\)
b. \(O(\log n)\)
c. \(O(n)\)
d. \(O(n \log n)\)
e. \(O(n^2)\)
f. The number of comparisons the algorithm makes in the worst case is not bounded.",E,na,6,"a,m",tested,,"אלגוריתם חדש בשם new-rand-partition מקבל מערך A בעל אינדקסים 1 עד n. הוא מבצע:
1. הגרל מספר שלם בין 1 ל-n( כולל( ללא החזרה ושמור אותו במשתנה x. נסמן איבר A[x] ב-p.
2. בצע partition לפי איבר הפיבוט p. נסמן ב-m את מיקום האיבר p במערך בסיום התהליך.
3. אם m<n/6 או m>5n/6, החזר את המערך למצבו לפני שלב 2 וחזור לסעיף 1. אחרת, סיים.
הניחו שבסעיף 1 כל פעם מוגרל מספר אחר )כלומר, הגרלה ללא החזרה(.
מה מספר ההשוואות שהאלגוריתם מבצע במקרה הגרוע?
א. (1)O
O(log n) .ב
O(n) .ג
O (n log n) .ד
ה. O(n^2)
ו. מספר ההשוואות שהאלגוריתם מבצע במקרה הגרוע לא חסום.",na,,,,
C,TRUE,2014,B,A,2,T3/ds14ba-sol(vaad).pdf,TAU,5,na,C,na,6,a.m,untested,,"אלגוריתם חדש בשם new-rand-partition מקבל מערך A בעל אינדקסים 1 עד n. הוא מבצע:
1. הגרל מספר שלם בין 1 ל-n( כולל( ללא החזרה ושמור אותו במשתנה x. נסמן איבר A[x] ב-p.
2. בצע partition לפי איבר הפיבוט p. נסמן ב-m את מיקום האיבר p במערך בסיום התהליך.
3. אם m<n/6 או m>5n/6, החזר את המערך למצבו לפני שלב 2 וחזור לסעיף 1. אחרת, סיים.
הניחו שבסעיף 1 כל פעם מוגרל מספר אחר )כלומר, הגרלה ללא החזרה(.
מה מספר ההשוואות שהאלגוריתם מבצע בתוחלת?
א. (1)O
O(log n) .ב
O(n) .ג
O (n log n) .ד
ה. O(n^2)
ו. מספר ההשוואות שהאלגוריתם מבצע במקרה הגרוע לא חסום.",na,,,,
C,TRUE,2014,B,A,3,T3/ds14ba-sol(vaad).pdf,TAU,5,na,B,na,6,"b,p",untested,,"נתון מימוש של תור באמצעות שתי מחסניות 1S ו2-S, שמאותחלות לריקות בהתחלה:
Enqueu(x) 
S1.push(x) 

Dequeue()
If (S2.empty())
While (not(S1.empty())
x = S1.pop()
S2.push(x)
return S2.pop()
סטודנט ניתח זמן ריצה אמורטייזד באמצעות שתי פונקציות פוטנציאל: f1=|S1| ו-f2=|S2|
( הסימון |Si| = מספר האיברים במחסנית Si). מה יצא זמן הריצה אמורטייזד של dequeue לפי כל פונקציה:
א. (1)O לפי שתי הפונקציות.
ב. O(1) לפי f1 ו-O(n) לפי f2.
ג. O(1) לפי f2 וO(n) לפי f1.
ד. O(n) לפי שתי הפונקציות.
ה. אחת מהפונקציות לא חוקית לניתוח זמן ריצה אמורטייזד ולפי האחרת (1)O.
ו. אחת מהפונקציות לא חוקית לניתוח זמן ריצה אמורטייזד ולפי האחרת O(n).",na,,,,"מחסנית, פונקציית פוטנציאל"
C,TRUE,2014,B,A,4,T3/ds14ba-sol(vaad).pdf,TAU,5,"\begin{enumerate}
    \item Given an array with \( n \) integers in the range from 1 to \( \lfloor n \log n \rfloor \). Choose the most correct answer.
    \begin{enumerate}
        \item It is possible to sort using count-sort in \( O(n) \) time in the worst case.
        \item It is possible to sort using radix-sort with base \( \sqrt{n} \) in \( O(n) \) time in the worst case.
        \item It is possible to sort using merge-sort in \( O(n) \) time in the worst case.
        \item It is possible to sort using quick-sort in \( O(n) \) time in the worst case.
        \item Answers (a) and (b).
        \item None of the answers is correct.
    \end{enumerate}
\end{enumerate}",B,na,6,"a,l",tested,,"נתון מערך עם n מספרים שלמים בתחום 1 עד ⌊n log⁡n ⌋. בחר את התשובה הנכונה ביותר.
א. ניתן למיין על-ידי count-sort בזמן O(n) במקרה הגרוע.
ב. ניתן למיין על-ידי radix-sort בבסיס √n בזמן O(n) במקרה הגרוע.
ג. ניתן למיין על-ידי merge-sort בזמן O(n) במקרה הגרוע.
ד. ניתן למיין על-ידי quick-sort בזמן O(n) במקרה הגרוע.
ה. תשובות א' ו-ב'.
ו. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2014,B,A,5,T3/ds14ba-sol(vaad).pdf,TAU,5,"\begin{quote}
In the homework, we encountered a d-ary heap. This is a heap that is implemented like a binary heap, with the difference that each node—except for leaves and at most one node in the second-to-last layer—has d children. The heap is represented using an array. The root is at position 0, and the children of index i are at positions di+1, ..., di+d. Note that d is not constant, but a parameter in the question.

\texttt{Huffman(C)} \\
$n \leftarrow |C|$ \\
$Q \leftarrow C$ \\
\textbf{for} $i \leftarrow 1$ \textbf{to} $n-1$ \\
\hspace{1em} \textbf{do} \textbf{new}$(z)$ \\
\hspace{2em} \textbf{left}$(z) \leftarrow x \leftarrow \textbf{delete-min}(Q)$ \\
\hspace{2em} \textbf{right}$(z) \leftarrow y \leftarrow \textbf{delete-min}(Q)$ \\
\hspace{2em} $f(z) \leftarrow f(x) + f(y)$ \\
\hspace{2em} \textbf{insert}$(z,Q)$ \\
\textbf{return} \textbf{delete-min}$(Q)$

What is the running time of Huffman's algorithm, when the priority queue $Q$ is implemented using a d-ary heap? \\
(A) $O(n)$ \\
(B) $O(n \log_d n)$ \\
(C) $O(n \log n)$ \\
(D) $O(n d)$ \\
(E) $O(n d \log_d n)$ \\
(F) $O(n^2)$
\end{quote}",E,na,6,"a,h",tested,,"בשיעורי הבית נתקלנו בערימה d-ארית. זוהי ערימה שממומשת כמו ערימה בינארית, בהבדל שבו לכל צומת, פרט לעלים ולצומת אחד לכל היותר בשכבה הלפני אחרונה, יש d ילדים. הערימה מיוצגת באמצעות מערך. השורש במקום 0, והילדים של אינדקס i במקום di+1,…,di+d. שימו-לב, d לא קבוע, אלא פרמטר בשאלה.
Huffman(C)
 n ← |C|
 Q ← C
 for i ← 1 to n-1
 do new(z)
 left(z) ← x ← delete-min(Q)
 right(z) ← y ← delete-min(Q)
 f(z) ← f(x) + f(y)
 insert(z,Q)
 	return delete-min(Q)
מה זמן הריצה של אלג' האפמן, כשממשים את תור העדיפויות Q באמצעות ערימה d-ארית?
O(n) .א
O(n log_d n) .ב
O(n log n) .ג
O(n d) .ד
O(n d log_d n) .ה
ו. O(n^2)",na,,,,
C,TRUE,2014,B,A,6,T3/ds14ba-sol(vaad).pdf,TAU,5,"\textbf{Given the following Compressed Suffix Tree structure (each edge can contain more than one character):}
O 
/ \      
 O O
/ \      
 O O
/ \      
 O O
/ \      
 O O

\textbf{Which strings can match it?}

a. ABCD  
b. ABCA  
c. ABAB  
d. ABBB  
e. AAAA 
f. c and d",E,na,6,o,tested,,"נתון מבנה ה-Compressed Suffix tree הבא (כל קשת יכולה להכיל יותר מתו אחד). 
O 
/ \      
 O O
/ \      
 O O
/ \      
 O O
/ \      
 O O

אילו מחרוזות יכולות להתאים לו?

א. ABCD  
ב. ABCA  
ג. ABAB  
ד. ABBB  
ה. AAAA 
ו. ג' וד'",na,,,,
C,TRUE,2014,B,A,7,T3/ds14ba-sol(vaad).pdf,TAU,5,"\[
\text{Given a binary search tree with pointers to the maximum and minimum, and with two additional operations: }
\]

\text{Insert-max – Insert an element (guaranteed to be larger than the other elements in the tree) as the right child of the maximum (a pointer to the maximum is given). Update the pointer to the maximum to the newly inserted element.}

\text{Delete-min – Find the successor of the minimum (search for the successor from the minimum position using the successor operation learned in class), delete the minimum from its position (a pointer is given). Update the pointer to the minimum to point to the successor.}

\text{What is the worst-case running time for the Insert-max operation:}

\text{a. }\ O(1)

\text{b. }\ O(\log \log n)

\text{c. }\ O(\log n)

\text{d. }\ O(n)

\text{e. }\ O(n \log n)

\text{f. }\ O(n^2)
",A,na,6,"a,e",tested,,"נתון עץ חיפוש בינארי עם מצביעים למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר )מובטח שהוא גדול משאר איברי העץ( כילד ימני של המקסימום )נתון 
מצביע למקסימום(. עדכן מצביע למקסימום לאיבר החדש שהוכנס.
Delete-min – מצא את העוקב של המינימום )חיפוש העוקב ממקום המינימום על-ידי פעולת successor שנלמדה בכיתה(, מחק את המינימום ממקומו )נתון מצביע(. עדכן את המצביע למינימום להצביע לעוקב.
מה זמן ריצה worst case לפעולת Insert-max:
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
ו. O(n^2)",na,,,,
C,TRUE,2014,B,A,8,T3/ds14ba-sol(vaad).pdf,TAU,5,na,D,na,6,a.e,untested,,"נתון עץ חיפוש בינארי עם מצביעים למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר )מובטח שהוא גדול משאר איברי העץ( כילד ימני של המקסימום )נתון 
מצביע למקסימום(. עדכן מצביע למקסימום לאיבר החדש שהוכנס.
Delete-min – מצא את העוקב של המינימום )חיפוש העוקב ממקום המינימום על-ידי פעולת successor שנלמדה בכיתה(, מחק את המינימום ממקומו )נתון מצביע(. עדכן את המצביע למינימום להצביע לעוקב.
מה זמן ריצה worst case לפעולת Delete-min:
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
ו. O(n^2)",na,,,,
C,TRUE,2014,B,A,9,T3/ds14ba-sol(vaad).pdf,TAU,5,na,D,na,6,"a,i",untested,,"הכניסו לערימה בינומית )לא עצלה( סדרה של n איברים ממוינים הפוך, כלומר מהגדול ביותר לקטן ביותר. לאחר מכן ביצעו n פעולות min-delete מן הערימה.
בשאלה זו נספור את מספר ה linking שהתבצעו, כלומר כמות הפעמים שעץ נתלה על עץ אחר.
מהו מספר ה linking שהתבצע ב worst case בפעולת insert ומה מספר ה-linking שהתבצע ב- worst caseלכל פעולות insert ביחד?
א. (1)O לפעולה ו (1)O לכל הסדרה
ב. (1)O לפעולה ו O(log n) לכל הסדרה
ג. (1)O לפעולה ו O(n) לכל הסדרה
ד. O(log n) לפעולה ו O(n) לכל הסדרה
הסדרה לכל O(n log n) ו לפעולה O(log n) .ה
הסדרה לכל O(n log n) ו לפעולה O(n) .ו",na,,,,
C,TRUE,2014,B,A,10,T3/ds14ba-sol(vaad).pdf,TAU,5,na,A,na,6,"a,i",untested,,"הכניסו לערימה בינומית )לא עצלה( סדרה של n איברים ממוינים הפוך, כלומר מהגדול ביותר לקטן ביותר. לאחר מכן ביצעו n פעולות min-delete מן הערימה.
בשאלה זו נספור את מספר ה linking שהתבצעו, כלומר כמות הפעמים שעץ נתלה על עץ אחר.
מהו מספר ה linking שהתבצע ב worst case בפעולת delete-min ומה מספר ה-linking שהתבצע ב- worst case בכל פעולות delete-min ביחד?
א. (1)O לפעולה ו (1)O לכל הסדרה
ב. (1)O לפעולה ו O(log n) לכל הסדרה
ג. (1)O לפעולה ו O(n) לכל הסדרה
ד. O(log n) לפעולה ו O(n) לכל הסדרה
הסדרה לכל O(n log n) ו לפעולה O(log n) .ה
הסדרה לכל O(n log n) ו לפעולה O(n) .ו",na,,,,
C,TRUE,2014,B,A,11,T3/ds14ba-sol(vaad).pdf,TAU,5,na,F,na,6,"a,k",untested,,"נגדיר מערך זיג-זג, עבורו קיימים n ≤ i ≤ j ≤ 1 כלשהם כך שכל האיברים במערך במקומות בין 1 ל i בסדר עולה, כל האיברים במקומות בין i ל j בסדר יורד, וכל האיברים בין j ל n בסדר עולה.
נקרא ל-i איבר הפסגה ול-j איבר העמק.
נתון מערך זיג-זג, בחרו את התשובה הנכונה ביותר )חסם הדוק ביותר(:
א. חסם תחתון הדוק ביותר במודל ההשוואות לבעיית מציאת איבר הפסגה ואיבר העמק, כאשר 
שניהם אינם ידועים, הוא Ω(log n).
ב. חסם תחתון הדוק ביותר במודל ההשוואות לבעיית מציאת איבר הפסגה ואיבר העמק, כאשר שניהם אינם ידועים הוא Ω(n).
ג. אם נתון מיקום אחד האיברים ניתן למצוא את האיבר השני ב (1)O
ד. אם נתון מיקום אחד האיברים ניתן למצוא את האיבר השני ב O(log n).
ה. תשובות א' ו ג' נכונות
ו. תשובות ב' ו ד' נכונות",na,,,,
C,TRUE,2014,B,A,12,T3/ds14ba-sol(vaad).pdf,TAU,5,na,D,na,6,"a,k",untested,,"נגדיר מערך זיג-זג, עבורו קיימים n ≤ i ≤ j ≤ 1 כלשהם כך שכל האיברים במערך במקומות בין 1 ל i בסדר עולה, כל האיברים במקומות בין i ל j בסדר יורד, וכל האיברים בין j ל n בסדר עולה.
נקרא ל-i איבר הפסגה ול-j איבר העמק.
נתון מערך זיג-זג, ומיקום איבר הפסגה ואיבר העמק לא ידועים. מהו החסם העליון ההדוק ביותר למיון המערך?
O(log n) .א
ב. O(log ^ 2 n)
O(n / logn) .ג
O(n) .ד
O(n log log n) .ה
O(n log n) .ו",na,,,,
C,TRUE,2014,B,A,13,T3/ds14ba-sol(vaad).pdf,TAU,5,"\text{Given a set } D \text{ of } n \text{ distinct elements and a family of universal functions } H \text{ from } D \text{ to a domain of size } m \text{ for which the collision probability is } \Pr[h(k_1) = h(k_2)] \leq 1/m \text{ for all } k_1 \neq k_2. \text{ It is given that } m = (n/ \log n). \text{ Assume that } h \text{ is chosen randomly, and we are interested in a function } h \text{ for which the number of collisions is less than } n \log n. \text{ Choose the tightest upper bound on the expected number of draws until a function satisfying the condition is drawn:} 
\text{a. } 1 
\text{b. } 2 
\text{c. } \log n 
\text{d. } n / 2 
\text{e. } n 
\text{f. The expected number of draws is unbounded.}",B,na,6,"g,p",tested,,"נתון אוסף D של n איברים שונים זה מזה, ומשפחת פונקציות אוניברסליות H מ D לתחום בגודל m שעבורן הסיכוי להתנגשות הוא Pr[h(k1) = h(k2)] ≤ 1/m לכל k1≠k2. נתון ש m = (n/ log n). 
נניח ש h נבחרת באקראי, ואנו מעוניינים בפונקציה h עבורה מספר ההתנגשויות קטן מ n log n.
בחר בחסם העליון ההדוק ביותר למספר ההגרלות בתוחלת עד להגרלת פונקציה המקיימת את התנאי:
א. .1
ב. .2
ג. log n
ד. n / 2
 ה. n
ו. מספר ההגרלות בתוחלת לא חסום.",na,,,,פונקציות אוניברסליות
C,TRUE,2014,B,A,14,T3/ds14ba-sol(vaad).pdf,TAU,5,na,C,na,6,"a,g,p",untested,,"מבצעים two level hash בעזרת פונקציה h בעלת מספר התנגשויות קטן מ n log n (כלומר, ברמה הראשונה עד n log n התנגשויות, ובכל תא i עם ni איברים פותרים בעזרת טבלה בגודל ni^2 ועבורה מחפשים פונקציה ללא התנגשויות, כפי שלמד בכיתה). מהו זמן הריצה בחלוקת של כל תהליך הבנייה?
א. O(1)
ב. O(n)
ג. O(n log n)
ד. O(n log^2 n)
ה. O(n^2)
ו. זמן הריצה בתוחלת של כל תהליך הבנייה לא חסום",na,,,,פונקציות אוניברסליות
C,TRUE,2014,B,A,15,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textbf{Is the following statement true or false?} 
(Assume that the elements are distinct from one another). 
Given a red-black tree, a binary heap containing the same elements can be produced in O(n). 
Provide a brief justification.",1,na,2,"h,p",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן עץ אדום שחור, ניתן לייצר ערימה בינארית המכילה את אותם איברים ב O(n).
הוסף נימוק קצר. ",na,,,,עץ אדום שחור
C,TRUE,2014,B,A,16,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textbf{Is the following statement true or false?} (Assume the elements are distinct from one another.) Given a binary heap, it is possible to create a sorted array containing the same elements in $O(n)$. \textbf{Add a short argument.}",FALSE,na,2,"h,d",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן ערימה בינארית, ניתן לייצר מערך ממוין המכיל את אותם איברים ב O(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,17,T3/ds14ba-sol(vaad).pdf,TAU,3,\textit{Is the following claim true or false? (Assume the elements are distinct from each other). A binary tree (not necessarily a search tree) can be uniquely reconstructed when the post-order traversal and the height of each element in the tree are given. Add a brief explanation.},FALSE,na,2,e,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ בינארי )לא בהכרח עץ חיפוש( באופן יחיד כאשר נתונה סריקת post order ועבור כל איבר מה גובהו בעץ.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,18,T3/ds14ba-sol(vaad).pdf,TAU,3,\textbf{Is the following claim true or false?} (Assume that the elements are distinct from each other.) A binary tree (not necessarily a search tree) can be uniquely reconstructed when given an inorder traversal and the height of each element in the tree. Provide a brief explanation.,1,na,2,e,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ בינארי )לא בהכרח עץ חיפוש( באופן יחיד כאשר נתונה סריקת inorder ועבור כל איבר מה גובהו בעץ.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,19,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textbf{Is the following claim true or false?} 
(Assume that the elements are distinct from one another.)
A binary tree (not necessarily a search tree) can be uniquely reconstructed given an inorder traversal and the knowledge of whether each element is the root and whether it is a leaf.
Provide a brief justification.",FALSE,na,2,e,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ בינארי )לא בהכרח עץ חיפוש( באופן יחיד כאשר נתונה סריקת inorder וידוע עבור כל איבר האם הוא השורש והאם הוא עלה.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,20,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textit{Is the following claim true or false? (Assume the elements are distinct from each other). In a Fibonacci heap, during a single decrease-key operation, $\Theta(n)$ cuts can occur (for any $n$). Add a brief explanation.}",1,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימת פיבונצ'י בפעולת dec-key אחת יכולות להתבצע θ(n) תלישות (עבור כל n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,21,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textit{Is the following claim true or false? (Assume the elements are distinct from each other). Given 2 binomial heaps (not lazy) each containing n elements, they can be merged into a single binomial heap with 2n elements in $O(\log n)$. Provide a short justification.}",1,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן 2 ערימות בינומיות )לא עצלות( של n איברים כל אחת ניתן לחבר אותן לערימה בינומית אחת של 2n איברים בO(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,22,T3/ds14ba-sol(vaad).pdf,TAU,3,na,1,na,2,h,untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינארית )עם יותר מ10 איברים( הערך הגדול ביותר הוא בהכרח בעלה.
הוסף נימוק קצר.",na,,,,
C,TRUE,2014,B,A,23,T3/ds14ba-sol(vaad).pdf,TAU,3,"\begin{quote}
Is the following statement true or false? (Assume that the elements are distinct from one another). In a lazy binomial heap, in one del-min operation more than $n/2$ linkings can occur (for any even $n$). Add a brief justification.
\end{quote}",1,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינומית עצלה בפעולת del-min אחת יכולות להתבצע יותר מ n/2 תליות (עבור כל n זוגי(.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,A,24,T3/ds14ba-sol(vaad).pdf,TAU,3,"\textbf{Is the following claim true or false?} 
(Assume that the elements are distinct from one another). 
In a binary heap (with more than 10 elements), the second largest element (the largest one except for the maximum) is necessarily a leaf.
Provide a short justification.",FALSE,na,2,h,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינארית )עם יותר מ10 איברים( האיבר השני בגודלו )הגדול ביותר פרט למקסימום( הוא בהכרח בעלה.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,1,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,F,na,6,"a,m",untested,,"אלגוריתם חדש בשם new-rand-partition מקבל מערך A וזוג אינדקסים במערך i ו-j (כך ש i≤j).
1. אם i=j, סיים.
2. הגרל מספר שלם בין i ל-j ( כולל( ושמור אותו במשתנה x. נסמן איבר A[x] ב-p.
3. בצע partition לפי איבר הפיבוט p. נסמן ב-m את מיקום האיבר p במערך בסיום התהליך.
4. אם m<n/6 או m>5n/6, החזר את המערך למצבו לפני שלב 3 וחזור לסעיף 2. אחרת, סיים.
מחליפים את תהליך בחירת הפיבוט וה-patition באלגוריתם  select(למציאת האיבר ה-i בגודלו) הנלמד בכיתה באלגוריתם new-rand-partition. הנח כי ההגרלה לוקחת זמן קבוע וכי ניתן להחזיר את המערך למצבו לפני שלב 3 בזמן לינארי בגודל המערך.
מה יהיה זמן הריצה במקרה הגרוע של אלגוריתם select החדש?

א. (1)O
O(log n) .ב
O(n) .ג
O (n log n) .ד
ה. O(n^2)
ו. זמן הריצה במקרה הגרוע של האלגוריתם החדש לא חסום.",na,,,,
C,TRUE,2014,B,B,2,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,C,na,6,a.m,untested,,"אלגוריתם חדש בשם new-rand-partition מקבל מערך A וזוג אינדקסים במערך i ו-j (כך ש i≤j).
1. אם i=j, סיים.
2. הגרל מספר שלם בין i ל-j ( כולל( ושמור אותו במשתנה x. נסמן איבר A[x] ב-p.
3. בצע partition לפי איבר הפיבוט p. נסמן ב-m את מיקום האיבר p במערך בסיום התהליך.
4. אם m<n/6 או m>5n/6, החזר את המערך למצבו לפני שלב 3 וחזור לסעיף 2. אחרת, סיים.
מחליפים את תהליך בחירת הפיבוט וה-patition באלגוריתם  select(למציאת האיבר ה-i בגודלו) הנלמד בכיתה באלגוריתם new-rand-partition. הנח כי ההגרלה לוקחת זמן קבוע וכי ניתן להחזיר את המערך למצבו לפני שלב 3 בזמן לינארי בגודל המערך.
מה יהיה זמן הריצה בתוחלת של אלגוריתם select החדש?
א. (1)O
O(log n) .ב
O(n) .ג
O (n log n) .ד
ה. O(n^2)
ו. זמן הריצה במקרה הגרוע של האלגוריתם החדש לא חסום.",na,,,,
C,TRUE,2014,B,B,3,T3/ds14bb-official sol(vaad).pdf,TAU,5,"\textbf{Given an implementation of a queue using two stacks $S_1$ and $S_2$, which are initialized as empty:}

\textbf{Enqueue(x):}
\begin{verbatim}
S1.push(x)
\end{verbatim}

\textbf{Dequeue():}
\begin{verbatim}
If (S2.empty())
    While (not(S1.empty()))
        x = S1.pop()
        S2.push(x)
return S2.pop()
\end{verbatim}

A student analyzed the amortized running time using two potential functions: $f_1 = |S_1| + |S_2|$ and $f_2 = |S_1| - |S_2|$ (where $|S_i|$ represents the number of elements in stack $S_i$). What is the amortized running time of dequeue according to each function:

a. $O(1)$ according to both functions.  
b. $O(1)$ according to $f_1$ and $O(n)$ according to $f_2$.  
c. $O(1)$ according to $f_2$ and $O(n)$ according to $f_1$.  
d. $O(n)$ according to both functions.  
e. One of the functions is invalid for amortized running time analysis and according to the other $O(1)$.  
f. One of the functions is invalid for amortized running time analysis and according to the other $O(n)$.",F,na,6,"b,p",tested,,"נתון מימוש של תור באמצעות שתי מחסניות 1S ו2-S, שמאותחלות לריקות בהתחלה:
Enqueu(x) 
S1.push(x) 

Dequeue()
If (S2.empty())
While (not(S1.empty())
x = S1.pop()
S2.push(x)
return S2.pop()
סטודנט ניתח זמן ריצה אמורטייזד באמצעות שתי פונקציות פוטנציאל: f1=|S1|+|S2| ו-f2=|S1|-|S2| ( הסימון |Si| = מספר האיברים במחסנית Si). מה יצא זמן הריצה אמורטייזד של dequeue לפי כל פונקציה:
א. (1)O לפי שתי הפונקציות.
ב. O(1) לפי f1 ו-O(n) לפי f2.
ג. O(1) לפי f2 וO(n) לפי f1.
ד. O(n) לפי שתי הפונקציות.
ה. אחת מהפונקציות לא חוקית לניתוח זמן ריצה אמורטייזד ולפי האחרת (1)O.
ו. אחת מהפונקציות לא חוקית לניתוח זמן ריצה אמורטייזד ולפי האחרת O(n).",na,,,,"מחסנית, פונקציית פוטנציאל"
C,TRUE,2014,B,B,4,T3/ds14bb-official sol(vaad).pdf,TAU,5,"\text{Given an array with } n \text{ integers in the range 1 to } n\text{. Choose the most correct answer.} \\ 
\text{A. It is possible to sort using count-sort in } O(n) \text{ time in the worst case.} \\
\text{B. It is possible to sort using radix-sort in base 2 in } O(n) \text{ time in the worst case.} \\
\text{C. It is possible to sort using merge-sort in } O(n) \text{ time in the worst case.} \\
\text{D. It is possible to sort using quick-sort in } O(n) \text{ time in the worst case.} \\
\text{E. Answers A and B.} \\
\text{F. None of the answers are correct.}",A,na,6,"a,l",tested,,"נתון מערך עם n מספרים שלמים בתחום 1 עד n. בחר את התשובה הנכונה ביותר.
א. ניתן למיין על-ידי count-sort בזמן O(n) במקרה הגרוע.
ב. ניתן למיין על-ידי radix-sort בבסיס 2 בזמן O(n) במקרה הגרוע.
ג. ניתן למיין על-ידי merge-sort בזמן O(n) במקרה הגרוע.
ד. ניתן למיין על-ידי quick-sort בזמן O(n) במקרה הגרוע.
ה. תשובות א' ו-ב'.
ו. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2014,B,B,5,T3/ds14bb-official sol(vaad).pdf,TAU,5,"\textbf{Huffman}($C$)
\begin{itemize} \item $n \gets |C|$ \item $Q \gets C$ \item \textbf{for} $i \gets 1$ \textbf{to} $n-1$ \begin{itemize} \item \textbf{do new}($z$) \item \textbf{left}($z$) $\gets x \gets$ \textbf{delete-min}($Q$) \item \textbf{right}($z$) $\gets y \gets$ \textbf{delete-min}($Q$) \item $f(z) \gets f(x) + f(y)$ \item \textbf{insert}($z, Q$) \end{itemize} \item \textbf{return} \textbf{delete-min}($Q$) \end{itemize}
\begin{enumerate}
\item What is the running time of Huffman's algorithm when the priority queue \( Q \) is implemented using a Fibonacci heap?
\begin{enumerate}
\item O(\log n)
\item O(n)
\item O(n \log n)
\item O(n \log^2 n)
\item O(n^2)
\item O(n^2 \log n)
\end{enumerate}
\end{enumerate}",C,na,6,"a,i",tested,,"Huffman(C)
 n ← |C|
 Q ← C
 for i ← 1 to n-1
 do new(z)
 left(z) ← x ← delete-min(Q)
 right(z) ← y ← delete-min(Q)
 f(z) ← f(x) + f(y)
 insert(z,Q)
 	return delete-min(Q)
מה זמן הריצה של אלג' האפמן, כשממשים את תור העדיפויות Q באמצעות ערימת פיבונצ'י?
א. O(log n)
ב. O(n)
ג. O(n log n)
ד. O(n log ^2 n)
ה. O(n^2)
ו. O(n^2 log n)",na,,,,
C,TRUE,2014,B,B,6,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,D,na,6,o,untested,,,na,,,,
C,TRUE,2014,B,B,7,T3/ds14bb-official sol(vaad).pdf,TAU,5,"Given a binary search tree with pointers to the maximum and minimum, and two additional operations have been added:
Insert-max – Insert an element (guaranteed to be larger than the rest of the tree elements) as the right child of the maximum (given a pointer to the maximum). Update the pointer to the maximum to the newly inserted element.
Delete-min – Find the successor of the minimum (search the successor from the minimum position using the successor operation learned in class), delete the minimum from its position (given a pointer). Update the pointer to the minimum to point to the successor.
The following series of operations are performed: Given a sorted array of size \( n \) and an empty binary search tree, perform Insert-max on the array elements from smallest to largest. Then, perform Delete-min until the tree is empty.
What is the worst-case running time for the described series of operations?
A. \( O(1) \)
B. \( O(\log \log n) \)
C. \( O(\log n) \)
D. \( O(n) \)
E. \( O(n \log n) \)
F. \( O(n^2) \)",D,na,6,"a,e",tested,,"נתון עץ חיפוש בינארי עם מצביעים למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר )מובטח שהוא גדול משאר איברי העץ( כילד ימני של המקסימום )נתון מצביע למקסימום(. עדכן מצביע למקסימום לאיבר החדש שהוכנס.
Delete-min – מצא את העוקב של המינימום )חיפוש העוקב ממקום המינימום על-ידי פעולת successor שנלמדה בכיתה(, מחק את המינימום ממקומו )נתון מצביע(. עדכן את המצביע למינימום להצביע לעוקב.
מבצעים את סדרת הפעולות הבאה: נתון מערך ממויין בגודל n ועץ חיפוש בינארי ריק, ומבצעיםInsert-max  על איברי המערך מהקטן לגדול. לאחר מכן, מבצעים Delete-min עד שהעץ ריק.
מה זמן ריצה worst case לסדרת הפעולות המתוארת?
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
ו. O(n^2)",na,,,,
C,TRUE,2014,B,B,8,T3/ds14bb-official sol(vaad).pdf,TAU,5,"Given a binary search tree with pointers to the maximum and minimum, two additional operations are introduced:

Insert-max – insert an element (guaranteed to be larger than the other elements of the tree) as the right child of the maximum (a pointer to the maximum is provided). Update the pointer to the maximum to the newly inserted element.

Delete-min – Find the successor of the minimum (search the successor from the minimum position using the successor operation learned in class), remove the minimum from its position (a pointer is provided). Update the pointer to the minimum to point to the successor.

The following sequence of operations is performed: Given a sorted array of size \( n \) and an empty binary search tree, perform Insert-max on the elements of the array from smallest to largest. Then, perform Delete-min until the tree is empty.

Select the tightest valid bound for the height of the tree throughout the sequence of operations. 
A. \( 1 \)
B. \( \log_2 \log_2 n \)
C. \( \log_2 n \)
D. \( \frac{n}{2} \)
E. \( n \)
F. \( n \log_2 n \)",E,na,6,"a,e",tested,,"נתון עץ חיפוש בינארי עם מצביעים למקסימום ולמינימום ונוספו לו עוד שתי פעולות:
Insert-max – הכנס איבר )מובטח שהוא גדול משאר איברי העץ( כילד ימני של המקסימום )נתון מצביע למקסימום(. עדכן מצביע למקסימום לאיבר החדש שהוכנס.
Delete-min – מצא את העוקב של המינימום )חיפוש העוקב ממקום המינימום על-ידי פעולת successor שנלמדה בכיתה(, מחק את המינימום ממקומו )נתון מצביע(. עדכן את המצביע למינימום להצביע לעוקב.
מבצעים את סדרת הפעולות הבאה: נתון מערך ממויין בגודל n ועץ חיפוש בינארי ריק, ומבצעיםInsert-max  על איברי המערך מהקטן לגדול. לאחר מכן, מבצעים Delete-min עד שהעץ ריק.
בחר בחסם ההדוק ביותר התקף לגובה העץ לכל אורך סדרת הפעולות. 
א. 1
ב. log_2 log_2 n
ג. log_2 n
ד. n / 2
ה. n
ו. n log_2 n",na,,,,
C,TRUE,2014,B,B,9,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,D,na,6,i,untested,,"הכניסו לערימה בינומית )לא עצלה( סדרה של n איברים בסדר כלשהו. לאחר מכן ביצעו n פעולות delete-min מן הערימה.
בשאלה זו נספור את מספר ה linking שהתבצעו, כלומר כמות הפעמים שעץ נתלה על עץ אחר.
מהו מספר ה linking שהתבצע ב worst case לפעולה בודדת בסדרה המתוארת?
א. (1)O ל-insert ו (1)O ל- delete-min
ב. (log n)O ל-insert ו (1)O ל- delete-min
ג. (1)O ל-insert ו (log n)O ל- delete-min
ד. (log n)O ל-insert ו (log n)O ל- delete-min
ה. (log n)O ל-insert ו (n)O ל- delete-min
ו. (n)O ל-insert ו (log n)O ל- delete-min",na,,,,
C,TRUE,2014,B,B,10,T3/ds14bb-official sol(vaad).pdf,TAU,5,"Insert a series of n elements in some order into a binomial heap (not lazy). Then perform n delete-min operations from the heap.
In this question, we will count the number of linkings that occurred, i.e., the number of times a tree was attached to another tree.
What is the number of linkings that occurred in the worst case of all insert operations together, and of all delete-min operations together?
a. $O(\log n)$ for insert and $O(\log n)$ for delete-min  
b. $O(n)$ for insert and $O(1)$ for delete-min  
c. $O(n)$ for insert and $O(n \log n)$ for delete-min  
d. $O(n)$ for insert and $O(n)$ for delete-min  
e. $O(n \log n)$ for insert and $O(n)$ for delete-min  
f. $O(n \log n)$ for insert and $O(n \log n)$ for delete-min  ",C,na,6,i,tested,,"הכניסו לערימה בינומית )לא עצלה( סדרה של n איברים בסדר כלשהו. לאחר מכן ביצעו n פעולות delete-min מן הערימה.
בשאלה זו נספור את מספר ה linking שהתבצעו, כלומר כמות הפעמים שעץ נתלה על עץ אחר.
מהו מספר ה linking שהתבצע ב worst case של כל פעולות ה insert יחד, ושל כל פעולות ה -delete min יחד?
א. (log n)O ל-insert ו (log n)O ל- delete-min
ב. (n)O ל-insert ו (1)O ל- delete-min
ג. (n)O ל-insert ו (n log n)O ל- delete-min
ד. (n)O ל-insert ו (n)O ל- delete-min
ה. (n log n)O ל-insert ו (n)O ל- delete-min
ו. (n log n)O ל-insert ו (n log n)O ל- delete-min",na,,,,
C,TRUE,2014,B,B,11,T3/ds14bb-official sol(vaad).pdf,TAU,5,"Given an array of integers \(A\), we are required to create an array \(B\) containing, for each element \(i\), the minimum in the range \(A[i], A[i+1], \ldots, A[i + \lfloor \sqrt{n} \rfloor]\).
What is the tightest upper bound for creating the array \(B\):

A. \(O(\sqrt{n} \log n)\)  
B. \(O\left(\frac{n}{\log n}\right)\)  
C. \(O(n \log n)\)  
D. \(O(n \log^2 n)\)  
E. \(O(n \sqrt{n})\)  
F. \(O(n^2)\)",C,na,6,"a,d",tested,,"נתון מערך של איברים שלמים \(A\). אנו נדרשים ליצור מערך \(B\) המכיל עבור כל איבר \(i\) את המינימום בטווח \(A[i], A[i+1], ..., A[i + ⌊√n⌋]\).
מהו החסם העליון החזק ביותר ליצירת המערך \(B\):

א. \(O(\sqrt{n} \log n)\)
ב. \(O\left(\frac{n}{\log n}\right)\)
ג. O(n log n)
ד. O(n log^2 n)
ה. O(n \sqrt{n})
ו. O(n^2)",na,,,,
C,TRUE,2014,B,B,12,T3/ds14bb-official sol(vaad).pdf,TAU,5,"Given an array of integers \(A\), we are required to create an array \(B\) which contains for each element \(i\) the minimum in the range \(A[i], A[i+1], \ldots, A[i + \lfloor\sqrt{n}\rfloor]\).
Given any indices \(n \le i < j \le 1\), what is the tightest upper bound (in the worst case) for finding the smallest element in the array located between indices \(i\) and \(j\)? We need to find the minimum value and its exact position in the array.
A. \(O(1)\)
B. \(O(\log n)\)
C. \(O(\sqrt{n})\)
D. \(O(n)\)
E. \(O(n \log n)\)
F. \(O(n \sqrt{n})\)",C,na,6,"a,d",tested,,"נתון מערך של איברים שלמים \(A\). אנו נדרשים ליצור מערך \(B\) המכיל עבור כל איבר \(i\) את המינימום בטווח \(A[i], A[i+1], ..., A[i + ⌊√n⌋]\).
נתונים אינדקסים כלשהם n ≤ i < j ≤ 1
מהו החסם העליון ההדוק ביותר (ב( case worst  למציאת האיבר הקטן ביותר במערך שנמצא בין אינדקס i ו j ? יש למצוא את הערך המינימלי וגם את מיקומו המדויק במערך.
א. O(1)
ב. O(log n)
ג. O(\sqrt{n})
ד. O(n)
ה. O(n log n)
ו. O(n \sqrt{n})",na,,,,
C,TRUE,2014,B,B,13,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,F,na,6,"a,n",untested,,"נתבונן במבנה union-find עם path compression ו - union by rank (כלומר, המבנה כפי שנלמד בכיתה). נרחיב את פעולת ה-path compression כך שפעולת \( Find(x) \) תכווץ את כל המסלולים של הצאצאים של x אל שורש הקבוצה, גם אם x הוא בעצמו השורש (בנוסף לכיווץ המסלולים של האבות הקדמונים, כמו במימוש הרגיל). לצורך כך, נשמור בעץ שמיצג את הקבוצה מצביע מכל צומת לרשימת הילדים שלו (השינוי לא פגע בזמן הריצה של פעולת ה-union כי הוספת צומת אחד לרשימת הבנים של השורש לוקחת זמן קבוע(
זמן הריצה של \( Find \) במקרה הגרוע הוא:
א. \( O(1) \)
ב. \( O(\alpha(n)) \)
ג. \( O(\log \log n) \)
ד. \( O(\log n) \)
ה. \( O(\log^2 n) \)
ו. \( O(n) \)",na,,,,
C,TRUE,2014,B,B,14,T3/ds14bb-official sol(vaad).pdf,TAU,5,na,F,na,6,"b,n",untested,,"נתבונן במבנה union-find עם path compression ו - union by rank (כלומר, המבנה כפי שנלמד בכיתה). נרחיב את פעולת ה-path compression כך שפעולת \( Find(x) \) תכווץ את כל המסלולים של הצאצאים של x אל שורש הקבוצה, גם אם x הוא בעצמו השורש (בנוסף לכיווץ המסלולים של האבות הקדמונים, כמו במימוש הרגיל). לצורך כך, נשמור בעץ שמיצג את הקבוצה מצביע מכל צומת לרשימת הילדים שלו (השינוי לא פגע בזמן הריצה של פעולת ה-union כי הוספת צומת אחד לרשימת הבנים של השורש לוקחת זמן קבוע(
זמן הריצה אמורטייזד של Find הוא:
א. \( O(1) \)
ב. \( O(\alpha(n)) \)
ג. \( O(\log \log n) \)
ד. \( O(\log n) \)
ה. \( O(\log^2 n) \)
ו. \( O(n) \)",na,,,,
C,TRUE,2014,B,B,15,T3/ds14bb-official sol(vaad).pdf,TAU,3,na,FALSE,na,2,"h,p",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן ערימה בינארית, ניתן לייצר עץ שחור אדום המכיל את אותם איברים בO(n) 
הוסף נימוק קצר. ",na,,,,עץ אדום שחור
C,TRUE,2014,B,B,16,T3/ds14bb-official sol(vaad).pdf,TAU,3,"\text{Is the following claim true or false? (Assume that the elements are distinct from each other.) Given two binary heaps, they can be melded in } O(n) \text{. Provide a brief justification.}",1,na,2,h,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן שתי ערימות בינאריות, ניתן למזג ביניהן  (meld) בO(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,17,T3/ds14bb-official sol(vaad).pdf,TAU,3,"Is the following statement true or false? (Assume that the elements are distinct from each other). Given a binary heap, it is possible to produce a sorted array containing the log n smallest elements in the heap in O(log n * log log n) time. Add a short explanation.",1,na,2,"h,d",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן ערימה בינארית, ניתן לייצר מערך ממוין המכיל את log n האיברים הקטנים בערימה ב O(log⁡n*log⁡log⁡n )
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,18,T3/ds14bb-official sol(vaad).pdf,TAU,3,\textit{Is the following statement true or false? (Assume that the elements are distinct.) A binary search tree can be reconstructed from an unordered list of its elements and a sorted list of the leaves in the tree. Provide a short explanation.},FALSE,na,2,e,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ חיפוש בינארי על פי רשימה לא ממוינת של איברי העץ ורשימה ממוינת של העלים בעץ.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,19,T3/ds14bb-official sol(vaad).pdf,TAU,3,na,1,na,2,e,untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ בינארי )לא בהכרח עץ חיפוש( באופן יחיד כאשר נתונה סריקת post order ועבור כל איבר מה גובהו בעץ, וידוע שאין איברים בעץ שיש להם רק בן אחד.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,20,T3/ds14bb-official sol(vaad).pdf,TAU,3,"\textit{Is the following claim true or false? (Assume that the elements are distinct from each other). In a Fibonacci heap, during a dec-key operation, it is possible that 0 deletions of elements occur. Add a brief explanation.}",1,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימת פיבונצ'י בפעולת dec-key יכול להיות שיתבצעו 0 תלישות של איברים.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,21,T3/ds14bb-official sol(vaad).pdf,TAU,3,"\text{Is the following statement true or false? (Assume the elements are distinct from each other.) Given 2 Fibonacci heaps, each with } n \text{ elements, they can be combined into one Fibonacci heap with } 2n \text{ elements in } O(\log n). \text{ Add a short justification.}",1,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בהינתן 2 ערימות פיבונצ'י של n איברים כל אחת ניתן לחבר אותן לערימת פיבונצ'י אחת של 2n איברים בO(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,22,T3/ds14bb-official sol(vaad).pdf,TAU,3,na,FALSE,na,2,h,untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינארית יש לכל צומת 0 או 2 ילדים.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,23,T3/ds14bb-official sol(vaad).pdf,TAU,3,"\text{Is the following claim true or false? }
\text{(Assume that the elements are distinct from one another). }
\text{In a lazy binomial heap, exactly n linkings can occur in one del-min operation (for every n). }
\text{Add a brief argument.}",FALSE,na,2,i,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינומית עצלה בפעולת del-min אחת יכולות להתבצע בדיוק n תליות (עבור כל n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,B,24,T3/ds14bb-official sol(vaad).pdf,TAU,3,"\textbf{Is the following claim true or false?} (Assume that the elements are distinct from one another). In a binary heap (with more than 10 elements), the largest value after the maximum can be a child of the root. \textbf{Provide a brief justification.}",FALSE,na,2,h,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בערימה בינארית (עם יותר מ10 איברים) הערך הגדול ביותר אחרי המקסימום יכול להיות בן של השורש.
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,1,T3/ds14bc-sol(vaad).pdf,TAU,5,"Given a data structure with \( n \) numbers and a parameter \( k \) (where \( k \) is not fixed, but part of the input). We want to find the \( k \)-th largest element and the \( (n-k) \)-th largest element.
What will be the best runtime for a binary search tree with a size field in the nodes (size = the number of nodes for which this node is the root)?
a. \( O(1) \)
b. \( O(\log n) \)
c. \( O(\min(\log n, k)) \)
d. \( O(k + \log n) \)
e. \( O(k \log n) \)
f. \( O(n) \)",B,na,6,"a,e",tested,,"נתון מבנה נתונים עם n מספרים וכן פרמטר k (k לא קבוע, אלא חלק מהקלט). רוצים למצוא את האיבר ה-k בגודלו ואת האיבר ה-(n-k) בגודלו.
מה יהיה זמן הריצה הטוב ביותר עבור עץ חיפוש בינארי עם שדה size בצמתים (size = מספר הצמתים שצומת זה שורש)?
א. (1)O
O(log n) .ב
O(min(log n, k)) .ג
O(k + log n) .ד
O (k log n) .ה
O(n) .ו",na,,,,
C,TRUE,2014,B,C,2,T3/ds14bc-sol(vaad).pdf,TAU,5,na,F,na,6,"a,f,h",untested,,"נתון מבנה נתונים עם n מספרים וכן פרמטר k (k לא קבוע, אלא חלק מהקלט). רוצים למצוא את האיבר ה-k בגודלו ואת האיבר ה-(n-k) בגודלו.
מה יהיה זמן הריצה הטוב ביותר עבור ערימה בינארית, המיוצגת על-ידי מערך?
א. (1)O
O(log n) .ב
O(min(log n, k)) .ג
O(k + log n) .ד
O (k log n) .ה
O(n) .ו","הכוונה היתה לעץ חיפוש מאוזן. מי שבחר (n(O וכתב בנימוק שזה בעץ לא מאוזן, קיבל גם ניקוד מלא",,,,
C,TRUE,2014,B,C,3,T3/ds14bc-sol(vaad).pdf,TAU,5,"
Given an array of size $n$, in which every value appears exactly twice, the most efficient algorithm for sorting the array in the comparison model operates in the worst-case time:
\begin{enumerate}
\item $\Omega(n \log n)$
\item $\Omega(n^3)$
\item $\Omega(n^3 \log n)$
\item $\Omega(n^3 \log^2 n)$
\item $\Omega(n^3 \log^3 n)$
\item None of the answers are correct
\end{enumerate}",C,na,6,"a,d,k",tested,,"נתון מערך בגודל n, שבו כל ערך מופיע פעמיים בדיוק. האלגוריתם היעיל ביותר למיון המערך במודל השוואות פועל במקרה הגרוע בזמן:
.Ω(n log n) .א
ב. Ω(n^3)
ג. Ω(n^3 log n)
ד. Ω(n^3 log^2 n)
ה. Ω(n^3 log^3 n)
ו. אף תשובה אינה נכונה",na,,,,
C,TRUE,2014,B,C,4,T3/ds14bc-sol(vaad).pdf,TAU,5,na,D,na,6,"a,d,k",untested,,"נתון מודל השוואות עם פעולת השוואה חדשה בין שני מספרים x ו-y. הפעולה מחזירה אחת מהתשובות הבאות:
x=y
x גדול מעשרה איברים )או יותר( שגדולים מ-y.
y גדול מעשרה איברים )או יותר( שגדולים מ-x.
x גדול מ-y אבל יש פחות מעשרה איברים שערכם בין x ל-y.
y גדול מ-x אבל יש פחות מעשרה איברים שערכם בין x ל-y.
חסם תחתון למיון מערך בגודל n במודל החדש הוא:
א. (1)Ω.
.Ω(log n) .ב
.Ω(n) .ג
.Ω(n log n) .ד
ה. Ω(n^2)
ו. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2014,B,C,5,T3/ds14bc-sol(vaad).pdf,TAU,5,na,D,na,6,c,untested,,"פתרו את נוסחת הנסיגה הבאה:
T(n) = 2T(n/2) + n log^2 (n)
T(n)  = ?
Θ(n) .א 
Θ (n log n) .ב 
Θ (n log^2 n) .ג
ד. Θ (n log^3 n)
Θ (n^2) .ה 
Θ (n^2 log n) .ו 
",na,,,,נוסחת נסיגה
C,TRUE,2014,B,C,6,T3/ds14bc-sol(vaad).pdf,TAU,5,na,E,na,6,o,untested,,"עבור המחרוזת BAOBABABBAO בנו suffix tree. מה מספר הצמתים עם 2 ילדים בדיוק?
א. 4
ב. 5
ג. 6
ד. 7
ה. 8
ו. אף תשובה אינה נכונה",na,,,,
C,TRUE,2014,B,C,7,T3/ds14bc-sol(vaad).pdf,TAU,5,"\textbf{Given a Hash table (with a Hash function chosen randomly from a universal set). In this table, collisions are resolved as follows:} \\
Every element mapped to a non-empty cell is stored in a shared red-black tree for the entire table. A search is carried out by checking the appropriate cell (using the Hash function), and if the cell is not empty and the desired element is not there, we search in the tree. \\
Let \( B \) be the size of the table, \( N \) the number of elements, and \( \alpha = \frac{N}{B} \).

\textbf{The expected time for an unsuccessful search is:}  
a. \( \Theta(1+\alpha) \) on average if \( B= \Theta(N) \). \\
b. \( \Theta(1) \) on average if \( N^2 = B \). \( \Theta(\log N) \) on average if \( 10N = B \). \\
c. \( \Theta(1) \) in the worst case if \( N^2=B \) (the worst case is over all sequences of \( N \) elements and function choices); \( \Theta(\log N) \) in the worst case if \( 10N=B \). \\
d. \( \Theta(\frac{\log(N-B)}{B}) \) \\
e. \( \Theta(N) \) in the worst case. \\
f. None of the answers are correct.",B,na,6,"a,g,p",tested,,"נתונה טבלת Hash (עם פונקציית Hash שנבחרת באופן אקראי מקבוצה אוניברסלית). בטבלה זו התנגשויות נפתרות באופן הבא:
כל איבר שממופה לתא שאינו ריק, נשמר בעץ אדום שחור משותף לכל הטבלה. חיפוש מתבצע על ידי בדיקת התא המתאים (באמצעות פונקציית ה-Hash), ואם התא אינו ריק, והאיבר הרצוי אינו נמצא שם – מחפשים בעץ.
יהא B גודל הטבלה, N – מספר האיברים ו- \( \alpha = \frac{N}{B}\).

זמן חיפוש כושל הוא:
א. Θ(1+\alpha) בתוחלת אם B= Θ(N).
ב. Θ(1) בתוחלת אם N^2 = B. Θ(log N) בתוחלת אם 10N = B.
ג. Θ(1) בworst case אם N^2=B (הworst case הוא על כל הסדרות של N איברים ובחירות הפונקציות); Θ(log N) בworst case אם 10N=B.
ד. Θ(\frac{\log(N-B)}{B})
ה. Θ(N) בworst case.
ו. אף תשובה אינה נכונה.",na,,,,עץ אדום שחור
C,TRUE,2014,B,C,8,T3/ds14bc-sol(vaad).pdf,TAU,5,"\[
\text{Given a hash table (with a hash function chosen randomly from a universal set). In this table, collisions are resolved as follows:}
\]
\[
\text{Every element mapped to a non-empty cell is stored in a red-black tree shared by the entire table. A search is performed by checking the appropriate cell (using the hash function), and if the cell is not empty and the desired element is not there, the search is performed in the tree.}
\]
\[
\text{Let } B \text{ be the size of the table, } N \text{ the number of elements, and } \alpha = \frac{N}{B}.
\]
\[
\text{The successful search time is bounded by:}
\]
\begin{enumerate}
    \item \( O(1) \)
    \item \( O(\log \log n) \)
    \item \( O(\log n) \)
    \item \( O(n) \)
    \item \( O(n \log n) \)
    \item \( O(n^2) \)
\end{enumerate}",C,na,6,"a,g,p",tested,,"נתונה טבלת Hash (עם פונקציית Hash שנבחרת באופן אקראי מקבוצה אוניברסלית). בטבלה זו התנגשויות נפתרות באופן הבא:
כל איבר שממופה לתא שאינו ריק, נשמר בעץ אדום שחור משותף לכל הטבלה. חיפוש מתבצע על ידי בדיקת התא המתאים (באמצעות פונקציית ה-Hash), ואם התא אינו ריק, והאיבר הרצוי אינו נמצא שם – מחפשים בעץ.
יהא B גודל הטבלה, N – מספר האיברים ו- \( \alpha = \frac{N}{B}\).
זמן חיפוש מוצלח חסום על-ידי:
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
O(n^2) .ו",na,,,,עץ אדום שחור
C,TRUE,2014,B,C,9,T3/ds14bc-sol(vaad).pdf,TAU,5,na,B,na,6,"d,m",untested,,"נתון מערך A בגודל n. המערך ""כמעט ממוין"" כלומר כל איבר נמצא במרחק לכל היותר log n
מקומות ממקומו במערך הממוין.
רוצים אלגוריתם יעיל ביותר (ב-W.C.) לחיפוש האיבר k בגודלו במערך A. ניתן לעשות זאת בזמן:
O(log log n) .א
O(log n) .ב
O(log^2) .ג
O(n) .ד
O(n log log n) .ה
O(n log n) .ו",na,,,,
C,TRUE,2014,B,C,10,T3/ds14bc-sol(vaad).pdf,TAU,5,"A given array $A$ of size $n$ is ""almost sorted,"" meaning that each element is at most $\log n$ positions away from its place in the sorted array.

We want the most efficient (in W.C.) algorithm to sort array $A$. This can be done in time:
\begin{enumerate}
    \item $O(\log n)$
    \item $O(n)$
    \item $O(n \log \log n)$
    \item $O(n \log n)$
    \item $O(n \log^2 n)$
    \item $O(n^2)$
\end{enumerate}",C,na,6,d,tested,,"נתון מערך A בגודל n. המערך ""כמעט ממוין"" כלומר כל איבר נמצא במרחק לכל היותר log n
מקומות ממקומו במערך הממוין.
רוצים אלגוריתם יעיל ביותר (ב-W.C.) למיון מערך A. ניתן לעשות זאת בזמן:
O(log n) .א
O(n) .ב
O(n log log n) .ג
O(n log n) .ד
O(n log^2 n) .ה
O(n^2) .ו",na,,,,
C,TRUE,2014,B,C,11,T3/ds14bc-sol(vaad).pdf,TAU,5,na,C,na,6,i,untested,,"נתונות שתי ערימות בינומיות (לא עצלות), 1H וH2. נסמן ב1R ו2R את מספר השורשים של 
1H ו2H בהתאמה. מאחדים את 1H ו2H באלגוריתם האיחוד של ערימה בינומית ומקבלים 
ערימה H. יהי R מספר שורשי H. רוצים לדעת את היחס בין 2R1+R ל-R.
.תמיד R=R1+R2 .א
.תמיד R ≠ R1+R2 .ב
.תמיד R ≤ R1+R2 .ג
.תמיד R ≥ R1+R2 .ד
ה. אי אפשר לדעת.
ו. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2014,B,C,12,T3/ds14bc-sol(vaad).pdf,TAU,5,"Two Fibonacci heaps, \( H_1 \) and \( H_2 \), are given. Let \( R_1 \) and \( R_2 \) denote the number of roots of \( H_1 \) and \( H_2 \) respectively. The heaps \( H_1 \) and \( H_2 \) are united using the union algorithm of a binomial heap to form a heap \( H \). Let \( R \) be the number of roots of \( H \). We want to know the relation between \( R_1 + R_2 \) and \( R \).

a. \( R = R_1 + R_2 \) always.

b. \( R \neq R_1 + R_2 \) always.

c. \( R \leq R_1 + R_2 \) always.

d. \( R \geq R_1 + R_2 \) always.

e. It is not possible to know.

f. None of the answers is correct.",A,na,6,i,tested,,"נתונות שתי ערימות פיבונצ'י, 1H וH2. נסמן ב1R ו2R את מספר השורשים של 
1H ו2H בהתאמה. מאחדים את 1H ו2H באלגוריתם האיחוד של ערימה בינומית ומקבלים 
ערימה H. יהי R מספר שורשי H. רוצים לדעת את היחס בין 2R1+R ל-R.
.תמיד R=R1+R2 .א
.תמיד R ≠ R1+R2 .ב
.תמיד R ≤ R1+R2 .ג
.תמיד R ≥ R1+R2 .ד
ה. אי אפשר לדעת.
ו. אף תשובה אינה נכונה.",na,,,,
C,TRUE,2014,B,C,13,T3/ds14bc-sol(vaad).pdf,TAU,5,na,D,na,6,d,untested,,"נתון מערך עם מספרים וצריך למצוא את תת-מערך רצוף כלשהו המכיל לפחות איבר אחד, שסכום המספרים בו שווה ל0- בדיוק.
נתון שכל המספרים הם 1 או -1. מה זמן הריצה הטוב ביותר לפתרון הבעיה?
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
O(n^2) .ו ","עוברים על המערך עד שמוצאים שני איברים עוקבים שונים זה מזה. אם קיימים סכומם 0, אם לא אז לא קיים כזה רצף.",,,,
C,TRUE,2014,B,C,14,T3/ds14bc-sol(vaad).pdf,TAU,5,"Given an array with numbers, the task is to find the longest contiguous subarray whose sum of elements is exactly equal to $0$. It is given that all the numbers are $1$ or $-1$. What is the best runtime for solving this problem?
\begin{enumerate}
\item $O(1)$
\item $O(\log \log n)$
\item $O(\log n)$
\item $O(n)$
\item $O(n \log n)$
\item $O(n^2)$
\end{enumerate}",D,"\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}

We record an array of partial sums from the first position to the last. The list can be sorted in $O(n)$ since all the sums are between $-n$ to $n$. We look for a pair in the sorted list whose partial sum is identical, and for which the sum between the two elements is exactly 0. We search for the pair whose distance between its elements is the greatest.

\end{document}",6,d,tested,,"נתון מערך עם מספרים וצריך למצוא את תת-מערך רצוף הארוך ביותר, שסכום המספרים בו שווה ל-0 בדיוק.
נתון שכל המספרים הם 1 או -1. מה זמן הריצה הטוב ביותר לפתרון הבעיה?
א. (1)O
O(log log n) .ב
O(log n) .ג
O(n) .ד
O(n log n) .ה
O(n^2) .ו ","רושמים מערך של סכומים חלקיים מהמיקום הראשון עד האחרון. ניתן למיין את הרשימה ב O(n) מאחר וכל הסכומים בין n- ל n. מחפשים זוג ברשימה הממוינת שהסכום החלקי שלו זהה, ועבורו הסכום בין שני האיברים הוא בדיוק 0. מחפשים את הזוג שהמרחק בין איבריו גדול ביותר.",,,,
C,TRUE,2014,B,C,15,T3/ds14bc-sol(vaad).pdf,TAU,3,na,FALSE,na,2,"d,k",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
נתון אלגוריתם שבהינתן איבר במערך מחזיר תשובה מה היה מיקומו במערך לו היה ממוין order)) בזמן קבוע. אזי ניתן למצוא באמצעות האלגוריתם חציון של מערך לא ממוין בO(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,16,T3/ds14bc-sol(vaad).pdf,TAU,3,"\textit{Is the following claim true or false? (Assume the elements are distinct from each other). Given an algorithm that, given an element in an array, returns the answer of what its position would have been in the array if it were sorted (order), in time $O(\log n)$. Then it is possible to sort an unsorted array using the algorithm in $O(n)$. Add a short justification.}",FALSE,na,2,"d,k",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
נתון אלגוריתם שבהינתן איבר במערך מחזיר תשובה מה היה מיקומו במערך לו היה ממוין order)) בזמן O(log n). אזי ניתן למיין באמצעות האלגוריתם מערך לא ממוין בO(n). 
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,17,T3/ds14bc-sol(vaad).pdf,TAU,3,na,1,na,2,"d,k",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
נתון מערך שבו עבור כל זוג איברים באינדקסים i ו j כאשרi+10=j  מתקיים שהאיבר הקטן מביניהם באינדקסi . אזי ניתן למיין את המערך בO(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,18,T3/ds14bc-sol(vaad).pdf,TAU,3,"\textbf{Is the following claim true or false?} 
(Assume that the elements are distinct from one another).
Given an array where for every pair of elements at indices \(i\) and \(j\) where \(i + \log n = j\), it holds that the smaller element is at index \(i\). Then the array can be sorted in \(O(n)\).
\textbf{Provide a short justification.}",FALSE,na,2,"d,k",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
נתון מערך שבו עבור כל זוג איברים באינדקסים i ו j כאשרi+log n=j  מתקיים שהאיבר הקטן מביניהם באינדקסi . אזי ניתן למיין את המערך בO(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,19,T3/ds14bc-sol(vaad).pdf,TAU,3,"\textbf{Is the following claim true or false?} (Assume the elements are distinct from each other). Given an array, it is known that after sorting the array, the difference between every two consecutive elements will be some constant (the value of the constant is unknown). Then the array can be sorted in \(O(n)\). Add a brief justification.",1,na,2,"d,k",tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
נתון מערך, וידוע שלאחר מיון המערך ההפרש בין כל שני איברים עוקבים יהיה קבוע כלשהו (ערך הקבוע אינו ידוע). אזי ניתן למיין את המערך בO(n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,20,T3/ds14bc-sol(vaad).pdf,TAU,3,na,FALSE,na,2,"a,n",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
במבנה נתונים union-find עם שיפור כיווץ מסלולים וללא שיפור rank-by-union, זמן פעולת find בworst case הוא O(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,21,T3/ds14bc-sol(vaad).pdf,TAU,3,na,1,na,2,"b,n",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
במבנה נתונים union-find ללא שיפור כיווץ מסלולים ועם שיפור rank-by-union, זמן amortized לפעולה הוא O(log n).
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,22,T3/ds14bc-sol(vaad).pdf,TAU,3,"\textit{Is the following claim true or false? (Assume the elements are distinct from one another). In a suffix tree, there are at most $n$ internal nodes, where $n$ is the length of the string. Add a short explanation.}",1,na,2,o,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
בעץ suffix tree יש לכל היותר n צמתים פנימיים, כש-n  אורך המחרוזת. 
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,23,T3/ds14bc-sol(vaad).pdf,TAU,3,\textit{Is the following statement true or false? (Assume that the elements are distinct from each other.) It is possible to reconstruct a binary search tree from an in-order traversal when the root element is known. Add a brief explanation.},FALSE,na,2,e,tested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן לשחזר עץ חיפוש בינארי מהדפסת in-order,  כשידוע איבר השורש. 
הוסף נימוק קצר. ",na,,,,
C,TRUE,2014,B,C,24,T3/ds14bc-sol(vaad).pdf,TAU,3,na,FALSE,na,2,"a,h,e",untested,,"האם הטענה הבאה נכונה או לא נכונה? 
(יש להניח שהאיברים שונים זה מזה). 
ניתן להפוך ערימה בינומית לעץ חיפוש בינארי בזמן O(n).
הוסף נימוק קצר. ",na,,,,
A,TRUE,2018,B,A,1-a,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נתונים 2 מספרים בתחום [0,1]. הפעולות היחידות שניתן לבצע על המספרים הם השוואות והעתקות. כל פעולה כזאת לוקחת זמן קבוע. תאר/י אלגוריתם יעיל ככל האפשר למיון המספרים. מה סיבוכיות האלגוריתם?",מאחר ומותר לעשות רק השוואות והעתקות החסם התחתון הוא O(nlogn). ולכן ניתן להשתמש באלגוריתם שראינו בכיתה למיין בזמן זה של המערך עם n איברים לדוגמה heapsort.,,,,
A,TRUE,2018,B,A,1-b,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,האם האלגוריתם שנתת בסעיף הקודם הוא אופטימלי? (תחת ההנחה שהפעולות היחידות השוואות והעתקות.) ,"מאחר והפעולות היחידות שניתן לעשות זה השוואות והעתקות, אנחנו נמצאים במגרש של מודל ההשוואות. יש n! סידורים אפשריים ולכן החסם התחתחון הוא גובה העץ שהוא log(n!) = O(nlogn).",,,,
A,TRUE,2018,B,A,1-c,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נתונים n מספרים בתחום [0,1]. נתון שהמרחק בין כל שני מספרים בקלט הוא לפחות 1/3. תאר/י אלגוריתם יעיל ככל האפשר למיון המספרים. מה סיבוכיות האלגוריתם? ניתן כאן להשתמש בפעולות שאינן השוואות או העתקות, כמו למשל חיבור, חיסור, כפל, חילוק, ועיגול למספר שלם.","ראשית נכפיל את כל המספרים בn^3 ונקבל n מספרים בתחום [0, n^3] שמרחקם לפחות 1. כעת נוכל לעגל את כולם (למשל כלפי מטה) והמרחק מבטיח שנקבל n מספרים שלמים שינועו בתחום  [0, n^3]. נעשה זאת במערך נפרד ואת כל הפסולת שעשינו על המערך החדש נעשה באותו סדר על הישן, ובכל נוכל למיין את המספרים הנתונים באופן חח""ע. כעת נוכל, בדומה למה שראינו בתרגול, להסתכל עליהם בבסיס n כך שכל מספר עכשיו הוא בתחום  [0, n] בעל 3 ספרות - ולהשתמש בradixsort שזמן הריצה שלו O(3(n+n)) = O(n) (כל שאר הפעולות בפרק עלי גם הן (O(n. ",,,,
A,TRUE,2018,B,A,1-d,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,האם האלגוריתם שנתת בסעיף הקודם הוא אופטימלי?,"כן, מאחר ונתונים n מספרים,, לא ניתן למיינם מבלי לפחות לעבור על כולם - שכאמור לוקח O(n).",,,,
A,TRUE,2018,B,A,1-e,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"הוכח או הפרך: בהינתן עץ WAVL ואיבר x שאינו בעץ, ניתן למצוא את מקום ההכנסה של x בזמן amortized של O(loglogn).","הפרכה: נעשה רדוקציה לבעיית המיון. נניח שניתן ונמיין מערך בפחות מ O(nlogn) שהראנו בכיתה שזה חסם תחתון. בהינתן מערך, נעבור על כל איבריו, ונמצא עבור כל אחד את מיקום ההכנסה בעץ ואז נכניס אותו. ידוע שסדרה של הכנסות כאשר ידוע מיקום ההכנסה ב WAVL הוא O(n) אמורטייזד לפעולה ולכן עבור n הכנסות נשלם O(nloglogn). לאחר שבנינו את העץ נעבור עליו ב in order walk ונפלוט את האיברים למערך באופן ממויין O(n). בסך הכל קיבלנו שסיבוכיות המיון היא O(n) + O(n) + O(nloglogn) = O(nloglogn), בסתירה לחסם התחתון שראינו בכיתה.",,,,
A,TRUE,2018,B,A,2-a,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נרצה לתחזק מבני נתונים למכירה פומבית. יש m מוצרים m-1,..,0 ויש n אנשים. לכל איש יש שם משלו שנכנס למילת מחשב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 
(init_auction(m - אתחל את מבנה הנתונים.(add_bid(person_name, product_id, price - מוסיף הצעה (bid) של אדם למוצר. (highest_bid_for_product(product_id - מחזיר את ההצעה הגבוהה ביותר שנתנה עד 
כה למוצר מסוים. ()highest_bid_overall - מחזיר את ההצעה הגבוהה ביותר עבור כל המוצרים. אם לא ניתנה עדיין הצעה למוצר, פעולת (highest_bid_for_product(product_id צריכה להגיד זאת. כל אדם יכול להגיש לכל היותר הצעה אחת לכל מוצר. תן/י מימוש דטרמיניסטי יעיל ככל האפשר לממשק שהוגדר. מהו זמן ה-worst-case הטוב ביותר הדרוש לכל פעולה? ",na,,,,
A,TRUE,2018,B,A,2-b,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נרצה לתחזק מבני נתונים למכירה פומבית. יש m מוצרים m-1,..,0 ויש n אנשים. לכל איש יש שם משלו שנכנס למילת מחשב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 
(init_auction(m - אתחל את מבנה הנתונים.(add_bid(person_name, product_id, price - מוסיף הצעה (bid) של אדם למוצר. (highest_bid_for_product(product_id - מחזיר את ההצעה הגבוהה ביותר שנתנה עד 
כה למוצר מסוים. ()highest_bid_overall - מחזיר את ההצעה הגבוהה ביותר עבור כל המוצרים. אם לא ניתנה עדיין הצעה למוצר, פעולת (highest_bid_for_product(product_id צריכה להגיד זאת. פעולת (retract_bid(bid – מבטל הצעה שניתנה (bid הוא עצם שנוצר ע""י פעולת add_bid.).  כל אדם יכול להגיש לכל היותר הצעה אחת לכל מוצר. תן/י מימוש דטרמיניסטי יעיל ככל האפשר לממשק שהוגדר. מהו זמן ה-worst-case הטוב ביותר הדרוש לכל פעולה? ",נשמור מערך בגודל m כאשר כל תא מצביא לעץ מאוזן (AVL). כמו כן נשמור עץ נוסף של ההצעות של כל המוצרים. בכל העצים נשמור מצביע למקסימום. Init - אתחול המערך. Add_bid\retract_bid - כאשר בכל הכנסה\מחיקה אנחנו מכניסים לעץ הגדול וגם לעץ המתאים למוצר. עדכון מצביע המקסימום גם הוא נבלע בlogn בכל עץ O(logn). וhighest_bid_for_product\highest_bid_overall - החזרת ערך המצביעים המתאימים  (1)O.,,,,
A,TRUE,2018,B,A,2-c,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נרצה לתחזק מבני נתונים למכירה פומבית. יש m מוצרים m-1,..,0 ויש n אנשים. לכל איש יש שם משלו שנכנס למילת מחשב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 
(init_auction(m - אתחל את מבנה הנתונים.(add_bid(person_name, product_id, price - מוסיף הצעה (bid) של אדם למוצר. (highest_bid_for_product(product_id - מחזיר את ההצעה הגבוהה ביותר שנתנה עד 
כה למוצר מסוים. ()highest_bid_overall - מחזיר את ההצעה הגבוהה ביותר עבור כל המוצרים. אם לא ניתנה עדיין הצעה למוצר, פעולת (highest_bid_for_product(product_id צריכה להגיד זאת. פעולת (retract_bid(bid – מבטל הצעה שניתנה (bid הוא עצם שנוצר ע""י פעולת add_bid.). פעולת ( increase_bid(bid, delta - מעלה הצעה בdelta כאשר delta > 0. כל אדם יכול להגיש לכל היותר הצעה אחת לכל מוצר. תן/י מימוש דטרמיניסטי יעיל ככל האפשר לממשק שהוגדר. מהו זמן הamortized הטוב ביותר הדרוש לכל פעולה? ","נשמור מערך בגודל m כאשר כל תא מצביע לערימת פיבונאצ'י מקסימום. Init - אתחול מערך בגודל m + נחזיק ערימת מקסימום כללית. Add_bid - גישה לתא המתאים במערך וinsert ב (1)O אמורטייזד ל2 הערימות.  Highest_bid_for_product\highest_bid_overall - החזרת הערכים ממצביעי המקסימום  (1)O אמורטייזד. increase_bid - ב (1)O אמורטייזד. retract_bid - בO(logn) אמורטייזד, כמו ביצוע delete_min. ",,,,
A,TRUE,2018,B,A,2-d,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נרצה לתחזק מבני נתונים למכירה פומבית. יש m מוצרים m-1,..,0 ויש n אנשים. לכל איש יש שם משלו שנכנס למילת מחשב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 
(init_auction(m - אתחל את מבנה הנתונים.(add_bid(person_name, product_id, price - מוסיף הצעה (bid) של אדם למוצר. (highest_bid_for_product(product_id - מחזיר את ההצעה הגבוהה ביותר שנתנה עד 
כה למוצר מסוים. ()highest_bid_overall - מחזיר את ההצעה הגבוהה ביותר עבור כל המוצרים. אם לא ניתנה עדיין הצעה למוצר, פעולת (highest_bid_for_product(product_id צריכה להגיד זאת. פעולת (retract_bid(bid – מבטל הצעה שניתנה (bid הוא עצם שנוצר ע""י פעולת add_bid.). פעולת ( increase_bid(bid, delta - מעלה הצעה בdelta כאשר delta > 0.פעולת (merge_products(product_idl, product_id2 – הפעולה מאחדת שני מוצרים. המזהה של המוצר המאוחד הוא product_id1. המוצר product_id2 מפסיק להתקיים. לכל אדם יכולה להיות יותר מהצעה אחת למוצר הממוזג. תן/י מימוש דטרמיניסטי יעיל ככל האפשר לממשק שהוגדר. מהו זמן הamortized הטוב ביותר הדרוש לכל פעולה? ","נשמור מערך בגודל m כאשר כל תא מצביע לערימת פיבונאצ'י מקסימום. Init - אתחול מערך בגודל m + נחזיק ערימת מקסימום כללית. Add_bid - גישה לתא המתאים במערך וinsert ב (1)O אמורטייזד ל2 הערימות.  Highest_bid_for_product\highest_bid_overall - החזרת הערכים ממצביעי המקסימום  (1)O אמורטייזד. increase_bid - ב (1)O אמורטייזד. retract_bid - בO(logn) אמורטייזד, כמו ביצוע delete_min. וmerge_products - נעשה בדומה לאיחוד של ערימות, נמזג את ערימה של מוצר 2 לערימה של מוצר 1, נעדכן את המקסימום במידת הצורך  (1)O.",,,,
A,TRUE,2018,B,A,2-e,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"נרצה לתחזק מבני נתונים למכירה פומבית. יש m מוצרים ויש n אנשים. m אינו ידוע מראש. המזהים של המוצרים אינם בהכרח המספרים מ0 ל m-1. לכל איש יש שם משלו שנכנס למילת מחשב. מבנה הנתונים צריך לתמוך בפעולות הבאות: 
()init_auction - אתחל את מבנה הנתונים. (add_bid(person_name, product_id, price - מוסיף הצעה (bid) של אדם למוצר. (highest_bid_for_product(product_id - מחזיר את ההצעה הגבוהה ביותר שנתנה עד 
כה למוצר מסוים. ()highest_bid_overall - מחזיר את ההצעה הגבוהה ביותר עבור כל המוצרים. אם לא ניתנה עדיין הצעה למוצר, פעולת (highest_bid_for_product(product_id צריכה להגיד זאת. פעולת (retract_bid(bid – מבטל הצעה שניתנה (bid הוא עצם שנוצר ע""י פעולת add_bid.). פעולת ( increase_bid(bid, delta - מעלה הצעה בdelta כאשר delta > 0.פעולת (merge_products(product_idl, product_id2 – הפעולה מאחדת שני מוצרים. המזהה של המוצר המאוחד הוא product_id1. המוצר product_id2 מפסיק להתקיים. לכל אדם יכולה להיות יותר מהצעה אחת למוצר הממוזג. תן/י מימוש הסתברותי יעיל ככל האפשר לממשק שהוגדר. מהו זמן הamortized הטוב ביותר הדרוש לכל פעולה? ","נשתמש בפונקציית hash ממשפחה אוניברסלית. ידוע שבשימוש בhash פעולת ההכנסה\חיפוש לוקחת (1)O בתוחלת. המפתח של כל תא בטבלה יהיה מזהה המוצר והערך יצביע לערימת פיבונאצ'י מקסימום. Init - אתחול טבלת hash + נחזיק ערימת מקסימום כללית. Add_bid - חיפוש בטבלה וinsert ב (1)O אמורטייזד ל2 הערימות.  Highest_bid_for_product\highest_bid_overall - חיפוש בטבלה והחזרת הערכים ממצביעי המקסימום  (1)O אמורטייזד. increase_bid - ב (1)O אמורטייזד. retract_bid - בO(logn) אמורטייזד, כמו ביצוע delete_min. וmerge_products - נעשה בדומה לאיחוד של ערימות, נמזג את ערימה של מוצר 2 לערימה של מוצר 1, נעדכן את המקסימום במידת הצורך  (1)O.",,,,
A,TRUE,2018,B,A,3-a,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבני נתונים לתחזוק רשימות שתומכים בפעולות הבאות: 
()L → MakeList - צור רשימה ריקה. (A → Insert(L, x,i - הכנס את האיבר x למקום ה-i-י ברשימה L. החזר ListNode שמכיל את האיבר החדש שנוצר. (האינדקס של האיברים במקומות i ואילך גדלים ב-1). (A ← Retrieve(L, i - החזר את ה-ListNode שמכיל את האיבר במקום ה-i-י ברשימה. (L3 - Concat(L1,L2 - שרשר את הרשימות L1 ו-L2 והחזר את הרשימה המשורשרת. הרשימות L1 ו-L2 מפסיקות להתקיים. (WhichList(A – החזר את הרשימה שבה נמצא כרגע ה-A ListNode. עליך לתאר מימוש שונים של מבנה הנתונים לפי הדרישות הבאות: (Retrieve(L, i - ב(1)O בworst-case. שאר הפעולות צריכות להיות מהירות ככל האפשר בworst-case. בכל המקרים n הוא אורך הרשימה, או סכום אורכי הרשימות שעליהן מתבצעת הפעולה. רשום/י את הזמנים שלוקחות הפעולות השונות במימושים שלך בטבלה.",na,,,,
A,TRUE,2018,B,A,3-b,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבני נתונים לתחזוק רשימות שתומכים בפעולות הבאות: 
()L → MakeList - צור רשימה ריקה. (A → Insert(L, x,i - הכנס את האיבר x למקום ה-i-י ברשימה L. החזר ListNode שמכיל את האיבר החדש שנוצר. (האינדקס של האיברים במקומות i ואילך גדלים ב-1). (A ← Retrieve(L, i - החזר את ה-ListNode שמכיל את האיבר במקום ה-i-י ברשימה. (L3 - Concat(L1,L2 - שרשר את הרשימות L1 ו-L2 והחזר את הרשימה המשורשרת. הרשימות L1 ו-L2 מפסיקות להתקיים. (WhichList(A – החזר את הרשימה שבה נמצא כרגע ה-A ListNode. עליך לתאר מימוש שונים של מבנה הנתונים לפי הדרישות הבאות: (Retrieve(L, i - ב (O(logn בworst-case. פעולת insert(L,x,i - ב(O(logn בworst-case.  שאר הפעולות צריכות להיות מהירות ככל האפשר בworst-case. בכל המקרים n הוא אורך הרשימה, או סכום אורכי הרשימות שעליהן מתבצעת הפעולה. רשום/י את הזמנים שלוקחות הפעולות השונות במימושים שלך בטבלה.",na,,,,
A,TRUE,2018,B,A,3-c,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבני נתונים לתחזוק רשימות שתומכים בפעולות הבאות: 
()L → MakeList - צור רשימה ריקה. (A → Insert(L, x,i - הכנס את האיבר x למקום ה-i-י ברשימה L. החזר ListNode שמכיל את האיבר החדש שנוצר. (האינדקס של האיברים במקומות i ואילך גדלים ב-1). (A ← Retrieve(L, i - החזר את ה-ListNode שמכיל את האיבר במקום ה-i-י ברשימה. (L3 - Concat(L1,L2 - שרשר את הרשימות L1 ו-L2 והחזר את הרשימה המשורשרת. הרשימות L1 ו-L2 מפסיקות להתקיים. (WhichList(A – החזר את הרשימה שבה נמצא כרגע ה-A ListNode. עליך לתאר מימוש שונים של מבנה הנתונים לפי הדרישות הבאות: (Concat(L1, L2 - ב (O(1 בworst-case. שאר הפעולות צריכות להיות מהירות ככל האפשר בworst-case. בכל המקרים n הוא אורך הרשימה, או סכום אורכי הרשימות שעליהן מתבצעת הפעולה. רשום/י את הזמנים שלוקחות הפעולות השונות במימושים שלך בטבלה.",na,,,,
A,TRUE,2018,B,A,3-d,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבני נתונים לתחזוק רשימות שתומכים בפעולות הבאות: 
()L → MakeList - צור רשימה ריקה. (A → Insert(L, x,i - הכנס את האיבר x למקום ה-i-י ברשימה L. החזר ListNode שמכיל את האיבר החדש שנוצר. (האינדקס של האיברים במקומות i ואילך גדלים ב-1). (A ← Retrieve(L, i - החזר את ה-ListNode שמכיל את האיבר במקום ה-i-י ברשימה. (L3 - Concat(L1,L2 - שרשר את הרשימות L1 ו-L2 והחזר את הרשימה המשורשרת. הרשימות L1 ו-L2 מפסיקות להתקיים. (WhichList(A – החזר את הרשימה שבה נמצא כרגע ה-A ListNode. עליך לתאר מימוש שונים של מבנה הנתונים לפי הדרישות הבאות: פעולת insert(L,x,i - ב((O(log(i + 2 באמורטייזד. שאר הפעולות צריכות להיות מהירות ככל האפשר באמורטייזד. בכל המקרים n הוא אורך הרשימה, או סכום אורכי הרשימות שעליהן מתבצעת הפעולה. רשום/י את הזמנים שלוקחות הפעולות השונות במימושים שלך בטבלה.",na,,,,
A,TRUE,2018,B,A,3-e,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"בשאלה זאת נעסוק במבני נתונים לתחזוק רשימות שתומכים בפעולות הבאות: 
()L → MakeList - צור רשימה ריקה. (A → Insert(L, x,i - הכנס את האיבר x למקום ה-i-י ברשימה L. החזר ListNode שמכיל את האיבר החדש שנוצר. (האינדקס של האיברים במקומות i ואילך גדלים ב-1). (A ← Retrieve(L, i - החזר את ה-ListNode שמכיל את האיבר במקום ה-i-י ברשימה. (L3 - Concat(L1,L2 - שרשר את הרשימות L1 ו-L2 והחזר את הרשימה המשורשרת. הרשימות L1 ו-L2 מפסיקות להתקיים. (WhichList(A – החזר את הרשימה שבה נמצא כרגע ה-A ListNode. עליך לתאר מימוש שונים של מבנה הנתונים לפי הדרישות הבאות: (Concat(L1, L2 - ב (O(logn באמורטייזד. פעולת whichList(A - ב(1)O באמורטייזד. שאר הפעולות צריכות להיות מהירות ככל האפשר בבאמורטייזד. בכל המקרים n הוא אורך הרשימה, או סכום אורכי הרשימות שעליהן מתבצעת הפעולה. רשום/י את הזמנים שלוקחות הפעולות השונות במימושים שלך בטבלה.",na,,,,
A,TRUE,2018,B,A,4-a,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ברצוננו לממש מבנה נתונים לתחזוק רשימות שתומך בפעולות הבאות:
1. MakeList() - צור רשימה ריקה S.
2. Retrieve(S, i) - החזר את האיבר ה- i ברשימה S (באינדקסים מתחילים מ- 0).
3. InsertLast(S, x) - הוסף את x לסוף הרשימה S.
4. DeleteLast(S) - מחק את האיבר האחרון מרשימה S (בהנחה שהרשימה לא ריקה).

ננתח מספר המעות למימוש של מבנה זה בעזרת מערך.

הפעולה MakeList() מקצה מערך התחלתי (באורך 1000). כאשר המערך מתמלא, נקצה מערך חדש עם 100 איברים יותר מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר יש 200 איברים לא בשימוש בסוף המערך, נקצה מערך חדש הקצר ב-100 מגודלו הנוכחי ונעביר את האיברים אליו.

א. מה הסיבוכיות amortized של הפעולות השונות תחת מימוש זה? הנח/י ש- n הוא מספר האיברים ברשימה.",na,,,,
A,FALSE,2018,B,A,4-b,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ברצוננו לממש מבנה נתונים לתחזוק רשימות שתומך בפעולות הבאות:
1. MakeList() - צור רשימה ריקה S.
2. Retrieve(S, i) - החזר את האיבר ה- i ברשימה S (באינדקסים מתחילים מ- 0).
3. InsertLast(S, x) - הוסף את x לסוף הרשימה S.
4. DeleteLast(S) - מחק את האיבר האחרון מרשימה S (בהנחה שהרשימה לא ריקה).

ננתח מספר המעות למימוש של מבנה זה בעזרת מערך.

הפעולה MakeList() מקצה מערך התחלתי (באורך 1000). כאשר המערך מתמלא, נקצה מערך חדש עם 100 איברים יותר מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר יש 200 איברים לא בשימוש בסוף המערך, נקצה מערך חדש הקצר ב-100 מגודלו הנוכחי ונעביר את האיברים אליו.

נניח עתה שכאשר המערך מתמלא, נקצה מערך חדש בגודל פי 3 מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר רק 1/9 מהאיברים במערך בשימוש, נקצה מערך חדש בגודל 1/3 מגודלו הנוכחי ונעביר את האיברים אליו.

ב. מה הסיבוכיות amortized של הפעולות השונות תחת מימוש זה? הנח/י ש- n הוא מספר האיברים ברשימה.",na,,,,
A,TRUE,2018,B,A,4-c,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ברצוננו לממש מבנה נתונים לתחזוק רשימות שתומך בפעולות הבאות:
1. MakeList() - צור רשימה ריקה S.
2. Retrieve(S, i) - החזר את האיבר ה- i ברשימה S (באינדקסים מתחילים מ- 0).
3. InsertLast(S, x) - הוסף את x לסוף הרשימה S.
4. DeleteLast(S) - מחק את האיבר האחרון מרשימה S (בהנחה שהרשימה לא ריקה).

ננתח מספר המעות למימוש של מבנה זה בעזרת מערך.

בסעיף א׳: הפעולה MakeList() מקצה מערך התחלתי (באורך 1000). כאשר המערך מתמלא, נקצה מערך חדש עם 100 איברים יותר מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר יש 200 איברים לא בשימוש בסוף המערך, נקצה מערך חדש הקצר ב-100 מגודלו הנוכחי ונעביר את האיברים אליו.

בסעיף ב׳: נניח עתה שכאשר המערך מתמלא, נקצה מערך חדש בגודל פי 3 מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר רק 1/9 מהאיברים במערך בשימוש, נקצה מערך חדש בגודל 1/3 מגודלו הנוכחי ונעביר את האיברים אליו.

נוסיף עתה למבנה הנתונים גם את הפעולה הבאה:
Delete(S, i) - מחק את האיבר במקום ה- i ב- S. (בהנחה שיש איבר כזה.)
האינדקסים של האיברים שאחריו מ- i + 1 ואילך קטנים ב- 1.
נסתכל על מימוש בו מחיקת איבר נעשית בצורה עצלה, כלומר, נסמן שהאיבר מחוק, אך לא נזיז את האיברים שאחריו בעקבות המחיקה. נתחזק בנוסף למערך רשימה מקושרת חד-כיוונית המכילה בצורה ממוינת את כל האינדקסים במערך שכרגע מחוקים (כלומר, האיבר שהיה שם נמחק). כאשר משנים את גודל המערך (מקטינים או מגדילים), אנחנו מעתיקים מחדש את המערך ואז נוכל באמת למחוק את האיברים שעד כה רק סומנו כמחוקים, ולהפוך את רשימת האינדקסים המחוקים לרשימה ריקה. 
הגדלת והקטנת המערך מתבצעת כמו שמתואר בסעיף ב׳.
לדוגמא, נניח שהתבצעה סדרת הפעולות הבאות:

S = MakeList()
Insert-Last(S, 15)
Insert-Last(S, 20)
Insert-Last(S, 25)
Insert-Last(S, 30)
Insert-Last(S, 35)
Delete(S, 2)
Delete(S, 0)
Retrieve(S, 0) — returns 20
Delete(S, 1)
Retrieve(S, 1) — returns 35

כך יראו המערך והרשימה המקושרת בסוף סדרת פעולות אלה:

Internal array: [NULL, 20, NULL, NULL, 35, …]
Deleted indices list: 0 => 2 => 3

שימו לב שאורך הרשימה הזה לכמות פעולות המחיקה שהיו מאז הפעם האחרונה שהגדלנו/הקטנו את גודל המערך. נסמן ערך זה ב-d.

ג. מה הסיבוכיות worst-case של פעולת Retrieve(S, i) תחת מימוש זה? (שימו לב שהפעולה צריכה להחזיר את האיבר ה-i-י הלא מחוק). ניתן להשתמש ב-d בכדי לציין את הסיבוכיות.",na,,,,
A,FALSE,2018,B,A,4-d,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ברצוננו לממש מבנה נתונים לתחזוק רשימות שתומך בפעולות הבאות:
1. MakeList() - צור רשימה ריקה S.
2. Retrieve(S, i) - החזר את האיבר ה- i ברשימה S (באינדקסים מתחילים מ- 0).
3. InsertLast(S, x) - הוסף את x לסוף הרשימה S.
4. DeleteLast(S) - מחק את האיבר האחרון מרשימה S (בהנחה שהרשימה לא ריקה).

ננתח מספר המעות למימוש של מבנה זה בעזרת מערך.

בסעיף א׳: הפעולה MakeList() מקצה מערך התחלתי (באורך 1000). כאשר המערך מתמלא, נקצה מערך חדש עם 100 איברים יותר מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר יש 200 איברים לא בשימוש בסוף המערך, נקצה מערך חדש הקצר ב-100 מגודלו הנוכחי ונעביר את האיברים אליו.

בסעיף ב׳: נניח עתה שכאשר המערך מתמלא, נקצה מערך חדש בגודל פי 3 מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר רק 1/9 מהאיברים במערך בשימוש, נקצה מערך חדש בגודל 1/3 מגודלו הנוכחי ונעביר את האיברים אליו.

בסעיף ג׳: נוסיף עתה למבנה הנתונים גם את הפעולה הבאה:
Delete(S, i) - מחק את האיבר במקום ה- i ב- S. (בהנחה שיש איבר כזה.)
האינדקסים של האיברים שאחריו מ- i + 1 ואילך קטנים ב- 1.
נסתכל על מימוש בו מחיקת איבר נעשית בצורה עצלה, כלומר, נסמן שהאיבר מחוק, אך לא נזיז את האיברים שאחריו בעקבות המחיקה. נתחזק בנוסף למערך רשימה מקושרת חד-כיוונית המכילה בצורה ממוינת את כל האינדקסים במערך שכרגע מחוקים (כלומר, האיבר שהיה שם נמחק). כאשר משנים את גודל המערך (מקטינים או מגדילים), אנחנו מעתיקים מחדש את המערך ואז נוכל באמת למחוק את האיברים שעד כה רק סומנו כמחוקים, ולהפוך את רשימת האינדקסים המחוקים לרשימה ריקה. 
הגדלת והקטנת המערך מתבצעת כמו שמתואר בסעיף ב׳.
לדוגמא, נניח שהתבצעה סדרת הפעולות הבאות:

S = MakeList()
Insert-Last(S, 15)
Insert-Last(S, 20)
Insert-Last(S, 25)
Insert-Last(S, 30)
Insert-Last(S, 35)
Delete(S, 2)
Delete(S, 0)
Retrieve(S, 0) — returns 20
Delete(S, 1)
Retrieve(S, 1) — returns 35

כך יראו המערך והרשימה המקושרת בסוף סדרת פעולות אלה:

Internal array: [NULL, 20, NULL, NULL, 35, …]
Deleted indices list: 0 => 2 => 3

שימו לב שאורך הרשימה הזה לכמות פעולות המחיקה שהיו מאז הפעם האחרונה שהגדלנו/הקטנו את גודל המערך. נסמן ערך זה ב-d.

בכדי לייעל את מבנה הנתונים, נבנה את המערך מחדש בכל פעם ש-d, מספר המחיקות מאז הבנייה האחרונה, מגיע ל-n^(1/3), כאשר n הוא מספר האיברים בבנייה האחרונה של המערך. 

ד. מהן סיבוכיות ה-W.C וה-amortized של הפעולות Retrieve(S,i) ו-Delete(S,i) במימוש זה?",na,,,,
A,FALSE,2018,B,A,4-e,T3/ds18ba_sol88(vaad).pdf,TAU,5,na,na,na,na,na,na,,"ברצוננו לממש מבנה נתונים לתחזוק רשימות שתומך בפעולות הבאות:
1. MakeList() - צור רשימה ריקה S.
2. Retrieve(S, i) - החזר את האיבר ה- i ברשימה S (באינדקסים מתחילים מ- 0).
3. InsertLast(S, x) - הוסף את x לסוף הרשימה S.
4. DeleteLast(S) - מחק את האיבר האחרון מרשימה S (בהנחה שהרשימה לא ריקה).

ננתח מספר המעות למימוש של מבנה זה בעזרת מערך.

בסעיף א׳: הפעולה MakeList() מקצה מערך התחלתי (באורך 1000). כאשר המערך מתמלא, נקצה מערך חדש עם 100 איברים יותר מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר יש 200 איברים לא בשימוש בסוף המערך, נקצה מערך חדש הקצר ב-100 מגודלו הנוכחי ונעביר את האיברים אליו.

בסעיף ב׳: נניח עתה שכאשר המערך מתמלא, נקצה מערך חדש בגודל פי 3 מגודלו הנוכחי ונעתיק את האיברים אליו. בנוסף, כאשר רק 1/9 מהאיברים במערך בשימוש, נקצה מערך חדש בגודל 1/3 מגודלו הנוכחי ונעביר את האיברים אליו.

בסעיף ג׳: נוסיף עתה למבנה הנתונים גם את הפעולה הבאה:
Delete(S, i) - מחק את האיבר במקום ה- i ב- S. (בהנחה שיש איבר כזה.)
האינדקסים של האיברים שאחריו מ- i + 1 ואילך קטנים ב- 1.
נסתכל על מימוש בו מחיקת איבר נעשית בצורה עצלה, כלומר, נסמן שהאיבר מחוק, אך לא נזיז את האיברים שאחריו בעקבות המחיקה. נתחזק בנוסף למערך רשימה מקושרת חד-כיוונית המכילה בצורה ממוינת את כל האינדקסים במערך שכרגע מחוקים (כלומר, האיבר שהיה שם נמחק). כאשר משנים את גודל המערך (מקטינים או מגדילים), אנחנו מעתיקים מחדש את המערך ואז נוכל באמת למחוק את האיברים שעד כה רק סומנו כמחוקים, ולהפוך את רשימת האינדקסים המחוקים לרשימה ריקה. 
הגדלת והקטנת המערך מתבצעת כמו שמתואר בסעיף ב׳.
לדוגמא, נניח שהתבצעה סדרת הפעולות הבאות:

S = MakeList()
Insert-Last(S, 15)
Insert-Last(S, 20)
Insert-Last(S, 25)
Insert-Last(S, 30)
Insert-Last(S, 35)
Delete(S, 2)
Delete(S, 0)
Retrieve(S, 0) — returns 20
Delete(S, 1)
Retrieve(S, 1) — returns 35

כך יראו המערך והרשימה המקושרת בסוף סדרת פעולות אלה:

Internal array: [NULL, 20, NULL, NULL, 35, …]
Deleted indices list: 0 => 2 => 3

שימו לב שאורך הרשימה הזה לכמות פעולות המחיקה שהיו מאז הפעם האחרונה שהגדלנו/הקטנו את גודל המערך. נסמן ערך זה ב-d.

בסעיף ד׳: בכדי לייעל את מבנה הנתונים, נבנה את המערך מחדש בכל פעם ש-d, מספר המחיקות מאז הבנייה האחרונה, מגיע ל-n^(1/3), כאשר n הוא מספר האיברים בבנייה האחרונה של המערך. 

ה. נרצה לשפר את סיבוכיות הפעולות Retrieve(S,i) ו-Delete(S,i) במימוש העצל שהוצע. הציעו מבנה נתונים שיחליף את הרשימה המקושרת שבה נשמרים האינדקסים המחוקים שישפר את הסיבוכיות של פעולות אלה כמה שאפשר.",na,,,,
B,TRUE,2018,A,B,1-a,T3/ds18AB-Sol.pdf,TAU,3,"\textit{Given a series of n elements, what is the time complexity for finding the k smallest elements in the series (for k < n).}",na,"\textbf{Time complexity:} \(O(n)\) \\
\textbf{Brief explanation:} Using a selection algorithm we saw in class and then partition.",na,m,tested,,"בהינתן סדרה של n איברים, מה סיבוכיות הזמן למציאת k האיברים הקטנים בגודלם בסדרה (עבור k < n). ","סיבוכיות זמן: (n(O
הסבר קצר: בעזרת אלגוריתם selection שראינו בכיתה ואז partition.",,,,
C,TRUE,2018,A,B,1-b,T3/ds18AB-Sol.pdf,TAU,2,na,FALSE,na,2,h,untested,,"ערימת מינימום מרושלת היא מבנה נתונים הדומה לערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הK איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר
שהחזירה כמינימום המקורב. הפעולות בהן תומך מבנה הנותנים ה (ADT): 
•  𝐼𝑛𝑠𝑒𝑟𝑡(𝑥) - הכנסה של איבר חדש עם מפתח .x
•  𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - החזרת מינימום מקורב (איבר מבין הk איברים הכי קטנים.)
•  𝐷𝑒𝑙𝑒𝑡𝑒𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - מחיקת המינימום המקורב (מחיקת אותו איבר שאם נעשה 𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛 נקבלו).
עבור 𝑘=2 )נניח שיש בערימה מעל שני איברים): יוסקה מימש ערימה מרושלת בצורה הבאה: המימוש מחזיר את המינימום האמיתי מבין כל האיברים
שנמצאים בערימה למעט שני האיברים האחרונים שהוכנסו (הערימה מתעלמת מ 2 האיברים האחרונים שהוכנסו). לדוגמה, נניח הוכנסו לערימה האיברים בסדר הבא (משמאל לימין): 2,7,9,0. הערימה המרושלת שיוסקה מימש תחזיר 2 כי זה המינימום מבין 2,7 (לא מתייחסת ל9,0 כיוון שהם ה 2 האחרונים).
האם מבנה הנתונים של יוסקה עונה על הדרישות של ערימת מינימום מרושלת חוקית (או האם קיימת סדרה של הכנסות/מחיקות בה הערימה אינה עונה על דרישות ערימה מרושלת)?",לא. הסבר: שני האיברים האחרונים יכולים להיות הכי קטנים מבין כל מי שבערימה לכן מבנה הנתונים יהיה חייב להחזיר אחד מהם על מנת לשמור על חוקי הערימה המרושלת.,,,,
C,TRUE,2018,A,B,1-c,T3/ds18AB-Sol.pdf,TAU,3,na,1,na,2,h,untested,,"ערימת מינימום מרושלת היא מבנה נתונים הדומה לערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הK איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר
שהחזירה כמינימום המקורב. הפעולות בהן תומך מבנה הנותנים ה (ADT): 
•  𝐼𝑛𝑠𝑒𝑟𝑡(𝑥) - הכנסה של איבר חדש עם מפתח .x
•  𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - החזרת מינימום מקורב (איבר מבין הk איברים הכי קטנים.)
•  𝐷𝑒𝑙𝑒𝑡𝑒𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - מחיקת המינימום המקורב (מחיקת אותו איבר שאם נעשה 𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛 נקבלו).
עבור k=100 (נניח שיש בערימה מעל 100 איברים) יוסקה מימש רשימה מרושלת בצורה הבאה: המימוש של יוסקה מחזיר את האיבר ה 20 הקטן ביותר (יש 19 איברים קטנים ממנו) מבין כל האיברים שנמצאים בערימה למעט 50 האיברים האחרונים שהוכנסו לערימה. זאת אומרת מבנה הנתונים מסתכל על קבוצת כל האיברים שיש בערימה למעט ה 50 איברים שהוכנסו בסוף, ומבין הקבוצה הזאת מחזיר את האיבר ה 20 בגודלו.
האם מבנה הנתונים של יוסקה עונה על הדרישות של ערימת מינימום מרושלת חוקית (או האם קיימת סדרה של הכנסות/מחיקות בה הערימה אינה עונה על דרישות ערימה מרושלת)?",כן. הסבר: נשים לב שהאיבר שיוסקה מחזיר הוא בין ה 70 הכי קטנים שנמצאים במבנה הנתונים ולכן מבנה הנתונים תקין.,,,,
C,TRUE,2018,A,B,1-d,T3/ds18AB-Sol.pdf,TAU,2,"A sloppy minimum heap is a data structure similar to a heap, which instead of returning the minimum, returns one of the k smallest elements in the heap. Additionally, in the delete operation, it deletes the same element that it returned as the approximate minimum. The operations supported by the data structure (ADT) are:
\begin{itemize}
    \item \texttt{Insert(x)} - insertion of a new element with key \(x\).
    \item \texttt{FindApproxMin()} - return an approximate minimum (an element among the k smallest elements).
    \item \texttt{DeleteApproxMin()} - deletion of the approximate minimum (deletion of the same element that if we performed \texttt{FindApproxMin()} we would receive).
\end{itemize}
For \(k=1\) can a sloppy heap be implemented so that all operations in the ADT take amortized time \(O(1)\)?",FALSE,"\noindent No. Explanation: No, because then we could reach a contradiction to the lower bound of sorting.",2,"b,h",tested,,"ערימת מינימום מרושלת היא מבנה נתונים הדומה לערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הK איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר
שהחזירה כמינימום המקורב. הפעולות בהן תומך מבנה הנותנים ה (ADT): 
•  𝐼𝑛𝑠𝑒𝑟𝑡(𝑥) - הכנסה של איבר חדש עם מפתח .x
•  𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - החזרת מינימום מקורב (איבר מבין הk איברים הכי קטנים.)
•  𝐷𝑒𝑙𝑒𝑡𝑒𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - מחיקת המינימום המקורב (מחיקת אותו איבר שאם נעשה 𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛 נקבלו).
עבור 𝑘=1 האם ניתן לממש ערימה מרושלת כך שכל הפעולות ב ADT לוקחות זמן אמורטייזד(1)O?",לא. הסבר: לא כי אז היינו יכולים להגיע לסתירה לחסם התחתון של מיון.,,,,
C,TRUE,2018,A,B,1-e,T3/ds18AB-Sol.pdf,TAU,5,"A sloppy minimum heap is a data structure similar to a heap, where instead of returning the minimum element, it returns one of the K smallest elements in the heap. Additionally, in the delete operation, it deletes the element that was returned as the approximate minimum. The operations supported by the ADT are:
• \( \text{Insert}(x) \) - insertion of a new element with key \( x \).
• \( \text{FindApproxMin}() \) - return an approximate minimum (an element among the k smallest elements).
• \( \text{DeleteApproxMin}() \) - delete the approximate minimum (delete the same element that would be obtained by doing \( \text{FindApproxMin} \)).

For \( k=n/100 \), is it possible to implement the sloppy heap such that all operations in the ADT take amortized \( O(1) \) time?",1,"Yes. Explanation: Find the n/200 smallest elements – denote this set by S.
During the next n/200 operations, return an element that hasn't been removed from set S (note that there must necessarily be such an element). After n/200, rebuild (find the set S again according to the elements currently in the data structure). Note that the element returned by the data structure is always among the n/100 smallest.",2,"b,h",tested,,"ערימת מינימום מרושלת היא מבנה נתונים הדומה לערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הK איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר
שהחזירה כמינימום המקורב. הפעולות בהן תומך מבנה הנותנים ה (ADT): 
•  𝐼𝑛𝑠𝑒𝑟𝑡(𝑥) - הכנסה של איבר חדש עם מפתח .x
•  𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - החזרת מינימום מקורב (איבר מבין הk איברים הכי קטנים.)
•  𝐷𝑒𝑙𝑒𝑡𝑒𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛() - מחיקת המינימום המקורב (מחיקת אותו איבר שאם נעשה 𝐹𝑖𝑛𝑑𝐴𝑝𝑝𝑟𝑜𝑥𝑀𝑖𝑛 נקבלו).
עבור k=n/100 , האם ניתן לממש ערימה מרושלת כך שכל הפעולות ב ADT לוקחות זמן אמורטייזד (1)O?","כן. הסבר: נמצא את ה n/200 איברים הכי קטנים – נסמן קבוצה זאת ב S .
במשך ה n/200 פעולות הבאות נחזיר איבר שלא נמחק מהקבוצה S (נשים לב שהבכרח קיים איבר כזה). אחריי n/200 נבנה מחדש (נמצא שוב את הקבוצה S לפי האיברים שכרגע נמצאים במבנה הנתונים). נשים לב שהאיבר שמבנה הנתונים מחזיר הוא תמיד בין ה n/100 הכי קטנים.",,,,
B,TRUE,2018,A,B,2-a,T3/ds18AB-Sol.pdf,TAU,3,"\begin{enumerate}
    \item Given a valid binary min-heap with $n$ elements, at which levels in the tree can the second smallest element be located?
    \item What is the minimum number of elements you would need to read in order to guarantee finding the second smallest element?
    (For the purpose of numbering, the level of the root is 0)
\end{enumerate}",na,"\textit{Levels: At level 1. \\
Minimum number of places: 2, the minimum element can only be at level 1 and at level 1 there are two elements.}",na,h,tested,,"בהינתן ערימת מינימום בינארית חוקית בת n איברים, באילו רמות בעץ יכול להיות ממוקם האיבר השני הקטן ביותר?
מה מספר האיברים המינימלי שתצטרכו לקרוא כדי להבטיח את מציאת האיבר השני הקטן ביותר?
(לצורך המספור, הרמה של השורש היא 0 )","רמות: ברמה 1 .
מספר מינימלי של מקומות: 2, האיבר המינימלי יכול להיות רק ברמה 1 וברמה 1 יש שני איברים.",,,,
B,TRUE,2018,A,B,2-b,T3/ds18AB-Sol.pdf,TAU,2,"Given a valid binary minimum heap of n elements, on which levels of the tree can the third smallest element be placed?",na,\text{Levels: Level 1 or 2.},na,h,tested,,"בהינתן ערימת מינימום בינארית חוקית בת n איברים. באילו רמות בעץ יכול להיות ממוקם האיבר
השלישי בקטן ביותר?",רמות: ברמה 1 או 2 .,,,,
C,TRUE,2018,A,B,2-c,T3/ds18AB-Sol.pdf,TAU,5,na,b,na,5,"a,h",untested,,"נתונה ערימת מינימום 𝐻 עם n איברים. הפרוצדורה ⁡𝑚𝑖𝑛(𝐻,𝑘) מדפיסה את 𝑘 האיברים הקטנים ביותר לפי הסדר, מן הקטן לגדול. בסיום הפרוצדורה, 𝐻 היא ערימת מינימום תקינה הכוללת את 𝑛 האיברים המקוריים.
מה הזמן הטוב ביותר בו ניתן לממש את הפרוצדורה:
א. 𝑂(𝑘logn)⁡
ב. 𝑂(𝑘logk)⁡⁡
ג. 𝑂(𝑘)
ד. 𝑂(𝑘+𝑙𝑜𝑔𝑛)
ה. 2 בחזקת K","תשובה ב. הסבר: נבנה ערימת עזר אליה נכניס O(k) איברים. בהתחלה מכניסים לערימת העזר את המינימום (אותו ניתן למצוא בזמן קבוע ע""י גישה ישירה לשורש). במשך k צעדים שולפים את המינימום מערימת העזר מחזירים אותו כאחד מה k הכי קטנים ומכניסים את שני ילדיו בערימה הראשונה לערימת המינימום (לוקח זמן קבוע).",,,,
C,TRUE,2018,A,B,3,T3/ds18AB-Sol.pdf,TAU,7,"Given an array of size \( n \) of elements \((\text{key}, \text{value})\) where the number of distinct keys in the array is \( k \) (i.e., if we convert the keys in the array into a set, the set will be of size \( k \)). We want to sort the array in the comparison model so that the sorting will be stable.
Reminder: A sort is called stable if it maintains the order of elements with the same key after sorting.
Note: Without addressing stability in the explanation of the solution, only partial credit will be given.
a. When \( k = \sqrt{n} / \log n \), the array can be stably sorted in time \( O(\sqrt{n} \log n) \) using a balanced search tree.
b. When \( k = \log n \), the array can be stably sorted in time \( O(n \log \log \log n) \) using a balanced search tree.
c. When \( k = n / \log n \), the array can be stably sorted with complexity \( O(n) \) on average using a hash table.
d. When \( k = n \), the array can be stably sorted with complexity \( O(n \log \log n) \) on average using a hash table.",c,"\textbf{Solution:} c. \textbf{Explanation:} Initialize a hash table $A$ of size at least $k$ (with the goal that for each key, it will hold a pointer to a linked list of the elements in the array with the same key, in the order they appear in the array). Additionally, initialize an array $B$ of size $k$. Traverse the original array in order, and for each element, search $A$ by $key$. If it exists, append the element to the end of the linked list that the element points to. If it does not exist, add the key, initialize a linked list for that key, and insert the element there. Additionally, during traversal, if when searching for the key it is not found, add the key to array $B$. Sort the array $B$ in time $O((n\log n) \cdot \log(n\log n)) = O(n)$. Traverse $B$ in order, search for the corresponding linked list in the hash table, and append the linked list elements in order to the original array (or to a new output array).",4,"d,k",tested,,"נתון מערך בגודל 𝑛 של איברים (𝑘𝑒𝑦,𝑣𝑎𝑙𝑢𝑒) כאשר מספר המפתחות השונים במערך הוא 𝑘 )כלומר, אם נמיר את המפתחות במערך לקבוצה, הקבוצה תהיה בגודל 𝑘(. נרצה למיין את המערך במודל ההשוואות, כך שהמיון יהיה יציב.
תזכורת: מיון נקרא מיון יציב אם הוא שומר על הסדר של איברים עם אותו המפתח גם לאחר המיון.
שימו לב: ללא התייחסות ליציבות בהסבר הפתרון, יינתן ניקוד חלקי בלבד.
א. כאשר 𝑘=√𝑛/log𝑛 ניתן למיין יציב את המערך בזמן O(√𝑛log𝑛) בעזרת עץ חיפוש מאוזן.
ב. כאשר 𝑘=log𝑛 ניתן למיין יציב את המערך בזמן (O(𝑛logloglog𝑛 בעזרת עץ חיפוש מאוזן.
ג. כאשר 𝑘=𝑛/log𝑛 , ניתן למיין יציב את המערך בסיבוכיות (O(𝑛 בתוחלת בעזרת טבלת האש.
ד. כאשר 𝑘=𝑛 , ניתן למיין יציב את המערך בסיבוכיות O(𝑛loglog𝑛) בתוחלת בעזרת טבלת האש.","פתרון: ג. הסבר: נאתחל טבלת האש A בגודל לפחות 𝑘 (במטרה שעבור כל מפתח יחזיק מצביע לרשימה מקושרת של האיברים במערך עם אותו המפתח, לפי סדר הופעתם במערך). בנוסף נאתחל מערך B בגודל 𝑘 .
נעבור על המערך המקורי לפי הסדר, ועבור כל איבר, נחפש ב A לפי 𝑘𝑒𝑦 . אם הוא קיים, נכניס את האיבר לסוף הרשימה המקושרת שהאיבר מצביע אליו. אם הוא לא קיים, נוסיף את המפתח, ונאתחל עבור אותו המפתח רשימה מקושרת ונכניס את האיבר לשם. בנוסף בזמן המעבר, אם כאשר אנחנו מחפשים אנחנו לא מוצאים את המפתח, נוסיף את המפתח למערך B . נמיין את המערך B , בזמן 𝑂((𝑛\log𝑛)*log(𝑛\log𝑛))=𝑂(𝑛) . נעבור על B לפי הסדר, נחפש את
הרשימה המקושרת המתאימה למפתח בטבלת ההאש, ונוסיף את איברי הרשימה המקושרת לפי הסדר למערך המקורי (או למערך פלט חדש).",,,,
C,TRUE,2018,A,B,4-a,T3/ds18AB-Sol.pdf,TAU,4,"\begin{quote}
After looking at the hash table using the chaining method, we thought it would be a good idea to change our choice of data structure (from a linked list to another data structure) to achieve better asymptotic complexity for insertion, search, and deletion from the hash table, even in the worst case (for any load factor), and on average (for load factor > 1). We denote load factor = \(\alpha\). Which data structure should we choose?

A. Binary heap. \\
B. Perfect hash table. \\
C. Array-based list that doubles in size. \\
D. Balanced search tree, such as AVL.
\end{quote}",d,"\textbf{d. Explanation:} We want to choose a balanced tree that will give us \(O(\log \alpha)\) expected per operation, and \(O(\log n)\) in the worst case.",4,"d,f,g,h",tested,,"לאחר שהסתכלנו על טבלת האש בשיטת Chaining , חשבנו שכדאי לנו להחליף את בחירת מבנה הנתונים (מרשימה מקושרת, למבנה נתונים אחר) כדי להשיג סיבוכיות אסימפטוטית טובה יותר בהכנסה, חיפוש ומחיקה מטבלת ההאש, גם במקרה הגרוע ביותר (לכל 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟 (, וגם בתוחלת (עבור 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟>1 ). נסמן 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟=𝛼.  איזה מבנה נתונים כדאי לנו לבחור?
א. ערימה בינארית.
ב. טבלת Perfect Hash .
ג. רשימה במימוש מערך המכפיל את עצמו.
ד. עץ חיפוש מאוזן, לדוגמה AVL","ד. הסבר: נרצה לבחור עץ מאוזן, שייתן לנו 𝑂(log𝛼) בתוחלת לפעולה, ו( 𝑂(log𝑛 ב wc.",,,,
C,TRUE,2018,A,B,4-b,T3/ds18AB-Sol.pdf,TAU,2,na,b,na,4,"a,d,f,g,h",untested,,"לאחר שהסתכלנו על טבלת האש בשיטת Chaining , חשבנו שכדאי לנו להחליף את בחירת מבנה הנתונים (מרשימה מקושרת, למבנה נתונים אחר) כדי להשיג סיבוכיות אסימפטוטית טובה יותר בהכנסה, חיפוש ומחיקה מטבלת ההאש, גם במקרה הגרוע ביותר (לכל 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟 (, וגם בתוחלת (עבור 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟>1 ). נסמן 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟=𝛼. מה הסיבוכיות במקרה הגרוע ביותר של הכנסה/חיפוש/הוצאה כתלות ב 𝛼 ובמספר האיברים במבנה הנתונים )לא בתוחלת). 
א. ( 𝑂(nlog𝛼
ב. (𝑂(log𝑛
ג. 𝑂(𝛼𝑛)
ד. 𝑂(𝛼log𝑛)","ב. הסבר: במקרה הגרוע ביותר כל האיברים ישבו באותו התא, והסיבוכיות תהיה log מספר האיברים הכולל.",,,,
C,TRUE,2018,A,B,4-c,T3/ds18AB-Sol.pdf,TAU,4,"After looking at the hash table using the Chaining method, we thought it would be advisable to change our data structure choice (from a linked list to another data structure) in order to achieve better asymptotic complexity for insertion, search, and deletion from the hash table, even in the worst case (for any load factor), and also on average (for a load factor > 1). Let us denote load factor = \(\alpha\). What is the average complexity of insertion/search/deletion, depending on \(\alpha = \text{load factor}\)? (The tightest answer.)

A. \(O(\log \log \alpha)\)
B. \(O(\alpha \log \alpha)\)
C. \(O(\alpha)\)
D. \(O(\log \alpha)\)",d,"\textbf{D. Explanation}: For a balanced tree, the average complexity of an operation will be the expectation of (log of the number of elements in the cell). From the reminder, we obtain that the above expression is less than or equal to the log of (the expected number of elements in the cell). As is known, the expected number of elements in the cell is \(\alpha\), and therefore we obtain that the average complexity is \(\log \alpha\). The expectation is over the hash functions from the universal family.",4,"a,d,f,g,h",tested,,"לאחר שהסתכלנו על טבלת האש בשיטת Chaining , חשבנו שכדאי לנו להחליף את בחירת מבנה הנתונים (מרשימה מקושרת, למבנה נתונים אחר) כדי להשיג סיבוכיות אסימפטוטית טובה יותר בהכנסה, חיפוש ומחיקה מטבלת ההאש, גם במקרה הגרוע ביותר (לכל 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟 (, וגם בתוחלת (עבור 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟>1 ). נסמן 𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟=𝛼. מה הסיבוכיות בתוחלת של הכנסה/חיפוש/הוצאה, כתלות ב 𝛼=𝑙𝑜𝑎𝑑𝑓𝑎𝑐𝑡𝑜𝑟 ? )התשובה ההדוקה ביותר).
א. ( 𝑂(loglog𝛼
ב. (𝑂(𝛼log𝛼
ג. 𝑂(𝛼)
ד. 𝑂(log𝛼)","ד. הסבר: עבור עץ מאוזן, הסיבוכיות בתוחלת של פעולה תהיה תוחלת של ( log מספר האיברים בתא). מהתזכורת נקבל שהביטוי הנ""ל קטן או שווה ל- log של (תוחלת מספר האיברים בתא). כידוע, תוחלת מספר האיברים בתא הוא 𝛼 , ולכן נקבל שהסיבוכיות בתוחלת היא log𝛼⁡ . התוחלת היא על פוקנציות ההאש מהמשפחה האוניברסלית.",,,,
C,TRUE,2018,A,B,5,T3/ds18AB-Sol.pdf,TAU,9,"\begin{quote}
In class, we learned about a deterministic \textit{select} that performed a \textit{partition} using a \textit{pivot} chosen by the median-of-medians algorithm. Assume that instead of the aforementioned \textit{pivot}, you received a new algorithm called \textit{GoodPivot} that takes an array containing \( n \) keys and returns the value of the \( 0.05n \)-th smallest element. For example, on an array of size 1000, it will return the value of the 50th smallest key. \textit{GoodPivot} does not call \textit{select} (unlike the median-of-medians algorithm). Assume the running time of \textit{GoodPivot} is bounded by \( c_1 \times n \), and the running time of \textit{partition} is bounded by \( c_2 \times n \). We are interested in the cost of \textit{select} using \textit{GoodPivot}. Choose the tightest answer. The running time of the algorithm is bounded by:
a. \( cn \)
b. \( c n \log n \)
c. \( cn^2 \)
Provide a proof by induction and the lowest value of \( c \) (as a function of \( c_1, c_2 \), and the problem data).
\end{quote}",a,"The tightest bound is: A. The value c is: 20. Proof: Induction - \( T(n) < (c_1+c_2)n + t(0.95n) \) 
\( T(n) < (c_1+c_2)n + 0.95 \times 20 (c_1+c_2)n = 20(c_1+c_2)n \)",3,m,tested,,"בכיתה למדנו על 𝑠𝑒𝑙𝑒𝑐𝑡 דטרמיניסטי שביצע 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 תוך שמוש ב 𝑝𝑖𝑣𝑜𝑡 שנבחר על ידי אלגוריתם חציון-החציונים.
הניחו שבתור תחליף ל 𝑝𝑖𝑣𝑜𝑡 הנ""ל קיבלתם אלגוריתם חדש הנקרא 𝐺𝑜𝑜𝑑𝑃𝑖𝑣𝑜𝑡 המקבל מערך המכיל 𝑛 מפתחות ומחזיר את הערך של האיבר ה 0.05𝑛 הקטן ביותר. לדוגמה על מערך בגודל 1000 הוא יחזיר את ערך המפתח ה 50 הקטן ביותר. 𝐺𝑜𝑜𝑑𝑃𝑖𝑣𝑜𝑡 אינו קורא ל 𝒔𝒆𝒍𝒆𝒄𝒕 )בנגוד לאלגוריתם חציון החציונים). הניחו שזמן הריצה של 𝐺𝑜𝑜𝑑𝑃𝑖𝑣𝑜𝑡 חסום על ידי 𝑐1*𝑛 זמן הריצה של 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 חסום על ידי 𝑐2*𝑛 . אנחנו מעוניינים בעלות של select המשתמש ב 𝐺𝑜𝑜𝑑𝑃𝑖𝑣𝑜𝑡 .
בחרו את התשובה ההדוקה ביותר.
זמן הריצה של האלגוריתם חסום על ידי:
א. 𝑐𝑛
ב. 𝑐⁡𝑛𝑙𝑜𝑔𝑛
ג. 𝑐𝑛2
ספקו הוכחה באינדוקציה ואת ערכו של 𝐜 הנמוך ביותר (כפונקציה של 𝑐1,𝑐2 ונתוני הבעייה).","החסם ההדוק ביותר הינו: א. הערך הינו c הינו: 20. הוכחה: אינדוקציה - T(n) < (c1+c2)n + t(0.95n)
T(n) < (c1+c2)n + 0.95*20 (c1+c2)n = 20(c1+c2)n",,,,
C,TRUE,2018,A,B,6-a,T3/ds18AB-Sol.pdf,TAU,5,"In order to improve \texttt{quicksort}, a new function \texttt{GreatPivot} has been created. It receives an array containing $n$ keys and returns a random value that is uniformly distributed among all key values that are greater than or equal to the $\lceil 0.05n \rceil$-th largest and less than or equal to the $\lfloor 0.95n \rfloor$-th largest element. The \texttt{partition} function performs the partitioning using this value. In other words, unlike \texttt{randpartition}, which selects a pivot randomly from all elements, this choice is restricted to only 90\% of the elements mentioned above.

The cost of \texttt{greatpivot} is $O(1)$, and the cost of \texttt{partition} is linear. The time complexity of \texttt{quicksort} when using \texttt{partition} and \texttt{GreatPivot} is, in the worst case:
\begin{enumerate}
  \item $\Theta(n)$
  \item $\Theta(0.9n)$
  \item $\Theta(n \log n)$
  \item $\Theta(n^2)$
\end{enumerate}",c,"The complexity is: \( \theta(n \log n) \). Proof:  
The depth of the tree is bounded from above by \(\log_{1/0.95} n\) and from below by \(\log_{1/0.05} n\). That is, between these depths, the width of the layer is partial. Therefore, the bounds on the total width of all layers are \(n \log_{1/0.95} n\) and \(n \log_{1/0.05} n\).",4,j,tested,,"במטרה לשפר את 𝑞𝑢𝑖𝑐𝑘𝑠𝑜𝑟𝑡 יוצרה פונקציה חדשה 𝐺𝑟𝑒𝑎𝑡𝑃𝑖𝑣𝑜𝑡 המקבלת מערך המכיל n מפתחות ומחזירה ערך אקראי המתפלג יוניפורמית בין כל ערכי המפתחות שהם גדולים או שווים לאיבר ה ⌈0.05n⌉ בגודלו וקטנים או שווים מהאיבר ה ⌊0.95𝑛⌋ בגודלו. הפונקציה 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 מבצעת את החלוקה על ערך זה. במילים אחרות בניגוד ל 𝑟𝑎𝑛𝑑𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 , שבוחר פיבוט באקראי מכל האיברים, בחירה זו מתפרשת רק על 90% מהאיברים שצוינו לעיל.
עלותה של 𝑔𝑟𝑒𝑎𝑡𝑝𝑖𝑣𝑜𝑡 הינה (1)O ועלות ה 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 היא לינארית.
סיבוכיות 𝑞𝑢𝑖𝑐𝑘𝑠𝑜𝑟𝑡 בשימוש ב 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 וב 𝐺𝑟𝑒𝑎𝑡𝑃𝑖𝑣𝑜𝑡 הינה ב Worst case :
א. Θ(𝑛)
ב. Θ(0.9𝑛)
ג. Θ(𝑛𝑙𝑜𝑔𝑛)
ד. Θ(𝑛^2)","הסיבוכיות הינה: 𝜃(𝑛𝑙𝑜𝑔𝑛). הוכחה:
עומק העץ חסום מלמעלה על ידי 𝑙𝑜𝑔1/0.95𝑛 ומלמטה על ידי 𝑙𝑜𝑔1/0.05𝑛 . כלומר בין העומקים האלו רוחב השכבה הוא חלקי. לכן חסמים של רוחב כולל של כל השכבות הינם 𝑛𝑙𝑜𝑔1/0.95𝑛 𝑛𝑙𝑜𝑔1/0.05𝑛",,,,
C,TRUE,2018,A,B,6-b,T3/ds18AB-Sol.pdf,TAU,5,na,c,na,4,j,untested,,"במטרה לשפר את 𝑞𝑢𝑖𝑐𝑘𝑠𝑜𝑟𝑡 יוצרה פונקציה חדשה 𝐺𝑟𝑒𝑎𝑡𝑃𝑖𝑣𝑜𝑡 המקבלת מערך המכיל n מפתחות ומחזירה ערך אקראי המתפלג יוניפורמית בין כל ערכי המפתחות שהם גדולים או שווים לאיבר ה ⌈0.05n⌉ בגודלו וקטנים או שווים מהאיבר ה ⌊0.95𝑛⌋ בגודלו. הפונקציה 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 מבצעת את החלוקה על ערך זה. במילים אחרות בניגוד ל 𝑟𝑎𝑛𝑑𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 , שבוחר פיבוט באקראי מכל האיברים, בחירה זו מתפרשת רק על 90% מהאיברים שצוינו לעיל.
עלותה של 𝑔𝑟𝑒𝑎𝑡𝑝𝑖𝑣𝑜𝑡 הינה (1)O ועלות ה 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 היא לינארית.
סיבוכיות 𝑞𝑢𝑖𝑐𝑘𝑠𝑜𝑟𝑡 בשמוש ב 𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛 וב 𝐺𝑟𝑒𝑎𝑡𝑃𝑖𝑣𝑜𝑡 הינה ב Average case :
א. Θ(𝑛)
ב. Θ(0.9𝑛)
ג. Θ(𝑛𝑙𝑜𝑔𝑛)
ד. Θ(𝑛^2)
ה. אי אפשר לדעת",הסיבוכיות הינה: 𝜃(𝑛𝑙𝑜𝑔𝑛). הוכחה: סיבכיות תוחלת חסומה מלמעלה על ידי worst case . תוחלת חסומה מלמטה על ידי זמן הריצה הטוב ביותר שהוא כשהפיבוט הוא החציון וגם זה nlogn.,,,,
B,TRUE,2018,A,B,7-a,T3/ds18AB-Sol.pdf,TAU,6,"\documentclass{article}
\begin{document}

In class, we learned about Union-Find implemented with linked lists. In this implementation, the \textit{union} operation was costly, and the \textit{find} was inexpensive. 

Reminder: In the union operation, the shorter list was merged into the longer one. Each list had a leader to whom all the elements of the list pointed. In the union operation, the algorithm traversed all the elements in the shorter list and updated their pointer to the leader of the longer list. The find operation returned the leader in $O(1)$ time.

We will deal with careless Find-Union. In it, merging the shorter list into the longer one is emphasized only if a certain condition concerning the two lists $A$ and $B$ holds. Otherwise, one is arbitrarily merged into the other.

If the ""emphasis"" condition is $5 < |\text{size}(A) - \text{size}(B)|$:

1. What is the maximum cost of the \textit{union} operation? (Counted by the number of elements changing groups)
2. What will be the complexity of $n$ \textit{union} operations? (Order of magnitude)

\end{document}",na,"\text{Maximum cost for a union operation (number of elements crossing a set): } \frac{n}{2} + 2 \\
\text{Justification:} \\
\text{Merge } \frac{n}{2} - 2 \text{ with } \frac{n}{2} + 2 \\
\text{Cost of } n \text{ union operations (order of magnitude): } O(n \log n) \\
\text{Justification: For each element, each transfer increases its group by a factor of at least 1.5 (if size > 10), so the number of times it transfers is at most } 10 + \log_{\text{base } 1.5} n",na,n,tested,,"בכיתה למדנו על Union-Find במימוש ברשימות מקושרות. במימוש זה פעולת ה 𝑢𝑛𝑖𝑜𝑛 הייתה יקרה ו 𝑓𝑖𝑛𝑑 הייתה זולה.
תזכורת: בפעולת איחוד מוזגה הרשימה הקצרה אל הארוכה. לכל רשימה היה מנהיג שכל איברי הרשימה הצביעו אליו. בפעולת union , האלגוריתם עבר על כל האיברים ברשימה הקצרה ועדכן את המצביע שלהם למנהיג הרשימה הארוכה. פעולת find החזירה את המנהיג בזמן (1)O .
נעסוק ב Find -Union רשלני. בו מקפידים על מיזוג הרשימה הקצרה אל הארוכה רק אם מתקיים תנאי מסוים לגבי שתי הרשימות A ו B . אחרת ממזגים שרירותית אחת אל השנייה.
אם תנאי ה""הקפדה"" הינו 5 < |𝑠𝑖𝑧𝑒(𝐴)−𝑠𝑖𝑧𝑒(𝐵)|⁡ ⁡ 
1. מה העלות המירבית של פעולת 𝑢𝑛𝑖𝑜𝑛 ? )נספרת במספר האיברים העוברים קבוצה)
2. מה תהיה הסיבוכיות של n פעולות 𝑢𝑛𝑖𝑜𝑛 ? )סדר גודל)","עלות מירבית לפעולת union (מספר האיברים העוברים קבוצה): n/2+2
נימוק:
Merge n/2-2 with n/2+2
עלות n פעולות union (סדר גודל) : O(nlog n)
נימוק: For each element each transfer increases its group by factor of at least 1.5 (if size > 10) so # times it transfers is at most 10 + log (base 1.5) of n",,,,
B,TRUE,2018,A,B,7-b,T3/ds18AB-Sol.pdf,TAU,6,"\begin{itemize}
    \item In class, we learned about Union-Find implemented with linked lists. In this implementation, the union operation was costly and the find operation was cheap.
    \item Reminder: In the union operation, the shorter list was merged into the longer one. Each list had a leader to which all elements of the list pointed. In the union operation, the algorithm iterated over all the elements of the shorter list and updated their pointer to the leader of the longer list. The find operation returned the leader in \( O(1) \) time.
    \item We will discuss a careless Union-Find, where merging the shorter list into the longer one is enforced only if a certain condition regarding the two lists \( A \) and \( B \) is met. Otherwise, one is arbitrarily merged into the other.
    \item If the condition for ""enforcement"" is \( \frac{\text{size}(A)}{\text{size}(B)} > 5 \) or \( \frac{\text{size}(A)}{\text{size}(B)} < \frac{1}{5} \):
    \begin{enumerate}
        \item What is the maximum cost of a union operation? (Counted by the number of elements switching groups)
        \item What will be the complexity of \( n \) union operations? (Order of magnitude)
    \end{enumerate}
\end{itemize}",na,"\begin{itemize}
    \item Maximum cost for a $\text{union}$ operation (number of elements transferring groups): $\frac{5}{6}n$
    \item Merge $\frac{5}{6}$ with $\frac{1}{6} n \Rightarrow$ costs $\frac{5}{6}n$
    \item Justification:
    \item Cost of $n$ $\text{union}$ operations (order of magnitude): $O(n \log n)$
    \item Justification:
    \item For each element, each transfer increases its group by a factor of at least $\frac{6}{5}$, so the number of transfers is at most $\log_{1.2} n$
\end{itemize}",na,n,tested,,"בכיתה למדנו על Union-Find במימוש ברשימות מקושרות. במימוש זה פעולת ה 𝑢𝑛𝑖𝑜𝑛 הייתה יקרה ו 𝑓𝑖𝑛𝑑 הייתה זולה.
תזכורת: בפעולת איחוד מוזגה הרשימה הקצרה אל הארוכה. לכל רשימה היה מנהיג שכל איברי הרשימה הצביעו אליו. בפעולת union , האלגוריתם עבר על כל האיברים ברשימה הקצרה ועדכן את המצביע שלהם למנהיג הרשימה הארוכה. פעולת find החזירה את המנהיג בזמן (1)O .
נעסוק ב Find -Union רשלני. בו מקפידים על מיזוג הרשימה הקצרה אל הארוכה רק אם מתקיים תנאי מסוים לגבי שתי הרשימות A ו B . אחרת ממזגים שרירותית אחת אל השנייה.
אם תנאי ה""הקפדה"" הינו 𝑠𝑖𝑧𝑒(A) / 𝑠𝑖𝑧𝑒(B)⁡ ⁡>⁡ 5 או ⁡⁡𝑠𝑖𝑧𝑒(𝐴)/𝑠𝑖𝑧𝑒(𝐵)⁡ < ⁡1/5:
1. מה העלות המירבית של פעולת 𝑢𝑛𝑖𝑜𝑛 ? )נספרת במספר האיברים העוברים קבוצה)
2. מה תהיה הסיבוכיות של n פעולות 𝑢𝑛𝑖𝑜𝑛 ? )סדר גודל)","עלות מירבית לפעולת 𝑢𝑛𝑖𝑜𝑛 )מספר האיברים העוברים קבוצה): 5/6n
Merge 5/6 with 1/6 n ➔ costs 5/6n
נימוק:
עלות 𝑛 פעולות 𝑢𝑛𝑖𝑜𝑛 )סדר גודל): (O(nlogn
נימוק:
For each element each transfer increases its group by factor of at least 6/5 so # transfers is at most log (base 1.2) of n",,,,
C,TRUE,2018,A,B,8-a,T3/ds18AB-Sol.pdf,TAU,3,"Alice ran the Perfect Hash algorithm learned in class (Two Level Hashing) on \( n > 100,000 \) keys. During the execution of the first part of the algorithm (creating the main table), Alice chose a function \( h_1 \) and discovered that the last \( 0.9n \) cells in the table are empty (we do not know what happened with the first cells). Answer True\False and justify: According to the algorithm, Alice can proceed to the second stage of the algorithm (creation of secondary level tables).",FALSE,"\noindent No. Explanation: The sum of the squares is at least approximately $10n$. Definitely greater than $n$. According to the algorithm, return to step 1. $\text{col} \mid \geq \left(\frac{n}{10}\right) \left(\frac{10 \times 9}{2}\right) = \frac{9n}{2} > n \rightarrow \text{algorithm will repeat stage 1} \mid$.",2,g,tested,,"אליס הריצה את האלגוריתם Perfect Hash שנלמד בכיתה ( Two Level Hashing ) על 𝑛>100,000 מפתחות. בהרצת החלק הראשון של האלגוריתם )יצירת הטבלה הראשית) בחרה אליס פונקציה ℎ1 וגילתה שכל 0.9𝑛 התאים האחרונים בטבלה ריקים (לא ידוע לנו מה קרה בתאים הראשונים). עני נכון\לא נכון ונמקי: על פי האלגוריתם אליס יכולה להמשיך לשלב השני של האלגוריתם (ייצור טבלאות ברמה השניה).","לא. הסבר: סכום הריבועים הינו לפחות 10n בערך. בוודאות גדול מ n . עפ האלגוריתם חוזרים על שלב 1 .
col| >= (n/10)*(10*9/2) = n*9/2 > n       ->       algorithm will rpeat stage 1|.",,,,
C,TRUE,2018,A,B,8-b,T3/ds18AB-Sol.pdf,TAU,3,na,FALSE,na,2,g,untested,,"אליס הריצה את האלגוריתם Perfect Hash שנלמד בכיתה ( Two Level Hashing ) על 𝑛>100,000 מפתחות. בהרצת החלק הראשון של האלגוריתם )יצירת הטבלה הראשית) בחרה אליס פונקציה ℎ1 וגילתה שכל 0.9𝑛 התאים האחרונים בטבלה ריקים (לא ידוע לנו מה קרה בתאים הראשונים). עני נכון\לא נכון ונמקי: על פי האלגוריתם אליס תבצע שוב את השלב הראשון של אלגוריתם, ותוחלת מספר הנסיונות הכולל של ביצוע השלב הראשון (כולל הניסיון שכבר נעשה)
הינו, בסיטואציה הזו, חסום על ידי 2 .","לא. הסבר: היא תבצע את השלב אבל התוחלת חסומה על ידי 3 .
( one so far + 2 for expected future)",,,,
C,TRUE,2018,A,B,8-c,T3/ds18AB-Sol.pdf,TAU,2,"Alice ran the Perfect Hash algorithm learned in class (Two Level Hashing) on 𝑛>100,000 keys. In running the first part of the algorithm (creating the main table), Alice chose a function ℎ1 and found that all 0.9𝑛 of the last slots in the table are empty (we do not know what happened in the first slots). Answer true\false and explain: In light of the results of the first stage, if Alice continues directly to the second stage, then the expected number of attempts to obtain good functions in the second stage will be greater than 10.",FALSE,\textit{No. Explanation: The expectation is bounded by 2.},2,g,tested,,"אליס הריצה את האלגוריתם Perfect Hash שנלמד בכיתה ( Two Level Hashing ) על 𝑛>100,000 מפתחות. בהרצת החלק הראשון של האלגוריתם )יצירת הטבלה הראשית) בחרה אליס פונקציה ℎ1 וגילתה שכל 0.9𝑛 התאים האחרונים בטבלה ריקים (לא ידוע לנו מה קרה בתאים הראשונים). עני נכון\לא נכון ונמקי: לאור תוצאות השלב הראשון, במידה ואליס תמשיך ישירות לשלב השני אזי תוחלת מספר הניסיונות להשגת פונקציות טובות בשלב השני יהיה גדול מ 10.",לא. הסבר: התוחלת חסומה על ידי 2.,,,,
C,TRUE,2018,A,B,8-d,T3/ds18AB-Sol.pdf,TAU,2,na,FALSE,na,2,g,untested,,"אליס הריצה את האלגוריתם Perfect Hash שנלמד בכיתה ( Two Level Hashing ) על 𝑛>100,000 מפתחות. בהרצת החלק הראשון של האלגוריתם )יצירת הטבלה הראשית) בחרה אליס פונקציה ℎ1 וגילתה שכל 0.9𝑛 התאים האחרונים בטבלה ריקים (לא ידוע לנו מה קרה בתאים הראשונים). עני נכון\לא נכון ונמקי: לאור תוצאות השלב הראשון, במידה ואליס תמשיך ישירות לשלב השני, אזי הגודל הכולל של הטבלאות יהיה בוודאות ריבועי ב n.",לא. הסבר: אם כולם מפוזרים אחיד מקבלים n*10 . אם כולם מרוכזים בתא אחד מקבלים n^2.,,,,
C,TRUE,2018,A,B,8-e,T3/ds18AB-Sol.pdf,TAU,2,na,1,na,2,g,untested,,"אליס הריצה את האלגוריתם Perfect Hash שנלמד בכיתה ( Two Level Hashing ) על 𝑛>100,000 מפתחות. בהרצת החלק הראשון של האלגוריתם )יצירת הטבלה הראשית) בחרה אליס פונקציה ℎ1 וגילתה שכל 0.9𝑛 התאים האחרונים בטבלה ריקים (לא ידוע לנו מה קרה בתאים הראשונים). עני נכון\לא נכון ונמקי: לאור תוצאות השלב הראשון, במידה ואליס תמשיך ישירות לשלב השני, אזי הפיזור של המפתחות ב 0.1n התאים הראשונים יקבע אם הגודל הכולל של הטבלאות בשלב השני הינו ריבועי או לא. כלומר יש מצבים בהם הגודל הזה ריבועי ויש מצבים בהם אינו ריבועי.",כן. הסבר: אם כולם מפוזרים אחיד מקבלים n*10 . אם כולם מרוכזים בתא אחד מקבלים n^2.,,,,
B,TRUE,2018,A,B,9-a,T3/ds18AB-Sol.pdf,TAU,3,na,na,na,na,f,untested,,"עץ 𝑚𝑎𝑣𝑙 הוא עץ חיפוש בינארי.
הוא מקיים את התכונות הבאות :
1. לכל עלה יש דרגה 0 .
2. לכל עלה חיצוני יש דרגה -1
3. כל צומת פנימית יש ילדים עם הפרשי דרגות 1-1 או 2-2 .
עבור 𝑘 זוגי, מה הוא מספר העלים המקסימלי של עץ 𝑚𝑎𝑣𝑙 שדרגת השורש שלו היא 𝑘? מה הוא מספר העלים המינימלי של עץ 𝑚𝑎𝑣𝑙 שדרגת השורש שלו היא 𝑘 ?","מספר מקסימלי: ⁡ 2 בחזקת K.
נימוק קצר: נעשה עץ בינארי מלא , עם הפרשי דרגות של 1-1 .
ניתן להוכיח את החסם פורמלית באינדוקציה על k. מספר מינימלי: 2 בחזקת K\2
נימוק קצר: נעשה עץ בינארי מלא , עם הפרשי דרגות של 2-2 .
ניתן להוכיח את החסם פורמלית באינדוקציה על K.",,,,
B,TRUE,2018,A,B,9-b,T3/ds18AB-Sol.pdf,TAU,3,na,na,na,na,f,untested,,"עץ 𝑣𝑎𝑣𝑙 הוא עץ חיפוש בינארי.
הוא מקיים את התכונות הבאות :
1. לכל עלה יש דרגה 0 .
2. לכל עלה חיצוני יש דרגה -1
3. כל צומת פנימית יש ילדים עם הפרשי דרגות 1-2 , 2-2 או 2-4
מה היא נוסחת הנסיגה שמייצגת את מספר הצמתים הפנימיים המינימלי (לא חיצוניים) של עץ 𝑣𝑎𝑣𝑙 שדרגת השורש שלו היא 𝑘 ?","𝐹(𝑛)=𝐹(𝑛−2)+𝐹(𝑛−4)+1,𝐹(0)=𝐹(1)=𝐹(2)=1,𝐹(−1)=0",,,,
B,TRUE,2018,A,B,9-c,T3/ds18AB-Sol.pdf,TAU,3,"\textit{An NAVL tree is a binary search tree.}

\textit{It satisfies the following properties:}

\begin{enumerate}
    \item \textit{Each leaf has rank 0.}
    \item \textit{Each external leaf has rank -1.}
    \item \textit{Each internal node has children with rank differences of 1-1, 1-2, 1-3, …, 1-n.}
\end{enumerate}

\textit{What is the minimum number of internal nodes (non-external) of an NAVL tree whose root rank is \( k \)? What is the search complexity of an element in a binary search tree of type NAVL (in the worst case)?}",na,"\begin{itemize}
    \item Number: k
    \item Brief explanation: The tree can be a linked list. When the children of each node at degree $i$ are an external leaf, and a node at degree $i-1$. The degree differences of such a node are $i+1, 1$.
    \item Complexity: $O(n)$
    \item Brief explanation: A tree as described in section A is a linked list. In such trees, searching is in $O(n)$ like in a linked list.
\end{itemize}",na,f,tested,,"עץ 𝑛𝑎𝑣𝑙 הוא עץ חיפוש בינארי.
הוא מקיים את התכונות הבאות :
1. לכל עלה יש דרגה 0 .
2. לכל עלה חיצוני יש דרגה -1
3. כל צומת פנימית יש ילדים עם הפרשי דרגות 1-1, 1-2, 1-3, … 1-n .
מה הוא מספר הצמתים הפנימיים המינימלי (לא חיצוניים) של עץ 𝑛𝑎𝑣𝑙 שדרגת השורש שלו היא 𝑘 ? מה היא הסיבוכיות חיפוש של איבר בעץ חיפוש בינארי מסוג 𝑛𝑎𝑣𝑙 )במקרה הגרוע ביותר(?","מספר: k
נימוק קצר: העץ יכול להיות רשימה מקושרת. כשהבנים של כל צומת בדרגה i הם עלה חיצוני, וצומת בדרגה i-1 . הפרשי הדרגות של צומת כזו הם i+1,1.
סיבוכיות: 𝑂(𝑛)
נימוק קצר: עץ כמתואר בסעיף א' הוא רשימה מקושרת. בעצים כאלה חיפוש הוא ב O(n) כמו ברשימה מקושרת.",,,,
C,TRUE,2018,A,B,10,T3/ds18AB-Sol.pdf,TAU,6,"\begin{itemize}
    \item In class, we learned about a Lazy Binomial Heap where Successive Linking is performed during each \texttt{deletemin} operation (This refers to an implementation where linking is done until completion and not just one-pass).
    \item Let \texttt{fresh} be the number of ""fresh"" nodes (trees of size 1 that have not yet undergone Successive Linking) in the binomial heap.
    \item Let \texttt{old} be the number of the other nodes in the binomial heap. In this question, we deal with an Impatient Binomial Heap-Lazy where there is no \texttt{deletemin} and therefore Successive Linking is performed during \texttt{insert} operations. The execution of Successive Linking occurs only when an \texttt{insert} operation causes a ""large"" increase in the number of ""fresh"" nodes in the structure.
    \item Assume that Successive Linking is performed with each \texttt{insert} operation that causes \(\texttt{fresh} > 100\). What is the complexity of \texttt{insert}? Given that \(n\) is the number of nodes in the structure at the moment of operation execution.
    \begin{enumerate}
        \item Worst Case = \(O(\log n)\). Amortized = \(O(\log n)\)
        \item Worst Case = \(O(n)\). Amortized = \(O(\log n)\)
        \item Worst Case = \(O(\log n)\). Amortized = \(O(1)\)
        \item Worst Case = \(O(n)\). Amortized = \(O(1)\)
    \end{enumerate}
\end{itemize}",c,na,4,"b,i",tested,,"בכיתה למדנו על ערימה בינומית עצלה (Lazy Binomial Heap) שבה התבצע Successive Linking בכל פעולת 𝑑𝑒𝑙𝑒𝑡𝑒𝑚𝑖𝑛 (מדובר על מימוש שבו הלינקינג מתבצע עד תום ולא רק Onepass).
יהי 𝑓𝑟𝑒𝑠ℎ⁡⁡ # מספר הצמתים ה ”טריים” (עצים בגודל 1 שעדיין לא עבר Successive Linking) בערימה הבינומית.
יהי 𝑜𝑙𝑑 # מספרם של שאר הצמתים בערימה הבינומית. בשאלה זו נעסוק ב Impatient Binomial Heap-Lazy שבה אין 𝒅𝒆𝒍𝒆𝒕𝒆𝒎𝒊𝒏 ולכן מבצעים Successive Linking בפעולות ה 𝑖𝑛𝑠𝑒𝑟𝑡 . ביצוע ה Successive Linking יתבצע רק כשפעולת 𝑖𝑛𝑠𝑒𝑟𝑡 גורמת לגידול ""גדול"" בכמות הצמתים ה""טריים"" שנמצאים במבנה.
הניחו שמבצעים Successive Linking בכל 𝑖𝑛𝑠𝑒𝑟𝑡 שגורם ל fresh > 100 #. מהי סיבוכיות של  𝑖𝑛𝑠𝑒𝑟𝑡?  כאשר n הינו מספר הצמתים במבנה ברגע ביצוע הפעולה.
א. Worst Case = O(logn).  Amortized = O(logn)
ב. Worst Case = O(n).  Amortized = O(logn)
ג. (Worst Case = O(logn).  Amortized = O(1
ד. (Worst Case = O(n).  Amortized = O(1",na,,,,
C,TRUE,2018,A,A,1,T3/ds18AA-Sol.pdf,TAU,7,"In class, we learned about \textbf{select} using a random \textbf{partition}. In a specific run of this algorithm on an array $A$ of length $n$, the function \textbf{select} (including recursive calls to itself) was called $0.75n$ times in total (where $n$ is divisible by $4$). Assume that the runtime of \textbf{partition} is linear in the length of its input.
The runtime complexity was (choose the tightest answer):
\begin{enumerate}
    \item \(O(n)\)
    \item \(O(n \log n)\)
    \item \(O(n^2)\)
    \item Any answer between \(O(n)\) and \(O(n^2)\) is possible and depends on the values of the array.
    \item It is impossible to bound the running time since only the expected running time can be calculated.
\end{enumerate}",3,مקרה הגרוע ביותר הוא בין 1 + 2 + 3 + ⋯ + 0.75n = \Theta(n^2) ל-0.25n + 0.25n + 1 + 0.25n + 2 + ... + n = \Theta(n^2),5,m,tested,,"בכיתה למדנו על select המשתמש ב partition אקראי. בריצה ספציפית שביצע אלגוריתם זה על מערך A באורך n נקראה הפונקציה select (כולל קריאות לעצמה) 0.75n פעמים (n מתחלק ב 4) בסך הכל. הניחו שזמן הריצה של partition הינו לינארי באורך הקלט שלו.
סבוכיות זמן הריצה היתה (בחרו את התשובה ההדוקה ביותר):
א.	(O(n
ב.	(O(nlogn
ג.	(O(n2
ד.	כל תשובה בין (O(n לבין ףמ)0הינה אפשרית ותלויה בערכי המערך.
ה.	אי אפשר לחסום את זמן הריצה כי ניתן רק לחשב את תוחלת זמן הריצה.","Worst case is between 1 + 2 + 3 + ⋯ + 0.75n = Θ(n^2) and 0.25n + 0.25n + 1 + 0,25n + 2 + ... . n = Θ (n^2)",,,,
C,TRUE,2018,A,A,2,T3/ds18AA-Sol.pdf,TAU,5,"In class, we learned about select which uses a random partition. In a specific run performed by this algorithm on an array \( A \) of length \( n \), the function select (including calls to itself) was called 0.75\( n \) times (where \( n \) is divisible by 4) in total. Assume the running time of partition is linear in the length of its input. We are interested in the array \( A \) being sorted (from smallest to largest).
After the above run, the number of elements in the array \( A \) that are not in the correct place is (provide the tightest answer):
A. At most 0.25\( n \)
B. At most 0.75\( n \)
C. At least 0.75\( n \)
D. At most \(\log n\)
E. All elements are in place. The array is sorted.
F. Since partition is random - it is not possible to know, thus the other answers are incorrect.",1,"יש 0.75n צירים. כולם מגיעים למקומם. כל השאר אנחנו לא יודעים.

\textit{There are } 0.75n \textit{ pivots. They all land in their place. All the rest we don't know.}",6,m,tested,,"בכיתה למדנו על select המשתמש ב partition אקראי. בריצה ספציפית שביצע אלגוריתם זה על מערך A באורך n נקראה הפונקציה select (כולל קריאות לעצמה) 0.75n פעמים (n מתחלק ב 4) בסך הכל. הניחו שזמן הריצה של partition הינו לינארי באורך הקלט שלו. מעוניינים שהמערך A יהיה ממוין (מקטן לגדול).
לאחר הריצה הנ""ל מספר האיברים במערך A שאינם נמצאים במקום הנכון הינו (ספקו התשובה ההדוקה ביותר):
א.	לכל היותר 0.25n
ב.	לכל היותר 0.75n
ג.	לכל הפחות 0.75n
ד.	לכל היותר logn
ה.	כל האיברים נמצאים במקום. המערך ממוין.
ו.	היות ו partition אקראי - אי אפשר לדעת ולכן התשובות האחרות אינן נכונות.",There are 0.75n pivots. They all land in their place. All the rest we don’t know.,,,,
C,TRUE,2018,A,A,3,T3/ds18AA-Sol.pdf,TAU,4,na,2,na,4,i,untested,,"בכיתה למדנו על lazy binomial heap. נתעניין במימוש שבו: 1 .insert מתבצע על ידי הוספת עץ בגודל 1 לסוף רשימת העצים.
2.ב deletemin, לאחר השמטת המינימום, מכניסים את ילדיו לסוף רשימת העצים ומבצעים successive linking על ידי סריקת העצים (המתחילה בראש הרשימה ומסתיימת בסופה).
אליס (A) ביצעה insert של האיברים 2 + 1,2, .. .,2k, 2k + 1,2k בסדר עולה ואחר כך בצעה שני deletemin.
בוב (B) ביצע insert של אותם האיברים בסדר יורד ואחר כך ביצע שני deletemin.
נסמן ב (trees(B) , #trees(A# את מספר העיצים הבינומיים במבנה של A ובמבנה של B בהתאמה.
בסוף סדרת הפעולות (לאחר ביצוע שני ה deletemin) .
א.	(trees(A) > #trees(B#
ב.	(trees(A) = #trees(B#
ג.	(trees(A) < #trees(B#
ד.	התשובה תלויה ב K","Tree size does not depend on the values, only on number of nodes.",,,,
C,TRUE,2018,A,A,4,T3/ds18AA-Sol.pdf,TAU,5,"\documentclass{article}
\usepackage[utf8]{inputenc}
\begin{document}

In class, we learned about lazy binomial heaps. We will be interested in an implementation where: 
1. insert is performed by adding a tree of size 1 to the end of the list of trees. 
2. In deletemin, after removing the minimum, we insert its children at the end of the list of trees and perform successive linking by scanning the trees (starting from the head of the list and ending at its tail). 

Alice (A) performed insert of the elements \(1, 2, \ldots, 2^k, 2^k + 1, 2^k + 2\) in ascending order and then executed two deletemin operations. 
Bob (B) performed insert of the same elements in descending order and then executed two deletemin operations. 
Let \(\#\text{links}(A), \#\text{links}(B)\) denote the number of link operations that will be performed in the second deletemin operation in the structure of A and in the structure of B, respectively. 
For \(1 < k\):

a. \(0 \sim |\#\text{links}(A) - \#\text{links}(B)|\)

b. \(|\#\text{links}(A) - \#\text{links}(B)| \sim \log k\)

c. \(|\#\text{links}(A) - \#\text{links}(B)| \sim k\)

d. \(|\#\text{links}(A) - \#\text{links}(B)| \sim 2^k\)

e. The answer depends on \(k\)

\end{document}",3,"\textit{Short explanation: (To illustrate the explanation, we can use $k=3$, but the reasoning is valid for general $k>1$). In one data structure, the minimum is in a tree of size 1, whereas in the other data structure, the minimum is in a tree of size $2k$ (with $k$ children).}",5,i,tested,,"בכיתה למדנו על lazy binomial heap. נתעניין במימוש שבו: 1 .insert מתבצע על ידי הוספת עץ בגודל 1 לסוף רשימת העצים.
2.ב deletemin, לאחר השמטת המינימום, מכניסים את ילדיו לסוף רשימת העצים ומבצעים successive linking על ידי סריקת העצים (המתחילה בראש הרשימה ומסתיימת בסופה).
אליס (A) ביצעה insert של האיברים 2 + 1,2, .. .,2k, 2k + 1,2k בסדר עולה ואחר כך בצעה שני deletemin.
בוב (B) ביצע insert של אותם האיברים בסדר יורד ואחר כך ביצע שני deletemin.
נסמן ב (links(B) ,#links(A# את מספר פעולות ה link שיתבצעו בפעולת ה deletemin השניה במבנה של A ובמבנה של B בהתאמה.
עבור 1<:k
א.	0 ~ |(links(A) — #links(B#|
ב.	links(A) — #links(B) | ~ log k#|
ג.	links(A) — #links(B)l ~ k#|
ד.	l#links(A) — #links(B)l ~ 2fc
ה.	התשובה תלויה ב  K","הסבר קצר: (לצורך המחשת ההסבר ניתן להשתמש ב3=k אך הנימוק נכון ל 1<k כללי).
In one DS the minimum is in a tree of size 1, in the other DS the minimum is in a tree of
.(size 2k (with k children",,,,
C,TRUE,2018,A,A,5,T3/ds18AA-Sol.pdf,TAU,1.6,"\begin{quote}
Bob implemented the perfect hash algorithm studied in class (two-level hashing). In running the first part of the algorithm (creating the main table), Bob chose the function \( h_1 \) and discovered that for the last \(1 + n - \sqrt{n} \) keys that he inserted into the main table, each one entered a ""private"" cell (i.e., without collision). Based on this information, Bob decided not to check the other keys and not to try additional functions in the first stage, and move on to the second stage. Answer true\false and justify. Within no more than 2 attempts in the second stage (for each sub-table), a perfect hash will be found.
\end{quote}",FALSE,\textit{Not true. The second stage produces square tables and therefore works on average in two attempts. The data from the question did not affect this.},2,g,tested,,"בוב הריץ את אלגוריתם perfect hash שנלמד בכיתה (two level hashing). בהרצת החלק הראשון של האלגוריתם (יצירת הטבלה הראשית) בחר בוב פונקציה h1 וגילה ש  sqrt(n) +n + 1-  המפתחות האחרונים שהכניס לטבלה הראשית נכנסו כל אחד לתא ""פרטי"" (כלומר ללא התנגשות). על סמך מידע זה החליט בוב שלא יבדוק את המפתחות האחרים ולא ינסה פונקציות נוספות בשלב הראשון ויעבור לבצוע השלב השני. ענה נכון\לא נכון ונמק. תוך 2 נסיונות לכל היותר בשלב השני (עבור כל טבלת משנה) - ימצא hash מושלם.",לא נכון. שלב שני מייצר טבלות ריבועיות ולכן עובד בתוחלת בשני נסיונות נתוני השאלה לא השפיעו על זה.,,,,
C,TRUE,2018,A,A,6,T3/ds18AA-Sol.pdf,TAU,1.6,"Bob improved the perfect hash algorithm learned in class (two-level hashing). During the execution of the first part of the algorithm (creating the main table), Bob chose a function h1 and found that the last \(1 + n - \sqrt{n} \) keys he inserted into the main table each went into a ""private"" cell (i.e., without collision). Based on this information, Bob decided not to check the other keys and not to try additional functions in the first stage and to move to execute the second stage. Answer true/false and explain. In expectation, within 2 attempts in the second stage (for each subtable), a perfect hash will be found.",1,"\textit{Correct. The second stage produces square tables, thus works on average in two attempts. The details of the question did not affect this.}",2,g,tested,,"בוב הריץ את אלגוריתם perfect hash שנלמד בכיתה (two level hashing). בהרצת החלק הראשון של האלגוריתם (יצירת הטבלה הראשית) בחר בוב פונקציה h1 וגילה ש  sqrt(n) +n + 1-  המפתחות האחרונים שהכניס לטבלה הראשית נכנסו כל אחד לתא ""פרטי"" (כלומר ללא התנגשות). על סמך מידע זה החליט בוב שלא יבדוק את המפתחות האחרים ולא ינסה פונקציות נוספות בשלב הראשון ויעבור לבצוע השלב השני. ענה נכון\לא נכון ונמק. תוך 2 נסיונות בתוחלת בשלב השני (עבור כל טבלת משנה) - ימצא hash מושלם.",נכון. שלב שני מייצר טבלות ריבועיות ולכן עובד בתוחלת בשני נסיונות נתוני השאלה לא השפיעו על זה.,,,,
C,TRUE,2018,A,A,7,T3/ds18AA-Sol.pdf,TAU,1.6,"Bob ran the perfect hash algorithm learned in class (two-level hashing). In executing the first part of the algorithm (creating the main table), Bob chose a function $h_1$ and discovered that the last $\1+ n - sqrt{n}$ keys he inserted into the main table each went into a “private” cell (i.e., without collisions). Based on this information, Bob decided not to check the other keys, nor to try additional functions in the first stage, and moved on to execute the second stage. Answer True/False and justify:
The function $h_1$ does not guarantee Bob that the overall size of the structure will be linear in $n$, and therefore, he will not achieve the performance of the two-level hashing (perfect hash) learned in class.",FALSE,"\textit{It does promise, by calculating the sum of the squares of the cells (the worst case that all the square root of N remaining elements fall in the same place is still linear).}",2,g,tested,,"בוב הריץ את אלגוריתם perfect hash שנלמד בכיתה (two level hashing). בהרצת החלק הראשון של האלגוריתם (יצירת הטבלה הראשית) בחר בוב פונקציה h1 וגילה ש  sqrt(n) +n + 1-  המפתחות האחרונים שהכניס לטבלה הראשית נכנסו כל אחד לתא ""פרטי"" (כלומר ללא התנגשות). על סמך מידע זה החליט בוב שלא יבדוק את המפתחות האחרים ולא ינסה פונקציות נוספות בשלב הראשון ויעבור לבצוע השלב השני. ענה נכון\לא נכון ונמק. הפונקציה h1 לא מבטיחה לבוב שהגודל הכללי של המבנה יהיה לינארי ב n ולכן לא ישיג את הביצועים של two level hashing) perfect hash) שנלמד בכיתה.","היא כן מבטיחה, מחישוב סכום ריבועי התאים (המקרה הגרוע ביותר שכל שורש N האיברים הנותרים נופלים באותו מקום עדיין לינארי).",,,,
C,TRUE,2018,A,A,8,T3/ds18AA-Sol.pdf,TAU,1.6,"Bob implemented the perfect hash algorithm that was taught in class (two level hashing). When running the first part of the algorithm (creating the main table), Bob chose a function \( h_1 \) and discovered that the last \(  n + 1 - \sqrt{n} \) keys he inserted into the main table each went into a ""private"" cell (i.e., without collision). Based on this information, Bob decided not to check the other keys and not to try additional functions in the first stage, and moved on to perform the second stage. Answer true\false and explain. Answer 6 is incorrect. However, within 4 attempts on average in the second stage (for each sub-table) a perfect hash will be found.",FALSE,\textit{Not correct. The second stage produces square tables and therefore works on average in two attempts. The question data did not affect this.},2,g,tested,,"בוב הריץ את אלגוריתם perfect hash שנלמד בכיתה (two level hashing). בהרצת החלק הראשון של האלגוריתם (יצירת הטבלה הראשית) בחר בוב פונקציה h1 וגילה ש  sqrt(n) +n + 1-  המפתחות האחרונים שהכניס לטבלה הראשית נכנסו כל אחד לתא ""פרטי"" (כלומר ללא התנגשות). על סמך מידע זה החליט בוב שלא יבדוק את המפתחות האחרים ולא ינסה פונקציות נוספות בשלב הראשון ויעבור לבצוע השלב השני. ענה נכון\לא נכון ונמק. תשובה 6 אינה נכונה. אבל תוך 4 נסיונות בתוחלת בשלב השני (עבור כל טבלת משנה) - ימצא hash מושלם.",לא נכון. שלב שני מייצר טבלות ריבועיות ולכן עובד בתוחלת בשני נסיונות נתוני השאלה לא השפיעו על זה.,,,,
C,TRUE,2018,A,A,9,T3/ds18AA-Sol.pdf,TAU,1.6,"Bob ran the perfect hash algorithm learned in class (two-level hashing). When running the first part of the algorithm (creating the main table), Bob chose a function $h_1$ and found that the last $n + 1 - \sqrt{n}$ keys he inserted into the main table each went into a ""private"" cell (i.e., without collision). Based on this information, Bob decided not to check the other keys or try additional functions in the first step and proceeded to perform the second step. Answer True/False and explain. Within $O(n^2)$ time, it is guaranteed that a perfect hash will be found in the second step.",FALSE,"\textit{Not true. Theoretically, there could be infinite attempts.}",2,g,tested,,"בוב הריץ את אלגוריתם perfect hash שנלמד בכיתה (two level hashing). בהרצת החלק הראשון של האלגוריתם (יצירת הטבלה הראשית) בחר בוב פונקציה h1 וגילה ש  sqrt(n) +n + 1-  המפתחות האחרונים שהכניס לטבלה הראשית נכנסו כל אחד לתא ""פרטי"" (כלומר ללא התנגשות). על סמך מידע זה החליט בוב שלא יבדוק את המפתחות האחרים ולא ינסה פונקציות נוספות בשלב הראשון ויעבור לבצוע השלב השני. ענה נכון\לא נכון ונמק. בזמן O(n^2) מובטח שבשלב השני ימצא hash מושלם.",לא נכון. תאורטית יכול להיות אינסוף נסיונות.,,,,
C,TRUE,2018,A,A,10,T3/ds18AA-Sol.pdf,TAU,2,na,1,na,5,a,untested,,"הציעו אלגוריתם יעיל ככל האפשר המקבל כקלט 2 מחרוזות, אחת באורך n והשנייה באורך k ובודק האם המחרוזת באורך k מופיעה פעמיים (או יותר) כתת-מחרוזת במחרוזת באורך n. ניתן להניח ש K<N.
מה היא סיבוכיות האלגוריתם במקרה הגרוע ביותר?
א. O(n)
ב. O(n2)
ג. O(n log(k))
ד. О(n log(n))
ה. О(k log(n))
","O(n). נבנה עץ סייפות מהמחרוזת באורך n.
נטייל על הקשתות העץ, מהשורש, במסלול שמתאים לאותיות במחרוזת באורך k.
אם נגיע בטיול למצב שבו לא ניתן להמשיך בכיוון האות הבאה, נעצור ונחזיר false.
בסוף המסלול, כשעברנו על כל האותיות במחרוזת באורך k נבדוק אם אנחנו בצומת פנימית, או קשת שמצביעה לצומת פנימית. אם כן נחזיר true. אחרת false.
נימוק זמן ריצה:
בניית העץ –O(n)
טיול לאורכו – O(K) – כל פעם נחפש את האות הבא של המחרוזת באורך k, מתוך לכל היותר כמות קבוע של
פיצולים בעץ.
בדיקה אם אנחנו בצומת פנימית – (1)O.",,,,
C,TRUE,2018,A,A,11,T3/ds18AA-Sol.pdf,TAU,6,"The regular expression

\(ab+a\)

matches any string that starts with the letter a, continues with a series of repetitions of the letter b, and ends with the letter a. For example:

\(abba, aba, abbba\)

match the expression, whereas:

\(abb, bba, bb, bbaa, ab, baa\)

do not match.

Propose an efficient algorithm to check if a string of length \(n\) contains 2 substrings that match the above regular expression and are equal to each other.
What is the runtime of the most efficient algorithm? Circle the best answer.
a. Worst case time - \(O(n)\)
b. Worst case time - \(O(n^2)\)
c. Amortized time - \(O(n)\) and worst case time - \(O(n^2)\)
d. Amortized time - \(O(n \log n)\) and worst case time - \(O(n \log n)\)

Describe the algorithm and justify its runtime.",1,"\textbf{Algorithm Description:}  
We build a suffix tree for a string of length \( n \). We traverse the tree as follows – from the root, we look for the letters \( ab \). If we do not find a path starting with \( ab \), we return false.  
After that, we traverse the tree and look for the letters \( b \) and \( a \). If we find the letter \( a \), we check if the continuation of its edge leads to an internal node. If yes, we return true. If not, or if we do not find the letter \( a \), we continue on the path that the letter \( b \) leads to.  

\textbf{Runtime Analysis:}  
Tree construction – \( O(n) \)  
Traversing the path in the tree starting with \( a \) and then including only the series of letters \( b \) – path length in the tree is at most \( O(n) \), and each comparison in it is at most \( O(1) \) – total \( O(n) \).  
Checking at each stage in the path if there is a split for the letter \( a \), and if it leads to an internal node – \( O(1) \times n = O(n) \).",4,"a,b",tested,,"הביטוי הרגולרי

ab+a
מתאים לכל מחרוזת שמתחילה באות a, ממשיכה בסדרה של חזרות של האות b ונגמרת באות a. לדוגמה:

abba, aba, abbba

מתאימים לביטוי ו:

abb, bba, bb, bbaa, ab, baa

לא מתאימים.
הציעו אלגוריתם יעיל ככל האפשר שיבדוק אם מחרוזת באורך n מכילה 2 תתי מחרוזות שמתאימות לביטוי הרגולרי הנ""ל, ושוות זו לזו.
מה הוא זמן הריצה של האלגוריתם היעיל ביותר? הקיפו את התשובה הנכונה ביותר.
א. זמן גרוע ביותר - O(n)
ב. זמן גרוע ביותר - O(n^2)
ג. זמן אמורטיזד - O(n) וזמן גרוע ביותר - O(n^2)
ד. זמן אמורטיזד - O(nlogn) וזמן גרוע ביותר - O(nlogn)

תארו את האלגוריתם, ונמקו את זמני הריצה שלו.","תאור אלגוריתם:
נבנה עץ סייפות למחרוזת באורך n. נטייל בעץ באופן הבא – מהשורש נחפש את האותיות ab. אם לא נמצא מסלול שמתחיל ב ab נחזיר false.
אחריה, נטייל בעץ ונחפש את האתיות b ו a. אם נמצא את האות a, נבדוק אם המשך הקשת שלה מוביל לצומת פנימית, אם כן, נחזיר true. אם לא, או שלא מצאנו את האות a, נמשיך במסלול שמובילה אליו האות b.
נימוק זמן ריצה:
בניית העץ - O(n)
טיול במסלול בעץ שמתחיל ב a ואז כולל רק את סדרת האותיות b – מסלול בעץ באורך לכל היותר O(n) ,
וכל השוואה בו היא לכל היותר (1)O- סכ""ה O(n).
בדיקה בכל שלב במסלול אם קיים פיצול לאות a, ואם הוא מוביל לצומת פנימית –O(1)*n=O(n).",,,,
B,FALSE,2018,A,A,12-a,T3/ds18AA-Sol.pdf,TAU,4,na,na,na,na,k,untested,,מכיל ציור,na,,,,
B,FALSE,2018,A,A,12-b,T3/ds18AA-Sol.pdf,TAU,4,na,na,na,na,k,untested,,מכיל ציור,na,,,,
C,TRUE,2018,A,A,13-a,T3/ds18AA-Sol.pdf,TAU,4,\textit{Define an easy binary search tree as a binary tree where the following rule holds: each node x is greater than its left child (if it exists) and smaller than its right child (if it exists). Prove or disprove: any sequence of n different numbers can be inserted into an easy binary search tree in O(n) time.},1,"Yes.  
A short explanation:  
You can simply insert the elements in the order in which they are stored and construct a tree in the form of a thread. Each time a new element is inserted, check if it is smaller or larger than the previous element, and accordingly decide if it is the left/right child of the previous element.",2,e,tested,,"נגדיר עץ חיפוש בינארי קל כעץ בינארי בו מתקיים הכלל הבא: כל צומת x גדול מבנו השמאלי (אם קיים) וקטן מבנו הימני (אם קיים).
הוכיחו או הפריכו: ניתן לשכן סדרה כלשהיא של n מספרים שונים בעץ חיפוש בינארי קל בזמן O(n).","כן.
נימוק קצר:
ניתן פשוט להכניס את האיברים לפי הסדר בו הם שמורים ולבנות עץ במבנה של שרוך. כל פעם שמכניסים איבר חדש בודקים אם הוא קטן או גדול מהאיבר הקודם, ובהתאם לכך מחליטים אם הוא בן שמאלי/ימני של האיבר הקודם.",,,,
C,TRUE,2018,A,A,13-b,T3/ds18AA-Sol.pdf,TAU,6,na,1,na,2,"e,f",untested,,"נגדיר עץ חיפוש בינארי קל כעץ בינארי בו מתקיים הכלל הבא: כל צומת x גדול מבנו השמאלי (אם קיים) וקטן מבנו הימני (אם קיים).
הוכיחו או הפריכו:","כן. נימוק קצר:
אלגוריתם דומה לאלגוריתם לשיכון מערך עם n איברים לערימה בזמן O(n). מתייחסים
למערך כעל עץ, ואז מתקנים את העץ מלמטה למעלה שכבה שכבה.
הרעיון הוא לעבור על כל הצמתים בשכבה, ולפעפע את הבעיה למטה, בדומה לdown heapify.
כל פעם בודקים אם כלל עץ החיפוש הקל הופר, ובמידה שכן מתקנים בהתאם.
נשים לב שתמיד ניתן לפעפע את הבעיה צעד אחד כלפי מטה בזמן קבוע:
אם הערך של הצומת שכרגע מסתכלים עליו הוא בין שני הילדים שלו ורק הילדים בסדר לא נכון (הקטן מימין והגדול משמאל) אז מחליפים בין הילדים וסיימנו.
אחרת נניח שהערך של הצומת שמסתכלים עליו קטן יותר משני הילדים שלו (טיפול דומה כאשר הוא גדול יותר), אז אחד הילדים הוא עם הערך הגדול ביותר. קודם נדאג שהוא יישב כבן הימני של הצומת, ואז נחליף
את הצומת עם הבן השמאלי (שהוא כרגע עם הערך האמצעי מבין השלושה).
הבעיה עברה שלב אחד למטה (לאחר טיפול בזמן קבוע), וממשיכים באותו אופן עד שמגיעים לעלים והבעיה נפתרת.
",,,,
C,TRUE,2018,A,A,14-a,T3/ds18AA-Sol.pdf,TAU,4,na,1,na,4,p,untested,,"כמה זמן ייקח מיון הכנסות (sort insertion) על המערך באורך n הבא [7,8,5,6,3,4,1,2,...N,N-1]:
א. O(n)
ב. O(nlogn)
ג. O(n^2)
ד. O(n^{3/2})","ראינו שכאשר יש I הפרות סדר במערך, Sort Insertion ייקח (n + I)O. קל לראות שכאן O(n) = I.",,,,
C,TRUE,2018,A,A,14-b,T3/ds18AA-Sol.pdf,TAU,2,"A sloppy minimum heap is a heap where instead of returning the minimum, it returns one of the k smallest elements in the heap. Additionally, in the delete operation, it deletes the same element that it returned as the approximate minimum.
Is the sequence [7,8,5,6,3,4,1,2,...N,N-1] a possible output of a sloppy heap for k=1?",FALSE,"\textit{No, because when $K = 1$, the messy heap is a regular heap and therefore the output should be sorted.}",2,h,tested,,"ערימת מינימום מרושלת היא ערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הk איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר שהחזירה כמינימום המקורב.
האם הסדרה  [2,1,4,3,6,5,8,7,...N,N-1] היא פלט אופציונלי של ערימה מרושלת עבור 1=k?","לא, כי כאשר 1 =K הערימה המרושלת היא ערימה רגילה ולכן הפלט צריך להיות ממויין.",,,,
C,TRUE,2018,A,A,14-c,T3/ds18AA-Sol.pdf,TAU,2,na,1,na,2,h,untested,,"ערימת מינימום מרושלת היא ערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הk איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר שהחזירה כמינימום המקורב.
האם הסדרה  [7,8,5,6,3,4,1,2,...N,N-1] היא פלט אופציונלי של ערימה מרושלת עבור 2=k?",כן. קל לראות שאחד משני האיברים הקטנים ביותר הוחזרו.,,,,
C,TRUE,2018,A,A,14-d,T3/ds18AA-Sol.pdf,TAU,2,na,4,na,4,h,untested,,"ערימת מינימום מרושלת היא ערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הk איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר שהחזירה כמינימום המקורב.
עבור 2=k, נניח הכנסנו n איברים לערימה מרושלת ושלפנו אחד אחד. כמה איברים יכלו להישלף לפני שנשלף המינימום הגלובלי של n האיברים?
א. 0 איברים.
ב. 0 או 1 איברים.
ג. 1 או 2 איברים.
ד. כל מספר מבין 0 ל N-1.","תשובה: כל מספר מבין 0 ל N-1. נימוק: ניתן להחזיר במשך i פעמים את האיבר השני בגודלו ורק אז את האיבר הקטן ביותר, עבור כל i בין 0 ל1 − N.",,,,
C,TRUE,2018,A,A,14-e,T3/ds18AA-Sol.pdf,TAU,4,"A lazy minimum heap is a heap that instead of returning the minimum returns one of the k smallest elements in the heap. Additionally, in the delete operation, it deletes the same element that was returned as the approximate minimum. Prove or disprove the following claim:
For \( k=2 \), it is possible to implement a lazy heap such that all operations take \( O(1) \) amortized time.",FALSE,"\textit{Not possible. If it were possible, we would reach a contradiction to the sorting lower bound. We will perform a reduction from the sorting problem - we will insert the \( n \) elements we want to sort into a sloppy heap, and now find the approximate minimum and remove it. We will do this \( n \) times. We will take the sequence we obtained and note that it has at most \( n \) disorder violations, so now it is possible to perform insertion sort in linear time and obtain the sorted sequence.}",2,"b,h",tested,,"ערימת מינימום מרושלת היא ערימה שבמקום להחזיר את המינימום מחזירה את אחד מבין הk איברים הכי קטנים בערימה. בנוסף בפעולת המחיקה היא מוחקת את אותו איבר שהחזירה כמינימום המקורב. הוכיחו או הפריכו את הטענה הבאה:
עבור 2=k ניתן לממש ערימה מרושלת כך שכל הפעולות לוקחות O(1) amortized זמן.","לא ניתן. אם היה ניתן היינו מגיעים לסתירה לחסם התחתון של מיון.
נבצע רדוקציה מבעיית המיון – נכניס את n האיברים אותם אנחנו רוצים למיין לערימה מרושלת, וכעת נמצא את המינימום המקורב ונמחק אותו. נבצע זאת n פעמים. ניקח את הסדרה שקיבלנו ונשים לב שיש בה n הפרות סדר לכל היותר ולכן ניתן עכשיו לבצע מיון הכנסות בזמן לינארי ולקבל את הסדרה ממויינת.",,,,
A,TRUE,2018,A,A,15-a,T3/ds18AA-Sol.pdf,TAU,6,na,na,na,na,na,na,,"נרצה לתחזק את מהלך המשחק SudokTau. המשחק מתנהל על לוח n × n, כאשר מטרת המשחק היא למלא את כל הלוח במספרים בין 1 לn, ואסור שיהיה את אותו המספר פעמיים באותה שורה או באותה עמודה. השחקן יכול לבצע את הפעולות הבאות:
 Write(i,j,number) -  כותבת את המספר number למקום ה(i,j) בלוח.
המהלך הוא חוקי אם הוא לא מפר את כלל השורה והעמודה. אם המהלך אינו חוקי יש להודיע למשתמש. ניתן להניח שלא קיים איבר במקום ה(i,j) בלוח בעת ההכנסה.
Contains(i,j)  – בודקת האם קיים איבר במקום ה(i,j) בלוח. אם קיים, היא מחזירה את האיבר למשתמש.
Erase(i,j) - מוחקת את האיבר במקום ה(i,j) בלוח. ניתן להניח שקיים איבר במקום ה(i,j) בעת המחיקה.
()Won - מחזירה למשתמש האם הוא ניצח (את זה לא נממש).

תאר מימוש ל3 הפעולות הראשונות כך שכל הפעולות רצות בזמן (1)O במקרה הגרוע, כאשר סיבוכיותזמן ומקום האיתחול הוא O(n^2).","תיאור מבני הנתונים בהם אתם משתמשים בשביל המימוש (ומטרת כל מבנה נתונים):
צריך להחזיק 3 מבני נתונים. אחד כדי להחזיק את הלוח, אחד כדי להחזיק את תוכן העמודות ואחד כדי
להחזיק את תוכן השורות. כאשר ארשום מטריצה הכוונה היא למערך דו מימדי בגודל n × n.
עבור הלוח – נחזיק מטריצה A כך שתוכן הלוח במקום הi,j זה A[i,j], ו0 מציין שהתא ריק.
עבור תוכן השורות – נחזיק מטריצה B כך שאם num מופיע בשורה i אז B[i,num] = 1 ואחרת 0.
עבור תוכן העמודות – נחזיק מטריצה C כך שאם num מופיע בעמודה j אז C[j,num] = 1 ואחרת 0.

תיאור הפעולות:
(Contains(i,j:  במידה ו0 =! [A[i,j נחזיר את  [A[i,j. פעולת write במידה ו B[i,num] = 0 וגם C[j,num] = 0 נבצע השמות C[j,num] = 1 וגם  B[i,num] = 1 וגם ז A[i,j] = 1 אחרת נחזיר שהפעולה לא חוקית. Erase נשמור A[i,j] = num ונבצע השמות B[i,num] = C[j,num] = A[i,j] = 0. סיבוכיות זמן ומקום: האתחול (O(n^2 מהקצאת 3 מערכים דו מימדיים. סיבוכיות קבועה לכל פעולה כיוון שיש מספר קבוע של גישות למערכים.",,,,
B,TRUE,2018,A,A,15-b,T3/ds18AA-Sol.pdf,TAU,2,"\begin{quote}
In the following section, the initialization time and space complexity is O(1), and the space complexity at any given moment is O of the number of elements in the data structure. Describe how a vector of length m can be represented to support insertion at position i, reading from position i, and deletion at position i in O(\log m) worst-case time for each operation.
\end{quote}",na,"\textbf{Central Data Structure: AVL Tree. Short Description:} The key of an element will be the index \( i \), and the value will be the content of the vector at index \( i \).",na,"a,f",tested,,"בסעיף הבא, סיבוכיות זמן ומקום האיתחול הוא (1)O, וסיבוכיות המקום בכל רגע נתון הוא O של מספר האיברים במבנה הנתונים.
תאר כיצד ניתן לייצג וקטור באורך m שתומך בפעולות הכנסה למקום i , קריאה מהמקום i , ומחיקה מהמקום הi בזמן O(logm) במקרה הגרוע לכל פעולה.","מבנה נתונים מרכזי: עץ AVL. תיאור קצר:
הkey של איבר יהיה האינדקס i, והvalue יהיה תוכן הוקטור באינדקס i.",,,,
B,TRUE,2018,A,A,15-c,T3/ds18AA-Sol.pdf,TAU,3,"\textbf{In the following section, the time and space complexity of initialization is \(O(1)\), and the space complexity at any given moment is \(O\) of the number of elements in the data structure. Describe how a matrix of size \(m \times m\) can be represented, supporting the operations of insertion at position \((i,j)\), reading from position \((i,j)\), and deletion from position \((i,j)\), in \(O(\log m)\) worst-case time for each operation.}",na,"\textbf{Central Data Structure:} AVL Tree. \textbf{Brief Description:}
The key will be the pair (i,j) where the comparison between keys will be lexicographic (compare i, and if there is a tie, compare j).
The value will be the content of the matrix at position (i,j).",na,"a,f",tested,,"בסעיף הבא, סיבוכיות זמן ומקום האיתחול הוא (1)O, וסיבוכיות המקום בכל רגע נתון הוא O של מספר האיברים במבנה הנתונים. תאר כיצד ניתן לייצג מטריצה בגודל m × m שתומך בפעולות הכנסה למקום ה(i,j), קריאה מהמקום ה(i,j), ומחיקה מהמקום ה(i,j), בזמן O(logm) במקרה הגרוע לכל פעולה.","מבנה נתונים מרכזי: עץ AVL. תיאור קצר:
הkey יהיה הזוג (i,j) כאשר ההשוואה בין מפתחות תהיה לקסיקוגרפית (משווים את i, ואם יש תיקו משווים את j).
הvalue יהיה תוכן המטריצה במקום ה(i,j).
",,,,
A,TRUE,2018,A,A,15-d,T3/ds18AA-Sol.pdf,TAU,7,na,na,na,na,na,na,,"בסעיף הבא, סיבוכיות זמן ומקום האיתחול הוא (1)O, וסיבוכיות המקום בכל רגע נתון הוא O של מספר האיברים במבנה הנתונים. תאר מימוש ל3 הפעולות הראשונות (write, contains, erase) כך שכל הפעולות רצות בזמן O(logn). ","תיאור מבני הנתונים בשביל המימוש (ומטרת כל מבנה נתונים):
אותו פיתרון כמו בא', כאשר משתמשים במבנה הנתונים בסעיף ג' במקום המערכים הדו מימדיים.
תיאור מבני הנתונים בהם אתם משתמשים בשביל המימוש (ומטרת כל מבנה נתונים):
צריך להחזיק 3 מבני נתונים. אחד כדי להחזיק את הלוח, אחד כדי להחזיק את תוכן העמודות ואחד כדי להחזיק את תוכן השורות. נשתמש בשלושה עצי AVL כאשר הkey יהיה הזוג (i,j) כאשר ההשוואה בין מפתחות תהיה לקסיקוגרפית (משווים את i, ואם יש תיקו משווים את j).
הvalue יהיה תוכן המטריצה במקום ה(i,j). כל עץ AVL כזה מייצג מטריצה שתומך מפעולת הכנסה קריאה ומחיקה בO(logm). מעתה נתייחס למבנה זה כמטריצה.
עבור הלוח – נחזיק מטריצה A כך שתוכן הלוח במקום הi,j זה A[i,j], ו0 מציין שהתא ריק.
עבור תוכן השורות – נחזיק מטריצה B כך שאם num מופיע בשורה i אז B[i,num] = 1 ואחרת 0.
עבור תוכן העמודות – נחזיק מטריצה C כך שאם num מופיע בעמודה j אז C[j,num] = 1 ואחרת 0.
תיאור הפעולות:
(Contains(i,j:  במידה ו0 =! [A[i,j נחזיר את  [A[i,j. פעולת write במידה ו B[i,num] = 0 וגם C[j,num] = 0 נבצע השמות C[j,num] = 1 וגם  B[i,num] = 1 וגם ז A[i,j] = 1 אחרת נחזיר שהפעולה לא חוקית. Erase נשמור A[i,j] = num ונבצע השמות B[i,num] = C[j,num] = A[i,j] = 0. סיבוכיות זמן ומקום: האתחול (O(n^2 מהקצאת 3 מערכים דו מימדיים. סיבוכיות קבועה לכל פעולה כיוון שיש מספר קבוע של גישות למערכים.",,,,
B,TRUE,2018,A,A,16-a,T3/ds18AA-Sol.pdf,TAU,2,"\text{Describe an implementation of a data structure with the following operations (x is a key):}

\text{Insert(x) - in amortized time \(O(\log n)\).}

\text{Search(x) - in amortized time \(O(\log n)\).}

\text{Delete(x) - in amortized time \(O(\log n)\).}",na,"\textbf{Central Data Structure:} AVL Tree. \textbf{Brief Description:} We will use the standard operations of an AVL tree. \textbf{Complexity Explanation:} All operations are in worst-case in \(O(\log n)\), and therefore, in particular, amortized directly from the definition of amortized.",na,"b,p",tested,,"תאר מימוש של מבנה נתונים עם הפעולות הבאות (x הוא מפתח):
 Insert(x) - בזמן אמורטייזד O(logn).
 Search(x) - בזמן אמורטייזד O(logn).
Delete(x) - בזמן אמורטייזד O(logn).
","מבנה נתונים מרכזי: עץ AVL. תיאור קצר: נשתמש בפעולות הרגילות של עץ AVL.
הסבר לסיבוכיות: כל הפעולות הן בזמן הגרוע ב O(logn), ולכן בפרט באמורטייזד ישירות מההגדרה של אמורטייזד.",,,,
B,TRUE,2018,A,A,16-b,T3/ds18AA-Sol.pdf,TAU,2,"\begin{quote}
Describe an implementation of a data structure with the following operations (x is a key):
\begin{itemize}
    \item Insert(x) - in amortized time $O(\log n)$.
    \item Search(x) - in amortized time $O(\log n)$.
    \item Delete(x) - in amortized time $O(1)$.
\end{itemize}
\end{quote}",na,"\textbf{Central Data Structure:} AVL Tree. \textbf{Brief Description:} We will use the standard operations of an AVL tree. \textbf{Explanation for Complexity:} In the banker's method - at the time of insertion \((x(\text{insert})\), we insert the element, and additionally leave \(\log n\) coins for its deletion.",na,"b,p",tested,,"תאר מימוש של מבנה נתונים עם הפעולות הבאות (x הוא מפתח):
 Insert(x) - בזמן אמורטייזד O(logn).
 Search(x) - בזמן אמורטייזד O(logn).
Delete(x) - בזמן אמורטייזד (1)O.","מבנה נתונים מרכזי: עץ AVL. תיאור קצר: נשתמש בפעולות הרגילות של עץ AVL.
הסבר לסיבוכיות: בשיטת הבנק - בזמן הכנסה ((x(insert), נכניס את האיבר, ובנוסף נשאיר לו logn מטבעות בשביל המחיקה שלו.",,,,
B,TRUE,2018,A,A,16-c,T3/ds18AA-Sol.pdf,TAU,7,"\textit{Describe an implementation of a data structure with the following operations (x is a key):} \\
Insert(x) - \textit{in amortized time} $O(\log n)$. \\
Search(x) - \textit{in amortized time} $O(\log n)$. \\
Delete(x) - \textit{in amortized time} $O(1)$ \textit{and also in worst-case time} $O(1)$.",na,"\textbf{Central Data Structure:} AVL Tree. \textbf{Secondary Data Structure:} Linked List. The worst-case complexity of insert is \(O(n \log n)\). The worst-case complexity of search is \(O(n \log n)\). \textbf{Solution:}  
During initialization, we will initialize an AVL tree and a linked list.  
During deletion, we will insert \(x\) at the beginning of the linked list.  
During search/insert, before performing the actual operation, we will traverse the entire linked list and delete element by element.  
After emptying the list, we will perform the actual operation (search/insert).  
Amortized analysis using the banker's method - at the time of insertion \((x\text{, insert})\), we will insert the element and also leave it with \(\log n\) coins for its deletion.",na,"a,b,p",tested,,"תאר מימוש של מבנה נתונים עם הפעולות הבאות (x הוא מפתח):
 Insert(x) - בזמן אמורטייזד O(logn).
 Search(x) - בזמן אמורטייזד O(logn).
Delete(x) - בזמן אמורטייזד (1)O וגם במקרה הגרוע ביותר (1)O.","מבנה נתונים מרכזי: עץ AVL. מבנה נתונים משני: רשימה מקושרת. סיבוכיות במקרה הגרוע של insert הוא O(nlogn). סיבוכיות במקרה הגרוע של search הוא O(nlogn). פיתרון:
בזמן האתחול נאתחל עץ AVL ורשימה מקושרת.
בזמן מחיקה, נכניס את x לתחילת הרשימה המקושרת.
בזמן חיפוש/הכנסה, לפני ביצוע הפעולה עצמה, נעבור על כל הרשימה המקושרת ונמחק איבר איבר.
לאחר שרוקנו את הרשימה נבצע את הפעולה עצמה (חיפוש/הכנסה).
ניתוח האמורטייזד בשיטת הבנק - בזמן הכנסה ((x(insert), נכניס את האיבר, ובנוסף נשאיר לו logn מטבעות בשביל המחיקה שלו.",,,,
A,TRUE,2017,A,B,1-a,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נתון מערך של ח מספרים שלמים בין 0 ל-2 בחזקת n.
נתון שכל מספר במערך הוא כפולה של ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש. הציעו אלגוריתם למיון המערך.
","נחלק כל מספר ב-(ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש). כעת איברי המערך בתחום [0, n^3] וניתן למיינם באמצעות O(n) .radix sort.",,,,
A,TRUE,2017,A,B,1-b,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נתון מערך של ח מספרים שלמים בין 0 ל-2 בחזקת n. נתון כי המרחק בין כל שני מספרים הוא לפחות - [ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש] (פרט לחזרות על אותו מספר). הציעו אלגוריתם למיון המערך.","נעגל כל המספרים לכפולה השלמה של [ערך עליון של 2 בחזקת N, חלקי N בחזקת שלוש] הקרובה ביותר מלמטה ונשמור אותם במערך חדש לפי הסדר של המערך המקורי. נבצע radix sort במערך החדש ונבצע כל פעולת ""סידור"" של ה-radix sort במקביל
במערך המקורי. (O(n.",,,,
B,TRUE,2017,A,B,1-c,T3/ds17AB-sol.pdf,TAU,6.25,Two AVL trees of size \( n \) each are given. Can they be merged in \( O(n) \) time? Prove using an algorithm or disprove.,na,"\textbf{Proof.} Perform an in-order walk on each of the trees and obtain two sorted arrays of their elements. Perform a merge sort to obtain a single sorted array. Construct a balanced tree from it as follows: the median will be the root, the 1/4 and 3/4 order statistics will be the left and right child of the root respectively, and so on.",na,f,tested,,נתונים שני עצי AVL בגודל n כל אחד. האם ניתן למזגם בזמן O(n)? הוכח באמצעות אלגוריתם או הפרך.,"הוכחה. נבצע in order walk על כל אחד מהעצים ונקבל שני מערכים ממוינים של איבריהם. נבצע merge sort לקבלת מערך ממויך יחיד. נבנה ממנו עץ מאוזן באופן הבא: החציון יהיה השורש, הסטטיסטי סדר ה-1/4 וה-3/4 יהיו הבן השמאלי והימני של השורש בהתאמה, וכן הלאה.",,,,
B,TRUE,2017,A,B,1-d,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,f,untested,,נתונים שני עצי AVL בגודל n כל אחד. האם ניתן למזגם בזמן ((O(sqrt(n? הוכח באמצעות אלגוריתם או הפרך.,"לא ניתן. נניח וניתן היה לעשות זאת, אזי היינו יכולים למיין n מספרים בזמן קטן מ-(O(nlogn ע""י מיזוגים רקורסיבים ואז in order walk. נוסחת הרקורסיה המתוארת הינה T(n) = 2T(n/2) + Vn ופתרונה (O(n. לכן סה""כ זמן המיון הינו (O(n.",,,,
A,TRUE,2017,A,B,2-a,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נדרש מבנה נתונים התומך בפעולות הבאות על איברים המכילים שני שדות – id, amount. בכל רגע נתון מספר האיברים במבנה אינו עולה על N.
1. (Add(i,x מגדילה ב-x ערכו של שדה amount של האיבר (היחיד) בעל id=i אם קיים. אחרת, אם לא קיים איבר כזה, מוסיף איבר עם id=i, amount=x (לא נתון מצביע לאיבר)
2. ()whoIsMax מחזירה את ה-id עבורו שדה ה-amount מקסימלי (אם קיים יותר מאחד כזה, מחזירה אחד מהם)
3. (Reduce (i,y מפחיתה y מה-amount של האיבר בעל id=i (לא נתון מצביע לאיבר)

נניח כי כל ה-id נמצאים בטווח [1,3n].
תארו מבנה דטרמיניסטי התומך בפעולות 1-2 בזמן (1)O במקרה הגרוע ביותר (אין צורך לממש את פעולה 3).",נקצה מערך בגודל 3n. בכל קריאה ל-Add נעדכן התא המתאים במערך ונבדוק אם הוא המקסימום החדש על ידי השוואה לנוכחי. whoIsMax יחזיר את המקסימום שיישמר תמיד בשדה עזר.,,,,
A,TRUE,2017,A,B,2-b,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נדרש מבנה נתונים התומך בפעולות הבאות על איברים המכילים שני שדות – id, amount. בכל רגע נתון מספר האיברים במבנה אינו עולה על N.
1. (Add(i,x מגדילה ב-x ערכו של שדה amount של האיבר (היחיד) בעל id=i אם קיים. אחרת, אם לא קיים איבר כזה, מוסיף איבר עם id=i, amount=x (לא נתון מצביע לאיבר)
2. ()whoIsMax מחזירה את ה-id עבורו שדה ה-amount מקסימלי (אם קיים יותר מאחד כזה, מחזירה אחד מהם)
3. (Reduce (i,y מפחיתה y מה-amount של האיבר בעל id=i (לא נתון מצביע לאיבר)

נניח כי כל ה-id נמצאים בטווח [1,3n].
תארו מבנה דטרמיניסטי אשר בנוסף תומך בפעולה 3 בזמן (O(logn אמורטייזד. במקרה זה פעולה 1 תתבצע בזמן (1)O אמורטייזד ופעולה 2 תשאר בזמן (1)O במקרה הגרוע ביותר.","בנוסף למבנה שהשתמשנו בו בסעיף א' נחזיק ערימת פיבונאצ'י. בכל תא במערך נחזיק פוינטר לאיבר המתאים ערימה. בהכנסה (אם לא קיים) מעדכנים במערך ומוסיפים איבר לערימה – (1)O. אם האיבר קיים,
ההוספה לערימה תקח (1)O אמורטייזד. whoIsMax כמוקדם. בפעולה החדשה – נעדכן האיבר המתאים במערך, נעקוב אחרי הפוינטר לערימה ונבצע delete והכנסה מחדש לערימה (נעדכן המצביעים בהתאם).
(O(logn אמורטייזד.",,,,
A,TRUE,2017,A,B,2-c,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נדרש מבנה נתונים התומך בפעולות הבאות על איברים המכילים שני שדות – id, amount. בכל רגע נתון מספר האיברים במבנה אינו עולה על N.
1. (Add(i,x מגדילה ב-x ערכו של שדה amount של האיבר (היחיד) בעל id=i אם קיים. אחרת, אם לא קיים איבר כזה, מוסיף איבר עם id=i, amount=x (לא נתון מצביע לאיבר)
2. ()whoIsMax מחזירה את ה-id עבורו שדה ה-amount מקסימלי (אם קיים יותר מאחד כזה, מחזירה אחד מהם)
3. (Reduce (i,y מפחיתה y מה-amount של האיבר בעל id=i (לא נתון מצביע לאיבר)

נניח כי כל ה-id נמצאים בטווח [1,3n].
הסבירו מדוע לא ניתן לממש את כל הפעולות ב-(1)O אמורטייזד, אפילו בעזרת רנדומיות.","נראה סתירה לחסם המיון. נניח כי נתונה לנו קבוצה של n מספרים. נכניס אותם למבנה באמצעות Add עם id הגדל באחד כל פעם. כעת נבצע n פעמים whoIsMax לקבלת האיבר הגדול הבא, ונבצע עליו reduce(I,inf).",,,,
A,TRUE,2017,A,B,2-d,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נדרש מבנה נתונים התומך בפעולות הבאות על איברים המכילים שני שדות – id, amount. בכל רגע נתון מספר האיברים במבנה אינו עולה על N.
1. (Add(i,x מגדילה ב-x ערכו של שדה amount של האיבר (היחיד) בעל id=i אם קיים. אחרת, אם לא קיים איבר כזה, מוסיף איבר עם id=i, amount=x (לא נתון מצביע לאיבר)
2. ()whoIsMax מחזירה את ה-id עבורו שדה ה-amount מקסימלי (אם קיים יותר מאחד כזה, מחזירה אחד מהם)
3. (Reduce (i,y מפחיתה y מה-amount של האיבר בעל id=i (לא נתון מצביע לאיבר)

נניח כי כל ה-id נמצאים בטווח [1,3n]. נניח כי לא ניתנת הגבלה על טווח ה-id-ים.
תארו מבנה התומך בפעולה 1 בזמן (1)O בתוחלת אמורטייזד, בפעולה 2 בזמן .O(1) w.c ובפעולה 3 בזמן (O(logn אמורטייזד בתוחלת.","Add: נלך ל-hashtable עם ה-i key. אם לא קיים, נכניס לטבלה וכן לערימת פיבונאצ'י עם פוינטר בינהם. אם קיים, נעדכן פשוט בטבלה ובערימה. (1)O אמורטייזד בתוחלת. whoIsMax יחולץ כרגיל מהערימה.
Reduce: נעדכן בטבלה, ובעזרת הפוינטר נמחק ונוסיף מהערימה. סה""כ (O(logn אמורטייזד בתוחלת.",,,,
A,TRUE,2017,A,B,3-a,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"האם ניתן לממש עץ AVL כך שפעולת ה-insert תיקח במקרה הגרוע ביותר (1)O ופעולת ה-delete תיקח (O(n, כאשר n מספר האיברים בעץ?","לא ניתן. ניקח קבוצה כללית של מספרים בגודל n, נכניסם לעץ ונקבל אותם ממוינים על ידי in order walk ב-(O(n.",,,,
A,TRUE,2017,A,B,3-b,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"האם ניתן לממש עץ חיפוש כלשהו כך שפעולת ה-insert תיקח במקרה הגרוע ביותר (1)O ופעולת ה-delete תיקח (O(n, כאשר n מספר האיברים בעץ?","לא ניתן. ניקח קבוצה כללית של מספרים בגודל n, נכניסם לעץ ונקבל אותם ממוינים על ידי in order walk ב-(O(n.",,,,
A,TRUE,2017,A,B,3-c,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,האם ניתן לממש עץ AVL כך שנוסיף לו פעולה החזר את האיבר המינימלי שגדול שווה לממוצע האיברים בזמן (1)O מבלי לפגוע בזמן הריצה של שאר הפעולות?,"נחזיק מצביע עזר שיתוחזק בכל פעולת insert,delete ויצביע לאיבר הרלוונטי. ידרוש עדכון של הממוצע בכל שלב וחיפוש האיבר המתאים, מה שנכנס בזמן הריצה של (O(logn.",,,,
A,TRUE,2017,A,B,3-d,T3/ds17AB-sol.pdf,TAU,6.25,na,na,na,na,na,na,,"נגדיר עץ בינארי מסוג i-WAVL: ההגדרה זהה להגדרת עץ WAVL, פרט לכלל הפרשי הדרגות. בעץ מסוג i-WAVL הפרש הדרגות האפשרי בין צומת לבנו הוא בין 1 ל-i. חשבו חסם אסימפטוטי על גובהו המקסימלי של עץ i-AVL בן n איברים, כתלות ב-n וב-i.","בדומה לחישוב עבור-WAVL:
נסמן Sk מספר האיברים המינימלי בעץ i-WAVL ששורשו מדרגה k. אזי מתקיים sk = 1 +2sk-1, נוסחת נסיגה שפתרונה sk = 2^|k/i|     1. מכאן, אם מספר האיברים בעץ הינו n, דרגת השורש מקיימת k =< i · logn. בעץ -i WAVL מתקיים כי height =< rank, לכן החסם האחרוך הינו גם החסם על גובה העץ.",,,,
A,TRUE,2017,A,B,4-a,T3/ds17AB-sol.pdf,TAU,8.3,na,na,na,na,na,na,,"נרצה לתחזק מבנה נתונים המכיל קבוצות של מספרים. נניח שלכל קבוצה יש מספר מזהה ייחודיי. נגדיר אינטרוול רציף של מזהי קבוצות באופן הבא: בהינתן מערך ממוין A של כל מזהי הקבוצות, אינטרוול רציף של מזהים הינו קבוצה המכילה את כל האיברים בתת-מערך של A.
לדוגמא: נניח שמבנה הנתונים מכיל ברגע נתוך קבוצות עם המזהים {50 ,1,13,42}, אזי:
הקבוצה {1,13} היא אינטרוול רציף.
הקבוצה {13,42,250} היא אינטרוול רציף.
הקבוצה {1,42} היא אינה אינטרוול רציף.

נסמן ב-n את כמות הקבוצות וב-m את הגודל המקסימלי של קבוצה. כאשר ניתן יש להביע הסיבוכיות באמצעות m,n ו-|B|.

ממשו מבנה נתונים דטרמיניסטי התומך בפעולות:
(createSet(setId - יצירת קבוצה עם מזהה setId.
(insertToSets(B, E – בקבלת מערך המכיל איברי אינטרוול רציף של מזהים B (הקיימים במבנה) ומערך של אלמנטים E. יש להכניס את האיבר [E[i לקבוצה עם המזהה [B[i. שני המערכים זהים באורכם.","נחזיק עץ חיפוש בינארי מאוזן עם שהמפתחות בו הם מזהי הקבוצות. ב-createSet נכניס איבר חדש לעץ, שיצביע לעץ חיפוש בינארי מאוזן נפרד שיכיל את איברי הקבוצה ופוינטר למינימום שלו. (O(logn. עבור getMin נחפש בעץ הקבוצות ונחזיר המינימום של עץ הקבוצה המתאים.
getContMin: נמצא הצומת המתאים בעץ עבור הקבוצה עם המזהה המינימלי באינטרוול. נחזיר המינימום שלו ושל כל הקבוצות הבאות בעזרת קריאות עוקבות ל-successor. סה""כ (|O(logn+|B. בדומה נממש יתר הפעולות. זמני הריצה יהיו (((O(log(n)+|B|(1+log(m .",,,,
A,TRUE,2017,A,B,4-b,T3/ds17AB-sol.pdf,TAU,8.3,na,na,na,na,na,na,,"נרצה לתחזק מבנה נתונים המכיל קבוצות של מספרים. נניח שלכל קבוצה יש מספר מזהה ייחודיי. נגדיר אינטרוול רציף של מזהי קבוצות באופן הבא: בהינתן מערך ממוין A של כל מזהי הקבוצות, אינטרוול רציף של מזהים הינו קבוצה המכילה את כל האיברים בתת-מערך של A.
לדוגמא: נניח שמבנה הנתונים מכיל ברגע נתוך קבוצות עם המזהים {50 ,1,13,42}, אזי:
הקבוצה {1,13} היא אינטרוול רציף.
הקבוצה {13,42,250} היא אינטרוול רציף.
הקבוצה {1,42} היא אינה אינטרוול רציף.

נסמן ב-n את כמות הקבוצות וב-m את הגודל המקסימלי של קבוצה. כאשר ניתן יש להביע הסיבוכיות באמצעות m,n ו-|B|.

ממשו מבנה נתונים דטרמיניסטי התומך בפעולות:
(createSet(setId - יצירת קבוצה עם מזהה setId.
(insertToSets(B, E – בקבלת מערך המכיל איברי אינטרוול רציף של מזהים B (הקיימים במבנה) ומערך של אלמנטים E. יש להכניס את האיבר [E[i לקבוצה עם המזהה [B[i. שני המערכים זהים באורכם.
(getMin(setId - מחזירה המינימום של קבוצה עם מזהה setId.
(getContMin(B- מקבלת אינטרוול רציף של מזהים B ומחזירה מערך שמכיל את המינימום של כל קבוצה עם מזהה מ-B.","נחזיק עץ חיפוש בינארי מאוזן עם שהמפתחות בו הם מזהי הקבוצות. ב-createSet נכניס איבר חדש לעץ, שיצביע לעץ חיפוש בינארי מאוזן נפרד שיכיל את איברי הקבוצה ופוינטר למינימום שלו. (O(logn. עבור getMin נחפש בעץ הקבוצות ונחזיר המינימום של עץ הקבוצה המתאים.
getContMin: נמצא הצומת המתאים בעץ עבור הקבוצה עם המזהה המינימלי באינטרוול. נחזיר המינימום שלו ושל כל הקבוצות הבאות בעזרת קריאות עוקבות ל-successor. סה""כ (|O(logn+|B. בדומה נממש יתר הפעולות. זמני הריצה יהיו (((O(log(n)+|B|(1+log(m .",,,,
A,TRUE,2017,A,B,4-c,T3/ds17AB-sol.pdf,TAU,8.3,na,na,na,na,na,na,,"נרצה לתחזק מבנה נתונים המכיל קבוצות של מספרים. נניח שלכל קבוצה יש מספר מזהה ייחודיי. נגדיר אינטרוול רציף של מזהי קבוצות באופן הבא: בהינתן מערך ממוין A של כל מזהי הקבוצות, אינטרוול רציף של מזהים הינו קבוצה המכילה את כל האיברים בתת-מערך של A.
לדוגמא: נניח שמבנה הנתונים מכיל ברגע נתוך קבוצות עם המזהים {50 ,1,13,42}, אזי:
הקבוצה {1,13} היא אינטרוול רציף.
הקבוצה {13,42,250} היא אינטרוול רציף.
הקבוצה {1,42} היא אינה אינטרוול רציף.

נסמן ב-n את כמות הקבוצות וב-m את הגודל המקסימלי של קבוצה. כאשר ניתן יש להביע הסיבוכיות באמצעות m,n ו-|B|.

ממשו מבנה נתונים רנדומי התומך בפעולות:
(createSet(setId - יצירת קבוצה עם מזהה setId.
(insertToSets(B, E – בקבלת מערך המכיל איברי אינטרוול רציף של מזהים B (הקיימים במבנה) ומערך של אלמנטים E. יש להכניס את האיבר [E[i לקבוצה עם המזהה [B[i. שני המערכים זהים באורכם.","ניצור טבלת hash כפולה. לכל setId נכניס לטבלת האש בה ה-value הוא פוינטר לעוד טבלת hash. אופן מימוש הפעולות מיידי. הסיבוכיות של createId הינה (1)O בתוחלת, ושל יתר הפעולות (|O(|B בתוחלת.",,,,
A,FALSE,2016,B,B,1-a,T3/ds16 bb sol(vaad).pdf,TAU,5,na,na,na,na,na,na,,"מהו הערך המינימלי (כפונקציה של n) של מפתח שנמצא בעלה של ערימת מינימום בינארית המכילה את המפתחות 1,2…,n?",na,,,,תשובה בכתב יד 5/5
A,FALSE,2016,B,B,1-b,T3/ds16 bb sol(vaad).pdf,TAU,5,na,na,na,na,na,na,,"מהו הערך המקסימלי (כפונקציה של n) של מפתח שאינו נמצא בעלה של ערימת מינימום בינארית המכילה את המפתחות 1,2…,n?",na,,,,תשובה בכתב יד 3/5
A,FALSE,2016,B,B,2-a,T3/ds16 bb sol(vaad).pdf,TAU,5,na,na,na,na,na,na,,הוכיחו או הפריכו: קיים רצף insert/delete שיוצר עץ אדום-שחור עם 5 מפתחות בו כל הצמתים שחורים.,na,,,,תשובה בכתב יד 5/5
A,FALSE,2016,B,B,2-b,T3/ds16 bb sol(vaad).pdf,TAU,5,na,na,na,na,na,na,,הוכיחו או הפריכו: קיים רצף insert/delete שיוצר עץ אדום-שחור עם 3 מפתחות בו כל הצמתים שחורים.,na,,,,תשובה בכתב יד 5/5
A,FALSE,2016,B,B,3-a,T3/ds16 bb sol(vaad).pdf,TAU,15,na,na,na,na,na,na,,"נתונים m סוגי מוצרים שונים (ממוספרים מ-1 עד m), כאשר מכל סוג יש שני מוצרים. המכרז פתוח m ימים ובמהלכם אנשים מגישים סך של n הצעות לקנייה (כל הצעה עבור יחידת מוצר אחת). בסוף כל יום יימכרו זוג מוצרים מאותו הסוג שניתן להרוויח הכי הרבה כסף ממכירת שניהם.
התבקשתם לממש מבנה נתונים עבור המכירה התומך בפקודות הבאות:

• Init(m) - אתחול המבנה עם m סוגי מוצרים וללא הצעות.
• Bid(j,p) - הוספת הצעה במחיר p למוצר מסוג j. על הפקודה לרוץ בזמן O(1) אמורטייזד.
• Sell() -> j,p1,p2 - מכירה של זוג מוצרים מהסוג שניתן להרוויח הכי הרבה כסף ממכירתם (ניתן להניח שקיים סוג מוצר עם לפחות שתי הצעות על הפרק). הפקודה מחזירה את סוג המוצר j שנמכר ואת המחירים p1,p2 ששולמו על זוג היחידות. שאר ההצעות לסוג מוצר זה בטלות. על הפקודה לרוץ בזמן O(log m) אמורטייזד.",na,,,,תשובה בכתב יד 15/15
A,FALSE,2016,B,B,3-b,T3/ds16 bb sol(vaad).pdf,TAU,15,na,na,na,na,na,na,,"נתונים m  מוצרים שונים (ממוספרים מ-1 עד m). המכרז פתוח m ימים ובמהלכם אנשים מגישים סך של n הצעות לקנייה (כל הצעה עבור  מוצר אחד). בסוף כל יום יימכר המוצר שהוגשה עליו ההצעה הגבוהה ביותר מבין כל המוצרים.
התבקשתם לממש מבנה נתונים עבור המכירה התומך בפקודות הבאות:

• Init(m) - אתחול המבנה עם m סוגי מוצרים וללא הצעות.
• Bid(j,p) -> b - הוספת הצעה במחיר p למוצר מסוג j. הפקודה מחזירה כרטיס b באמצעותו ניתן יהיה לבטל את ההצעה. על הפקודה לרוץ בזמן O(1) אמורטייזד.
• Sell() -> j,p - מכירת המוצר שקיבל את ההצעה הגבוהה ביותר. הפקודה מחזירה את  המוצר j שנמכר ואת המחיר p ששולם עליו. שאר ההצעות למוצר זה בטלות. על הפקודה לרוץ בזמן O(log m) אמורטייזד.
• Revoke(b) - ביטול ההצעה המשויכת לכרטיס b. ניתן להניח שהמוצר הנדון טרם נמכר וההצעה טרם בוטלה. על הפקודה לרוץ בזמן  O(log n) אמורטייזד.",na,,,,תשובה בכתב יד 15/15
A,FALSE,2016,B,B,4,T3/ds16 bb sol(vaad).pdf,TAU,15,na,na,na,na,na,na,,"נתונה רשימת קטעים I_1,I_2,…,I_n. כל קטע הוא מהצורה I_j=(a_j,b_j) כאשר קצותיו הם מספרים טבעיים 0<=a_j<=b_j<=n^10. תארו אלגוריתם שמחשב את האורך שמכוסה ע״י הקטעים (קרי: המידה של איחודם). על האלגוריתם לרוץ בזמן O(n). 
דוגמא: עבור הקטעים (2,5),(3,7),(9,10) התשובה היא 6.",na,,,,תשובה בכתב יד 15/15
A,FALSE,2016,B,B,5-a,T3/ds16 bb sol(vaad).pdf,TAU,6,na,na,na,na,na,na,,"עבור עץ בינארי T עם עלים חיצוניים ומספר ממשי b>=1, נאמר ש-T הוא b-מאוזן אם היחס בין המרחק (בקשתות) מהשורש לעלה החיצוני הרחוק ביותר לבין המרחק (בקשתות) מהשורש לעלה החיצוני הקרוב ביותר אינו עולה על b. נאמר ש-T הוא b-מאוזן לגמרי אם כל תת עץ שלו הוא b מאוזן. 
הוכיחו או הפריכו: עץ בינארי על n צמתים שגובהו לכל היותר 3logn הוא 5-מאוזן לגמרי.",na,,,,תשובה בכתב יד 5/6
A,FALSE,2016,B,B,5-b,T3/ds16 bb sol(vaad).pdf,TAU,6,na,na,na,na,na,na,,"עבור עץ בינארי T עם עלים חיצוניים ומספר ממשי b>=1, נאמר ש-T הוא b-מאוזן אם היחס בין המרחק (בקשתות) מהשורש לעלה החיצוני הרחוק ביותר לבין המרחק (בקשתות) מהשורש לעלה החיצוני הקרוב ביותר אינו עולה על b. נאמר ש-T הוא b-מאוזן לגמרי אם כל תת עץ שלו הוא b מאוזן. 
הוכיחו או הפריכו: עץ בינארי על n צמתים  5-מאוזן לגמרי הוא בגובה O(logn).",na,,,,תשובה בכתב יד 6/6
A,FALSE,2016,B,B,5-c,T3/ds16 bb sol(vaad).pdf,TAU,8,na,na,na,na,na,na,,"עבור עץ בינארי T עם עלים חיצוניים ומספר ממשי b>=1, נאמר ש-T הוא b-מאוזן אם היחס בין המרחק (בקשתות) מהשורש לעלה החיצוני הרחוק ביותר לבין המרחק (בקשתות) מהשורש לעלה החיצוני הקרוב ביותר אינו עולה על b. נאמר ש-T הוא b-מאוזן לגמרי אם כל תת עץ שלו הוא b מאוזן. 
תארו אלגוריתם בסיבוכיות הטובה ביותר שמקבל עץ בינארי עם עלים חיצוניים T ומחשב b קטן ביותר כך ש-T הוא עץ b-מאוזן לגמרי.",na,,,,תשובה בכתב יד 4/8
A,FALSE,2016,B,B,6,T3/ds16 bb sol(vaad).pdf,TAU,15,na,na,na,na,na,na,,"במחשב נמצאים מספר רב של דפים על הדיסק. למחשב מגיע זרם של בקשות לדפים השונים. כדי לאפשר גישה מהירה לדפים, לרשותנו זיכרון מטמון בגודל n דפים ובו אנו שומרים את הדפים הנפוצים ביותר, כלומר אלו שנבקשו מספר רב יותר של פעמים (מודל  LFU).

דוגמא: נניח n = 3. לאחר זרם הבקשות 5,6,5,9,4,5,4,7 יכיל ה-cache את הדפים 5,4,7 כאשר 5 הוא הנפוץ ביותר (עם 3 בקשות) ו-7 הוא הנדיר ביותר (עם בקשה אחת). אם הבקשה הבאה היא לדף 3 אז 7 יפונה מה-cache.

הערה: ספירת הבקשות עבור דף מתאפסת כאשר מפנים אותו מה-cache.

עליכם לממש מבנה נתונים לשמירת ה-cache בתומך בפקודות הבאות:
• Init(n) - אתחול המבנה עם n מקומות לדפים וללא בקשות.
• Access(x) - גישה לדף x. אם הדף כבר נמצא במבנה, המבנה מעודכן עם מספר הבקשות החדש עבור x. אחרת, יש להכניס את הדף x כדף עם בקשה יחידה, ואם אין מקום לפנות דף אחר עם מספר בקשות נמוך ביותר. אם יש כמה דפים מועמדים לפינוי, ניתן למחוק אחד שרירותית. עח הפקודה לרוץ בזמן  O(1) בתוחלת.",na,,,,תשובה בכתב יד 10/15
A,TRUE,2014,A,B,1-a,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בערימה בינומית ביצענו n הכנסות ולאחר מכאן n פעמים delete-min.
האיברים ai מ-i=1 עד n, הוכנסו לפי הסדר. כלומר, קודם הוכנס איבר a1, אז a2 ובסוף הוכנס an. נניח שלאחר n ההכנסות, יש יותר מעץ אחד בערימה.
א. מה ניתן להגיד על היחס בין האינדקסים של האיברים בעץ מדרגה i לעומת האינדקסים של האיברים בעץ מדרגה j בערימה לאחר סדרת ההכנסות של הסדרה, כאשר i<j?",כל האינדקסים בעץ מדרגה j קטנים מכל האינדקסים בעץ מדרגה i.,,,,כל השאלה 20 נק
A,TRUE,2014,A,B,1-b,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בערימה בינומית ביצענו n הכנסות ולאחר מכאן n פעמים delete-min.
האיברים ai מ-i=1 עד n, הוכנסו לפי הסדר. כלומר, קודם הוכנס איבר a1, אז a2 ובסוף הוכנס an. נניח שלאחר n ההכנסות, יש יותר מעץ אחד בערימה.
ב. נבחן את מספר ה-linking בכל פעולה. ספקו חסם מדויק (לא אסימפטוטי) למספר ה-linking במקרה הגרוע של פעולת insert אחת, ושל כל פעולות insert בסדרה יחד.","חסם מס' linking לפעולת insert אחת:  logn
חסם מס' linking לסדרת פעולות insert: n",,,,כל השאלה 20 נק
A,TRUE,2014,A,B,1-c,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בערימה בינומית ביצענו n הכנסות ולאחר מכאן n פעמים delete-min.
האיברים ai מ-i=1 עד n, הוכנסו לפי הסדר. כלומר, קודם הוכנס איבר a1, אז a2 ובסוף הוכנס an. נניח שלאחר n ההכנסות, יש יותר מעץ אחד בערימה.
ג.  נתונה הסדרה ai = n-i, כלומר האיברים מוכנסים לערימה מהגדול לקטן. נבחן את מספר ה-linkings בכל פעולה. ספקו חסם מדויק (לא אסימפטוטי) למספר ה- linking במקרה הגרוע של delete-min אחד, ושל כל פעולות delete-min בסדרה יחד.","חסם מס' linking לפעולת delete אחת: 0
חסם מס' linking לסדרת פעולות :delete 0",,,,כל השאלה 20 נק
A,TRUE,2014,A,B,1-d,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בערימה בינומית ביצענו n הכנסות ולאחר מכאן n פעמים delete-min.
האיברים ai מ-i=1 עד n, הוכנסו לפי הסדר. כלומר, קודם הוכנס איבר a1, אז a2 ובסוף הוכנס an. נניח שלאחר n ההכנסות, יש יותר מעץ אחד בערימה.
ד. נניח שעבדנו על ערימה בינומית עצלה. בכל הכנסה העץ החדש נוסף לסוף רשימת העצים. בתהליך ה-successive linking, עוברים על העצים מסוף הרשימה לתחילתה. מה ניתן להגיד על היחס בין האינדקסים של האיברים בעץ מדרגה i לעומת האינדקסים של האיברים בעץ מדרגה j בערימה לאחר סדרת ההכנסות ופעולת del-min אחת (נניח שיש יותר מעץ אחד), כאשר i<j?",כל האינדקסים בעץ מדרגה j גדולים מכל האינדקסים בעץ מדרגה i.,,,,כל השאלה 20 נק
A,TRUE,2014,A,B,2-a,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,בונים טבלת hashing בגודל m בשיטת  ה-chaining. פונקצית ה-hash נבחרת באקראי ממשפחה אוניברסלית של פונקציות hash. לטבלה הוכנסו כבר n איברים שונים. מבצעים עתה חיפוש איבר x שנמצא כבר בטבלה. ספקו חסם טוב ככל האפשר (לא אסימפטוטי) על תוחלת מספר האיברים ברשימה שבה נמצא .x,1+(n-1)/m,,,,כל השאלה 20 נק
A,TRUE,2014,A,B,2-b,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בונים טבלת  hashing בגודל m בשיטת ה-open addressing (כלומר, כל האיברים נמצאים בטבלת ה-hashing ללא שימוש במצביעים). משתמשים בפונקציית hash מקרית לחלוטין מהצורה h(k,i), כאשר k הוא המפתח שאותו רוצים להכניס לטבלה ו-i הוא מספר הניסיון. (זאת שיטת ה-uniform probing. ערך המוחזר מקריאה ל-h(k,i) הוא שלם המוגרל יוניפורמית בין 2 ל-(m-1), בלתי-תלוי בהגרלות שבקריאות קודמות). לטבלה הוכנסו כבר n איברים שונים. מבצעים עתה חיפוש על איבר שאינו נמצא בטבלה. מה תוחלת מספר תאי הטבלה שנבדקים במהלך החיפוש? ספקו תשובה (לא אסימפטוטית) הדוקה ככל האפשר.",1/(1-n/m),,,,כל השאלה 20 נק
A,TRUE,2014,A,B,2-c,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"בונים טבלת  hashing בגודל m בשיטת ה-linear probing. מפתחות האיברים שמוכנסים לטבלה נלקחים מהקבוצה {0,1,…2m-1}. משתמשים בפונקצית ה-hash הבאה: h(k)=⌊k\2⌋. מכניסים לטבלה את האיברים 1,2,…m בסדר עולה. כמה זמן לוקחת הכנסת כל האיברים לטבלה תוך שימוש באלגוריתם ההכנסה הסטנדרטי? ספקו חסם אסימפטוטי.",זמן ריבועי,,,,כל השאלה 20 נק
A,TRUE,2014,A,B,2-d,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"תהא  U={0,1,…u}. הניחו שכל איבר של U ניתן לייצוג במילת מחשב אחת. נתונה תת-קבוצה D⊆U בגודל n. תארו אלגוריתם הסתברותי יעיל ככל האפשר שבונה פונקציה h:U→{0,1,…100n} שהיא חד-חד ערכית על  D. (כלומר לכל x,y∈D מתקיים h(x)!=h(y)). כמות הזיכרון הדרושה לייצוג הפונקציה h צריכה להיות  O(n). חישוב h(x), בהינתן x∈D צריך לקחת O(1) זמן במקרה הגרוע ביותר.",perfect hash,,,,כל השאלה 20 נק
A,TRUE,2014,A,B,3,T3/ds14ab-sol(vaad).pdf,TAU,32,na,na,na,na,na,na,,"נגדיר מערך זיג-זג, עבורו קיימים n ≤ j ≤ i ≤ 1 כלשהם כך שכל האיברים במערך בין 1 ל i בסדר עולה, כל האיברים בין i ל j בסדר יורד, וכל האיברים בין j ל n בסדר עולה. נקרא ל-i איבר הפסגה ול-j איבר העמק.
לכל בעיה ספקו חסם עליון ותחתון והוכיחו אותם.
בעיה א' - קלט: מערך. פלט: מחזיר TRUE אם""ם המערך הוא מערך זיגזג.
בעיה ב' - קלט: מערך זיגזג ומיקום איבר העמק. פלט: מיקום איבר הפסגה. 
בעיה ג' - קלט: מערך זיגזג. פלט: מיקום איבר הפסגה ואיבר העמק.","א': חסם עליון ותחתון n.
ב': חסם עליון ותחתון logn. 
ג': חסם עליון ותחתון n.",,,,
A,TRUE,2014,A,B,4-a,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"נתונים n קטעים על הישר (כלומר הקלט הוא n זוגות (x,y) של נקודות התחלה וסיום). קטע יקרא ""מרכזי"" אם יש לפחות n/4 קטעים שמתחילים לפניו (נקודת ההתחלה שלהם משמאל לנקודת ההתחלה שלו) וגם יש לפחות n/4 קטעים שמסתיימים אחריו (נקודת הסיום שלהם מימין לנקודת הסיום שלו). הציעו אלגוריתם שמחזיר את מספר הקטעים המרכזיים, בזמן ריצה W.C. הטוב ביותר שתוכלו, ונתחו את זמן הריצה שלו.","אפשר להריץ  select על n/4 ב-x ו-3n/4 ב-y, ולפי זה לזהות קטעים מרכזיים. זמן ריצה לינארי במספר הקטעים.",,,,כל השאלה 30 נק
A,TRUE,2014,A,B,4-b,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"הציעו מבנה נתונים דינמי, המאפשר Insert(x,y) ו-Delete(x,y) של קטעים על הישר בזמן W.C. O(logn) וכן בפעולה IsCentric(x,y) שמקבלת קטע במבנה, ועונה האם הקטע הוא מרכזי, בזמן O(1) .W.C. (שימו-לב ש-deleteלא מקבלת מצביע לקטע, אלא את הקואורדינאטות שלו.)","תאור המבנה: שני עצי-סדר סטטיסטי (עצי חופשי בינארי מאוזניים עם שדה size בצמתים). אחד לפי x והשני לפי y. מצביע לאיבר ה-n/4 ב-x ולאיבר ה-3n/4 ב-y.
מימוש פעולת insert וניתוח זמן ריצה: מכניסים לשני העצים ומבצעים select לעדכון המצביעים.
מימוש פעולת delete וניתוח זמן ריצה: מוחקים משני העצים ומבצעים select לעדכון המצביעים.
מימוש פעולת isCentric וניתוח זמן ריצה: בודקים את היחס לערכי x ו-y של המצביעים.",,,,כל השאלה 30 נק
A,TRUE,2014,A,B,4-c,T3/ds14ab-sol(vaad).pdf,TAU,na,na,na,na,na,na,na,,"הציעו מבנה נתונים דינמי, המאפשר Insert(x,y) ו-Delete(x,y) של קטעים (x,y) על הישר בזמן O(logn) בתוחלת, פעולת Find-Min(), המחזירה את הקטע הקצר ביותר בזמן קבוע, וזמן בנייה לינארי (כלומר, בהינתן n קטעים, ניתן לבנות את המבנה בזמן לינארי, כך שיכיל את כולם). ניתן להניח שכל הקטעים באורכים שונים (שימו-לב ש- delete לא מקבלת מצביע לקטע, אלא את הקואורדינאטות שלו.)","תיאור מבנה נתונים: ערימת מינימום וטבלת האש עם מצביעים הדדיים. המפתח זה אורך הקטע.
מימוש פעולת Find-Min וניתוח זמן ריצה: להחזיר את את שורש הערימה (פעולת min של הערימה.)
מימוש פעולות delete insert, וניתוח זמן ריצה: בהכנסה מכניסים לערימה וגם לטבלה, ומעדכנים בטבלה מצביע למיקום בערימה. במחיקה מוצאים את המפתח בטבלת האש ולפי זה מקבלים מצביע ומוחקים בערימה. מוחקים גם מהטבלה. בהכנסה או מחיקה – אם מיקום השתנה צריך לעדכן את המצביע בטבלת האש.
מימוש תהליך הבנייה וניתוח זמן ריצה: בונים ערימה בינארית בזמן לינארי. מכניסים כל איבר לטבלת האש  chaining, לראש הרשימה, ומעדכנים באותו זמן את המצביע למיקום בערימה.",,,,כל השאלה 30 נק
